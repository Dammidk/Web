
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Vehiculo
 * 
 */
export type Vehiculo = $Result.DefaultSelection<Prisma.$VehiculoPayload>
/**
 * Model Chofer
 * 
 */
export type Chofer = $Result.DefaultSelection<Prisma.$ChoferPayload>
/**
 * Model Cliente
 * 
 */
export type Cliente = $Result.DefaultSelection<Prisma.$ClientePayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model Viaje
 * 
 */
export type Viaje = $Result.DefaultSelection<Prisma.$ViajePayload>
/**
 * Model GastoViaje
 * 
 */
export type GastoViaje = $Result.DefaultSelection<Prisma.$GastoViajePayload>
/**
 * Model Comprobante
 * 
 */
export type Comprobante = $Result.DefaultSelection<Prisma.$ComprobantePayload>
/**
 * Model Mantenimiento
 * 
 */
export type Mantenimiento = $Result.DefaultSelection<Prisma.$MantenimientoPayload>
/**
 * Model PagoChofer
 * 
 */
export type PagoChofer = $Result.DefaultSelection<Prisma.$PagoChoferPayload>
/**
 * Model RegistroAuditoria
 * 
 */
export type RegistroAuditoria = $Result.DefaultSelection<Prisma.$RegistroAuditoriaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const RolUsuario: {
  ADMIN: 'ADMIN',
  AUDITOR: 'AUDITOR'
};

export type RolUsuario = (typeof RolUsuario)[keyof typeof RolUsuario]


export const EstadoVehiculo: {
  ACTIVO: 'ACTIVO',
  EN_RUTA: 'EN_RUTA',
  EN_MANTENIMIENTO: 'EN_MANTENIMIENTO',
  INACTIVO: 'INACTIVO'
};

export type EstadoVehiculo = (typeof EstadoVehiculo)[keyof typeof EstadoVehiculo]


export const EstadoChofer: {
  ACTIVO: 'ACTIVO',
  INACTIVO: 'INACTIVO'
};

export type EstadoChofer = (typeof EstadoChofer)[keyof typeof EstadoChofer]


export const ModalidadPago: {
  POR_VIAJE: 'POR_VIAJE',
  MENSUAL: 'MENSUAL'
};

export type ModalidadPago = (typeof ModalidadPago)[keyof typeof ModalidadPago]


export const MetodoPago: {
  EFECTIVO: 'EFECTIVO',
  TRANSFERENCIA: 'TRANSFERENCIA',
  TARJETA: 'TARJETA'
};

export type MetodoPago = (typeof MetodoPago)[keyof typeof MetodoPago]


export const EstadoCliente: {
  ACTIVO: 'ACTIVO',
  INACTIVO: 'INACTIVO'
};

export type EstadoCliente = (typeof EstadoCliente)[keyof typeof EstadoCliente]


export const EstadoPagoCliente: {
  PENDIENTE: 'PENDIENTE',
  PARCIAL: 'PARCIAL',
  PAGADO: 'PAGADO'
};

export type EstadoPagoCliente = (typeof EstadoPagoCliente)[keyof typeof EstadoPagoCliente]


export const EstadoViaje: {
  PLANIFICADO: 'PLANIFICADO',
  EN_CURSO: 'EN_CURSO',
  COMPLETADO: 'COMPLETADO',
  CANCELADO: 'CANCELADO'
};

export type EstadoViaje = (typeof EstadoViaje)[keyof typeof EstadoViaje]


export const TipoGasto: {
  COMBUSTIBLE: 'COMBUSTIBLE',
  PEAJE: 'PEAJE',
  ALIMENTACION: 'ALIMENTACION',
  HOSPEDAJE: 'HOSPEDAJE',
  MULTA: 'MULTA',
  OTRO: 'OTRO'
};

export type TipoGasto = (typeof TipoGasto)[keyof typeof TipoGasto]


export const TipoComprobante: {
  GASTO_VIAJE: 'GASTO_VIAJE',
  MANTENIMIENTO: 'MANTENIMIENTO',
  PAGO_CHOFER: 'PAGO_CHOFER'
};

export type TipoComprobante = (typeof TipoComprobante)[keyof typeof TipoComprobante]


export const TipoMantenimiento: {
  PREVENTIVO: 'PREVENTIVO',
  CORRECTIVO: 'CORRECTIVO'
};

export type TipoMantenimiento = (typeof TipoMantenimiento)[keyof typeof TipoMantenimiento]


export const EstadoMantenimiento: {
  PENDIENTE: 'PENDIENTE',
  EN_CURSO: 'EN_CURSO',
  COMPLETADO: 'COMPLETADO',
  CANCELADO: 'CANCELADO'
};

export type EstadoMantenimiento = (typeof EstadoMantenimiento)[keyof typeof EstadoMantenimiento]


export const EstadoPagoChofer: {
  PENDIENTE: 'PENDIENTE',
  PAGADO: 'PAGADO'
};

export type EstadoPagoChofer = (typeof EstadoPagoChofer)[keyof typeof EstadoPagoChofer]


export const AccionAuditoria: {
  CREAR: 'CREAR',
  EDITAR: 'EDITAR',
  ELIMINAR: 'ELIMINAR'
};

export type AccionAuditoria = (typeof AccionAuditoria)[keyof typeof AccionAuditoria]

}

export type RolUsuario = $Enums.RolUsuario

export const RolUsuario: typeof $Enums.RolUsuario

export type EstadoVehiculo = $Enums.EstadoVehiculo

export const EstadoVehiculo: typeof $Enums.EstadoVehiculo

export type EstadoChofer = $Enums.EstadoChofer

export const EstadoChofer: typeof $Enums.EstadoChofer

export type ModalidadPago = $Enums.ModalidadPago

export const ModalidadPago: typeof $Enums.ModalidadPago

export type MetodoPago = $Enums.MetodoPago

export const MetodoPago: typeof $Enums.MetodoPago

export type EstadoCliente = $Enums.EstadoCliente

export const EstadoCliente: typeof $Enums.EstadoCliente

export type EstadoPagoCliente = $Enums.EstadoPagoCliente

export const EstadoPagoCliente: typeof $Enums.EstadoPagoCliente

export type EstadoViaje = $Enums.EstadoViaje

export const EstadoViaje: typeof $Enums.EstadoViaje

export type TipoGasto = $Enums.TipoGasto

export const TipoGasto: typeof $Enums.TipoGasto

export type TipoComprobante = $Enums.TipoComprobante

export const TipoComprobante: typeof $Enums.TipoComprobante

export type TipoMantenimiento = $Enums.TipoMantenimiento

export const TipoMantenimiento: typeof $Enums.TipoMantenimiento

export type EstadoMantenimiento = $Enums.EstadoMantenimiento

export const EstadoMantenimiento: typeof $Enums.EstadoMantenimiento

export type EstadoPagoChofer = $Enums.EstadoPagoChofer

export const EstadoPagoChofer: typeof $Enums.EstadoPagoChofer

export type AccionAuditoria = $Enums.AccionAuditoria

export const AccionAuditoria: typeof $Enums.AccionAuditoria

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.vehiculo`: Exposes CRUD operations for the **Vehiculo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehiculos
    * const vehiculos = await prisma.vehiculo.findMany()
    * ```
    */
  get vehiculo(): Prisma.VehiculoDelegate<ExtArgs>;

  /**
   * `prisma.chofer`: Exposes CRUD operations for the **Chofer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chofers
    * const chofers = await prisma.chofer.findMany()
    * ```
    */
  get chofer(): Prisma.ChoferDelegate<ExtArgs>;

  /**
   * `prisma.cliente`: Exposes CRUD operations for the **Cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.ClienteDelegate<ExtArgs>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs>;

  /**
   * `prisma.viaje`: Exposes CRUD operations for the **Viaje** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Viajes
    * const viajes = await prisma.viaje.findMany()
    * ```
    */
  get viaje(): Prisma.ViajeDelegate<ExtArgs>;

  /**
   * `prisma.gastoViaje`: Exposes CRUD operations for the **GastoViaje** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GastoViajes
    * const gastoViajes = await prisma.gastoViaje.findMany()
    * ```
    */
  get gastoViaje(): Prisma.GastoViajeDelegate<ExtArgs>;

  /**
   * `prisma.comprobante`: Exposes CRUD operations for the **Comprobante** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comprobantes
    * const comprobantes = await prisma.comprobante.findMany()
    * ```
    */
  get comprobante(): Prisma.ComprobanteDelegate<ExtArgs>;

  /**
   * `prisma.mantenimiento`: Exposes CRUD operations for the **Mantenimiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mantenimientos
    * const mantenimientos = await prisma.mantenimiento.findMany()
    * ```
    */
  get mantenimiento(): Prisma.MantenimientoDelegate<ExtArgs>;

  /**
   * `prisma.pagoChofer`: Exposes CRUD operations for the **PagoChofer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PagoChofers
    * const pagoChofers = await prisma.pagoChofer.findMany()
    * ```
    */
  get pagoChofer(): Prisma.PagoChoferDelegate<ExtArgs>;

  /**
   * `prisma.registroAuditoria`: Exposes CRUD operations for the **RegistroAuditoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegistroAuditorias
    * const registroAuditorias = await prisma.registroAuditoria.findMany()
    * ```
    */
  get registroAuditoria(): Prisma.RegistroAuditoriaDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Vehiculo: 'Vehiculo',
    Chofer: 'Chofer',
    Cliente: 'Cliente',
    Material: 'Material',
    Viaje: 'Viaje',
    GastoViaje: 'GastoViaje',
    Comprobante: 'Comprobante',
    Mantenimiento: 'Mantenimiento',
    PagoChofer: 'PagoChofer',
    RegistroAuditoria: 'RegistroAuditoria'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "usuario" | "vehiculo" | "chofer" | "cliente" | "material" | "viaje" | "gastoViaje" | "comprobante" | "mantenimiento" | "pagoChofer" | "registroAuditoria"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Vehiculo: {
        payload: Prisma.$VehiculoPayload<ExtArgs>
        fields: Prisma.VehiculoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehiculoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehiculoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculoPayload>
          }
          findFirst: {
            args: Prisma.VehiculoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehiculoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculoPayload>
          }
          findMany: {
            args: Prisma.VehiculoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculoPayload>[]
          }
          create: {
            args: Prisma.VehiculoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculoPayload>
          }
          createMany: {
            args: Prisma.VehiculoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehiculoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculoPayload>[]
          }
          delete: {
            args: Prisma.VehiculoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculoPayload>
          }
          update: {
            args: Prisma.VehiculoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculoPayload>
          }
          deleteMany: {
            args: Prisma.VehiculoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehiculoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehiculoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiculoPayload>
          }
          aggregate: {
            args: Prisma.VehiculoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehiculo>
          }
          groupBy: {
            args: Prisma.VehiculoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehiculoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehiculoCountArgs<ExtArgs>
            result: $Utils.Optional<VehiculoCountAggregateOutputType> | number
          }
        }
      }
      Chofer: {
        payload: Prisma.$ChoferPayload<ExtArgs>
        fields: Prisma.ChoferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChoferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChoferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoferPayload>
          }
          findFirst: {
            args: Prisma.ChoferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChoferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoferPayload>
          }
          findMany: {
            args: Prisma.ChoferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoferPayload>[]
          }
          create: {
            args: Prisma.ChoferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoferPayload>
          }
          createMany: {
            args: Prisma.ChoferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChoferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoferPayload>[]
          }
          delete: {
            args: Prisma.ChoferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoferPayload>
          }
          update: {
            args: Prisma.ChoferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoferPayload>
          }
          deleteMany: {
            args: Prisma.ChoferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChoferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChoferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoferPayload>
          }
          aggregate: {
            args: Prisma.ChoferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChofer>
          }
          groupBy: {
            args: Prisma.ChoferGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChoferGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChoferCountArgs<ExtArgs>
            result: $Utils.Optional<ChoferCountAggregateOutputType> | number
          }
        }
      }
      Cliente: {
        payload: Prisma.$ClientePayload<ExtArgs>
        fields: Prisma.ClienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findFirst: {
            args: Prisma.ClienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findMany: {
            args: Prisma.ClienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          create: {
            args: Prisma.ClienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          createMany: {
            args: Prisma.ClienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          delete: {
            args: Prisma.ClienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          update: {
            args: Prisma.ClienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          deleteMany: {
            args: Prisma.ClienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCliente>
          }
          groupBy: {
            args: Prisma.ClienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      Viaje: {
        payload: Prisma.$ViajePayload<ExtArgs>
        fields: Prisma.ViajeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViajeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViajePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViajeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViajePayload>
          }
          findFirst: {
            args: Prisma.ViajeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViajePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViajeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViajePayload>
          }
          findMany: {
            args: Prisma.ViajeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViajePayload>[]
          }
          create: {
            args: Prisma.ViajeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViajePayload>
          }
          createMany: {
            args: Prisma.ViajeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViajeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViajePayload>[]
          }
          delete: {
            args: Prisma.ViajeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViajePayload>
          }
          update: {
            args: Prisma.ViajeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViajePayload>
          }
          deleteMany: {
            args: Prisma.ViajeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViajeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ViajeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViajePayload>
          }
          aggregate: {
            args: Prisma.ViajeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViaje>
          }
          groupBy: {
            args: Prisma.ViajeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViajeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViajeCountArgs<ExtArgs>
            result: $Utils.Optional<ViajeCountAggregateOutputType> | number
          }
        }
      }
      GastoViaje: {
        payload: Prisma.$GastoViajePayload<ExtArgs>
        fields: Prisma.GastoViajeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GastoViajeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GastoViajePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GastoViajeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GastoViajePayload>
          }
          findFirst: {
            args: Prisma.GastoViajeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GastoViajePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GastoViajeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GastoViajePayload>
          }
          findMany: {
            args: Prisma.GastoViajeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GastoViajePayload>[]
          }
          create: {
            args: Prisma.GastoViajeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GastoViajePayload>
          }
          createMany: {
            args: Prisma.GastoViajeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GastoViajeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GastoViajePayload>[]
          }
          delete: {
            args: Prisma.GastoViajeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GastoViajePayload>
          }
          update: {
            args: Prisma.GastoViajeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GastoViajePayload>
          }
          deleteMany: {
            args: Prisma.GastoViajeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GastoViajeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GastoViajeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GastoViajePayload>
          }
          aggregate: {
            args: Prisma.GastoViajeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGastoViaje>
          }
          groupBy: {
            args: Prisma.GastoViajeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GastoViajeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GastoViajeCountArgs<ExtArgs>
            result: $Utils.Optional<GastoViajeCountAggregateOutputType> | number
          }
        }
      }
      Comprobante: {
        payload: Prisma.$ComprobantePayload<ExtArgs>
        fields: Prisma.ComprobanteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComprobanteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComprobanteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>
          }
          findFirst: {
            args: Prisma.ComprobanteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComprobanteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>
          }
          findMany: {
            args: Prisma.ComprobanteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>[]
          }
          create: {
            args: Prisma.ComprobanteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>
          }
          createMany: {
            args: Prisma.ComprobanteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComprobanteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>[]
          }
          delete: {
            args: Prisma.ComprobanteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>
          }
          update: {
            args: Prisma.ComprobanteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>
          }
          deleteMany: {
            args: Prisma.ComprobanteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComprobanteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComprobanteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>
          }
          aggregate: {
            args: Prisma.ComprobanteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComprobante>
          }
          groupBy: {
            args: Prisma.ComprobanteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComprobanteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComprobanteCountArgs<ExtArgs>
            result: $Utils.Optional<ComprobanteCountAggregateOutputType> | number
          }
        }
      }
      Mantenimiento: {
        payload: Prisma.$MantenimientoPayload<ExtArgs>
        fields: Prisma.MantenimientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MantenimientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MantenimientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MantenimientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MantenimientoPayload>
          }
          findFirst: {
            args: Prisma.MantenimientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MantenimientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MantenimientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MantenimientoPayload>
          }
          findMany: {
            args: Prisma.MantenimientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MantenimientoPayload>[]
          }
          create: {
            args: Prisma.MantenimientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MantenimientoPayload>
          }
          createMany: {
            args: Prisma.MantenimientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MantenimientoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MantenimientoPayload>[]
          }
          delete: {
            args: Prisma.MantenimientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MantenimientoPayload>
          }
          update: {
            args: Prisma.MantenimientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MantenimientoPayload>
          }
          deleteMany: {
            args: Prisma.MantenimientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MantenimientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MantenimientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MantenimientoPayload>
          }
          aggregate: {
            args: Prisma.MantenimientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMantenimiento>
          }
          groupBy: {
            args: Prisma.MantenimientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MantenimientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.MantenimientoCountArgs<ExtArgs>
            result: $Utils.Optional<MantenimientoCountAggregateOutputType> | number
          }
        }
      }
      PagoChofer: {
        payload: Prisma.$PagoChoferPayload<ExtArgs>
        fields: Prisma.PagoChoferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagoChoferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoChoferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagoChoferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoChoferPayload>
          }
          findFirst: {
            args: Prisma.PagoChoferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoChoferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagoChoferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoChoferPayload>
          }
          findMany: {
            args: Prisma.PagoChoferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoChoferPayload>[]
          }
          create: {
            args: Prisma.PagoChoferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoChoferPayload>
          }
          createMany: {
            args: Prisma.PagoChoferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PagoChoferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoChoferPayload>[]
          }
          delete: {
            args: Prisma.PagoChoferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoChoferPayload>
          }
          update: {
            args: Prisma.PagoChoferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoChoferPayload>
          }
          deleteMany: {
            args: Prisma.PagoChoferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PagoChoferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PagoChoferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoChoferPayload>
          }
          aggregate: {
            args: Prisma.PagoChoferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePagoChofer>
          }
          groupBy: {
            args: Prisma.PagoChoferGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagoChoferGroupByOutputType>[]
          }
          count: {
            args: Prisma.PagoChoferCountArgs<ExtArgs>
            result: $Utils.Optional<PagoChoferCountAggregateOutputType> | number
          }
        }
      }
      RegistroAuditoria: {
        payload: Prisma.$RegistroAuditoriaPayload<ExtArgs>
        fields: Prisma.RegistroAuditoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegistroAuditoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAuditoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegistroAuditoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAuditoriaPayload>
          }
          findFirst: {
            args: Prisma.RegistroAuditoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAuditoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegistroAuditoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAuditoriaPayload>
          }
          findMany: {
            args: Prisma.RegistroAuditoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAuditoriaPayload>[]
          }
          create: {
            args: Prisma.RegistroAuditoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAuditoriaPayload>
          }
          createMany: {
            args: Prisma.RegistroAuditoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegistroAuditoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAuditoriaPayload>[]
          }
          delete: {
            args: Prisma.RegistroAuditoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAuditoriaPayload>
          }
          update: {
            args: Prisma.RegistroAuditoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAuditoriaPayload>
          }
          deleteMany: {
            args: Prisma.RegistroAuditoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegistroAuditoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RegistroAuditoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAuditoriaPayload>
          }
          aggregate: {
            args: Prisma.RegistroAuditoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegistroAuditoria>
          }
          groupBy: {
            args: Prisma.RegistroAuditoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegistroAuditoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegistroAuditoriaCountArgs<ExtArgs>
            result: $Utils.Optional<RegistroAuditoriaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    registrosAuditoria: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    registrosAuditoria?: boolean | UsuarioCountOutputTypeCountRegistrosAuditoriaArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountRegistrosAuditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegistroAuditoriaWhereInput
  }


  /**
   * Count Type VehiculoCountOutputType
   */

  export type VehiculoCountOutputType = {
    viajes: number
    mantenimientos: number
  }

  export type VehiculoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viajes?: boolean | VehiculoCountOutputTypeCountViajesArgs
    mantenimientos?: boolean | VehiculoCountOutputTypeCountMantenimientosArgs
  }

  // Custom InputTypes
  /**
   * VehiculoCountOutputType without action
   */
  export type VehiculoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiculoCountOutputType
     */
    select?: VehiculoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehiculoCountOutputType without action
   */
  export type VehiculoCountOutputTypeCountViajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViajeWhereInput
  }

  /**
   * VehiculoCountOutputType without action
   */
  export type VehiculoCountOutputTypeCountMantenimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MantenimientoWhereInput
  }


  /**
   * Count Type ChoferCountOutputType
   */

  export type ChoferCountOutputType = {
    viajes: number
    pagos: number
  }

  export type ChoferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viajes?: boolean | ChoferCountOutputTypeCountViajesArgs
    pagos?: boolean | ChoferCountOutputTypeCountPagosArgs
  }

  // Custom InputTypes
  /**
   * ChoferCountOutputType without action
   */
  export type ChoferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoferCountOutputType
     */
    select?: ChoferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChoferCountOutputType without action
   */
  export type ChoferCountOutputTypeCountViajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViajeWhereInput
  }

  /**
   * ChoferCountOutputType without action
   */
  export type ChoferCountOutputTypeCountPagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoChoferWhereInput
  }


  /**
   * Count Type ClienteCountOutputType
   */

  export type ClienteCountOutputType = {
    viajes: number
  }

  export type ClienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viajes?: boolean | ClienteCountOutputTypeCountViajesArgs
  }

  // Custom InputTypes
  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteCountOutputType
     */
    select?: ClienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountViajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViajeWhereInput
  }


  /**
   * Count Type MaterialCountOutputType
   */

  export type MaterialCountOutputType = {
    viajes: number
  }

  export type MaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viajes?: boolean | MaterialCountOutputTypeCountViajesArgs
  }

  // Custom InputTypes
  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCountOutputType
     */
    select?: MaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountViajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViajeWhereInput
  }


  /**
   * Count Type ViajeCountOutputType
   */

  export type ViajeCountOutputType = {
    gastos: number
    pagos: number
  }

  export type ViajeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gastos?: boolean | ViajeCountOutputTypeCountGastosArgs
    pagos?: boolean | ViajeCountOutputTypeCountPagosArgs
  }

  // Custom InputTypes
  /**
   * ViajeCountOutputType without action
   */
  export type ViajeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViajeCountOutputType
     */
    select?: ViajeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ViajeCountOutputType without action
   */
  export type ViajeCountOutputTypeCountGastosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GastoViajeWhereInput
  }

  /**
   * ViajeCountOutputType without action
   */
  export type ViajeCountOutputTypeCountPagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoChoferWhereInput
  }


  /**
   * Count Type ComprobanteCountOutputType
   */

  export type ComprobanteCountOutputType = {
    gastosViaje: number
    mantenimientos: number
    pagosChofer: number
  }

  export type ComprobanteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gastosViaje?: boolean | ComprobanteCountOutputTypeCountGastosViajeArgs
    mantenimientos?: boolean | ComprobanteCountOutputTypeCountMantenimientosArgs
    pagosChofer?: boolean | ComprobanteCountOutputTypeCountPagosChoferArgs
  }

  // Custom InputTypes
  /**
   * ComprobanteCountOutputType without action
   */
  export type ComprobanteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComprobanteCountOutputType
     */
    select?: ComprobanteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComprobanteCountOutputType without action
   */
  export type ComprobanteCountOutputTypeCountGastosViajeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GastoViajeWhereInput
  }

  /**
   * ComprobanteCountOutputType without action
   */
  export type ComprobanteCountOutputTypeCountMantenimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MantenimientoWhereInput
  }

  /**
   * ComprobanteCountOutputType without action
   */
  export type ComprobanteCountOutputTypeCountPagosChoferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoChoferWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nombreUsuario: string | null
    email: string | null
    passwordHash: string | null
    nombreCompleto: string | null
    rol: $Enums.RolUsuario | null
    activo: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    deletedAt: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nombreUsuario: string | null
    email: string | null
    passwordHash: string | null
    nombreCompleto: string | null
    rol: $Enums.RolUsuario | null
    activo: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    deletedAt: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombreUsuario: number
    email: number
    passwordHash: number
    nombreCompleto: number
    rol: number
    activo: number
    creadoEn: number
    actualizadoEn: number
    deletedAt: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nombreUsuario?: true
    email?: true
    passwordHash?: true
    nombreCompleto?: true
    rol?: true
    activo?: true
    creadoEn?: true
    actualizadoEn?: true
    deletedAt?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombreUsuario?: true
    email?: true
    passwordHash?: true
    nombreCompleto?: true
    rol?: true
    activo?: true
    creadoEn?: true
    actualizadoEn?: true
    deletedAt?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombreUsuario?: true
    email?: true
    passwordHash?: true
    nombreCompleto?: true
    rol?: true
    activo?: true
    creadoEn?: true
    actualizadoEn?: true
    deletedAt?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    nombreUsuario: string
    email: string
    passwordHash: string
    nombreCompleto: string
    rol: $Enums.RolUsuario
    activo: boolean
    creadoEn: Date
    actualizadoEn: Date
    deletedAt: Date | null
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombreUsuario?: boolean
    email?: boolean
    passwordHash?: boolean
    nombreCompleto?: boolean
    rol?: boolean
    activo?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    deletedAt?: boolean
    registrosAuditoria?: boolean | Usuario$registrosAuditoriaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombreUsuario?: boolean
    email?: boolean
    passwordHash?: boolean
    nombreCompleto?: boolean
    rol?: boolean
    activo?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    nombreUsuario?: boolean
    email?: boolean
    passwordHash?: boolean
    nombreCompleto?: boolean
    rol?: boolean
    activo?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    deletedAt?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    registrosAuditoria?: boolean | Usuario$registrosAuditoriaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      registrosAuditoria: Prisma.$RegistroAuditoriaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombreUsuario: string
      email: string
      passwordHash: string
      nombreCompleto: string
      rol: $Enums.RolUsuario
      activo: boolean
      creadoEn: Date
      actualizadoEn: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    registrosAuditoria<T extends Usuario$registrosAuditoriaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$registrosAuditoriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistroAuditoriaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly nombreUsuario: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly passwordHash: FieldRef<"Usuario", 'String'>
    readonly nombreCompleto: FieldRef<"Usuario", 'String'>
    readonly rol: FieldRef<"Usuario", 'RolUsuario'>
    readonly activo: FieldRef<"Usuario", 'Boolean'>
    readonly creadoEn: FieldRef<"Usuario", 'DateTime'>
    readonly actualizadoEn: FieldRef<"Usuario", 'DateTime'>
    readonly deletedAt: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.registrosAuditoria
   */
  export type Usuario$registrosAuditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAuditoria
     */
    select?: RegistroAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAuditoriaInclude<ExtArgs> | null
    where?: RegistroAuditoriaWhereInput
    orderBy?: RegistroAuditoriaOrderByWithRelationInput | RegistroAuditoriaOrderByWithRelationInput[]
    cursor?: RegistroAuditoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegistroAuditoriaScalarFieldEnum | RegistroAuditoriaScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Vehiculo
   */

  export type AggregateVehiculo = {
    _count: VehiculoCountAggregateOutputType | null
    _avg: VehiculoAvgAggregateOutputType | null
    _sum: VehiculoSumAggregateOutputType | null
    _min: VehiculoMinAggregateOutputType | null
    _max: VehiculoMaxAggregateOutputType | null
  }

  export type VehiculoAvgAggregateOutputType = {
    id: number | null
    anio: number | null
    kilometrajeActual: number | null
  }

  export type VehiculoSumAggregateOutputType = {
    id: number | null
    anio: number | null
    kilometrajeActual: number | null
  }

  export type VehiculoMinAggregateOutputType = {
    id: number | null
    placa: string | null
    marca: string | null
    modelo: string | null
    anio: number | null
    tipo: string | null
    capacidad: string | null
    estado: $Enums.EstadoVehiculo | null
    kilometrajeActual: number | null
    fechaUltimoMantenimiento: Date | null
    fechaProximoMantenimiento: Date | null
    fechaVencimientoSoat: Date | null
    fechaVencimientoSeguro: Date | null
    fechaVencimientoMatricula: Date | null
    observaciones: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    deletedAt: Date | null
  }

  export type VehiculoMaxAggregateOutputType = {
    id: number | null
    placa: string | null
    marca: string | null
    modelo: string | null
    anio: number | null
    tipo: string | null
    capacidad: string | null
    estado: $Enums.EstadoVehiculo | null
    kilometrajeActual: number | null
    fechaUltimoMantenimiento: Date | null
    fechaProximoMantenimiento: Date | null
    fechaVencimientoSoat: Date | null
    fechaVencimientoSeguro: Date | null
    fechaVencimientoMatricula: Date | null
    observaciones: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    deletedAt: Date | null
  }

  export type VehiculoCountAggregateOutputType = {
    id: number
    placa: number
    marca: number
    modelo: number
    anio: number
    tipo: number
    capacidad: number
    estado: number
    kilometrajeActual: number
    fechaUltimoMantenimiento: number
    fechaProximoMantenimiento: number
    fechaVencimientoSoat: number
    fechaVencimientoSeguro: number
    fechaVencimientoMatricula: number
    observaciones: number
    creadoEn: number
    actualizadoEn: number
    deletedAt: number
    _all: number
  }


  export type VehiculoAvgAggregateInputType = {
    id?: true
    anio?: true
    kilometrajeActual?: true
  }

  export type VehiculoSumAggregateInputType = {
    id?: true
    anio?: true
    kilometrajeActual?: true
  }

  export type VehiculoMinAggregateInputType = {
    id?: true
    placa?: true
    marca?: true
    modelo?: true
    anio?: true
    tipo?: true
    capacidad?: true
    estado?: true
    kilometrajeActual?: true
    fechaUltimoMantenimiento?: true
    fechaProximoMantenimiento?: true
    fechaVencimientoSoat?: true
    fechaVencimientoSeguro?: true
    fechaVencimientoMatricula?: true
    observaciones?: true
    creadoEn?: true
    actualizadoEn?: true
    deletedAt?: true
  }

  export type VehiculoMaxAggregateInputType = {
    id?: true
    placa?: true
    marca?: true
    modelo?: true
    anio?: true
    tipo?: true
    capacidad?: true
    estado?: true
    kilometrajeActual?: true
    fechaUltimoMantenimiento?: true
    fechaProximoMantenimiento?: true
    fechaVencimientoSoat?: true
    fechaVencimientoSeguro?: true
    fechaVencimientoMatricula?: true
    observaciones?: true
    creadoEn?: true
    actualizadoEn?: true
    deletedAt?: true
  }

  export type VehiculoCountAggregateInputType = {
    id?: true
    placa?: true
    marca?: true
    modelo?: true
    anio?: true
    tipo?: true
    capacidad?: true
    estado?: true
    kilometrajeActual?: true
    fechaUltimoMantenimiento?: true
    fechaProximoMantenimiento?: true
    fechaVencimientoSoat?: true
    fechaVencimientoSeguro?: true
    fechaVencimientoMatricula?: true
    observaciones?: true
    creadoEn?: true
    actualizadoEn?: true
    deletedAt?: true
    _all?: true
  }

  export type VehiculoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehiculo to aggregate.
     */
    where?: VehiculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehiculos to fetch.
     */
    orderBy?: VehiculoOrderByWithRelationInput | VehiculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehiculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehiculos
    **/
    _count?: true | VehiculoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehiculoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehiculoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehiculoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehiculoMaxAggregateInputType
  }

  export type GetVehiculoAggregateType<T extends VehiculoAggregateArgs> = {
        [P in keyof T & keyof AggregateVehiculo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehiculo[P]>
      : GetScalarType<T[P], AggregateVehiculo[P]>
  }




  export type VehiculoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehiculoWhereInput
    orderBy?: VehiculoOrderByWithAggregationInput | VehiculoOrderByWithAggregationInput[]
    by: VehiculoScalarFieldEnum[] | VehiculoScalarFieldEnum
    having?: VehiculoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehiculoCountAggregateInputType | true
    _avg?: VehiculoAvgAggregateInputType
    _sum?: VehiculoSumAggregateInputType
    _min?: VehiculoMinAggregateInputType
    _max?: VehiculoMaxAggregateInputType
  }

  export type VehiculoGroupByOutputType = {
    id: number
    placa: string
    marca: string
    modelo: string
    anio: number
    tipo: string
    capacidad: string
    estado: $Enums.EstadoVehiculo
    kilometrajeActual: number
    fechaUltimoMantenimiento: Date | null
    fechaProximoMantenimiento: Date | null
    fechaVencimientoSoat: Date | null
    fechaVencimientoSeguro: Date | null
    fechaVencimientoMatricula: Date | null
    observaciones: string | null
    creadoEn: Date
    actualizadoEn: Date
    deletedAt: Date | null
    _count: VehiculoCountAggregateOutputType | null
    _avg: VehiculoAvgAggregateOutputType | null
    _sum: VehiculoSumAggregateOutputType | null
    _min: VehiculoMinAggregateOutputType | null
    _max: VehiculoMaxAggregateOutputType | null
  }

  type GetVehiculoGroupByPayload<T extends VehiculoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehiculoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehiculoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehiculoGroupByOutputType[P]>
            : GetScalarType<T[P], VehiculoGroupByOutputType[P]>
        }
      >
    >


  export type VehiculoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placa?: boolean
    marca?: boolean
    modelo?: boolean
    anio?: boolean
    tipo?: boolean
    capacidad?: boolean
    estado?: boolean
    kilometrajeActual?: boolean
    fechaUltimoMantenimiento?: boolean
    fechaProximoMantenimiento?: boolean
    fechaVencimientoSoat?: boolean
    fechaVencimientoSeguro?: boolean
    fechaVencimientoMatricula?: boolean
    observaciones?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    deletedAt?: boolean
    viajes?: boolean | Vehiculo$viajesArgs<ExtArgs>
    mantenimientos?: boolean | Vehiculo$mantenimientosArgs<ExtArgs>
    _count?: boolean | VehiculoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehiculo"]>

  export type VehiculoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placa?: boolean
    marca?: boolean
    modelo?: boolean
    anio?: boolean
    tipo?: boolean
    capacidad?: boolean
    estado?: boolean
    kilometrajeActual?: boolean
    fechaUltimoMantenimiento?: boolean
    fechaProximoMantenimiento?: boolean
    fechaVencimientoSoat?: boolean
    fechaVencimientoSeguro?: boolean
    fechaVencimientoMatricula?: boolean
    observaciones?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["vehiculo"]>

  export type VehiculoSelectScalar = {
    id?: boolean
    placa?: boolean
    marca?: boolean
    modelo?: boolean
    anio?: boolean
    tipo?: boolean
    capacidad?: boolean
    estado?: boolean
    kilometrajeActual?: boolean
    fechaUltimoMantenimiento?: boolean
    fechaProximoMantenimiento?: boolean
    fechaVencimientoSoat?: boolean
    fechaVencimientoSeguro?: boolean
    fechaVencimientoMatricula?: boolean
    observaciones?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    deletedAt?: boolean
  }

  export type VehiculoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viajes?: boolean | Vehiculo$viajesArgs<ExtArgs>
    mantenimientos?: boolean | Vehiculo$mantenimientosArgs<ExtArgs>
    _count?: boolean | VehiculoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehiculoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VehiculoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehiculo"
    objects: {
      viajes: Prisma.$ViajePayload<ExtArgs>[]
      mantenimientos: Prisma.$MantenimientoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      placa: string
      marca: string
      modelo: string
      anio: number
      tipo: string
      capacidad: string
      estado: $Enums.EstadoVehiculo
      kilometrajeActual: number
      fechaUltimoMantenimiento: Date | null
      fechaProximoMantenimiento: Date | null
      fechaVencimientoSoat: Date | null
      fechaVencimientoSeguro: Date | null
      fechaVencimientoMatricula: Date | null
      observaciones: string | null
      creadoEn: Date
      actualizadoEn: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["vehiculo"]>
    composites: {}
  }

  type VehiculoGetPayload<S extends boolean | null | undefined | VehiculoDefaultArgs> = $Result.GetResult<Prisma.$VehiculoPayload, S>

  type VehiculoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehiculoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehiculoCountAggregateInputType | true
    }

  export interface VehiculoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehiculo'], meta: { name: 'Vehiculo' } }
    /**
     * Find zero or one Vehiculo that matches the filter.
     * @param {VehiculoFindUniqueArgs} args - Arguments to find a Vehiculo
     * @example
     * // Get one Vehiculo
     * const vehiculo = await prisma.vehiculo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehiculoFindUniqueArgs>(args: SelectSubset<T, VehiculoFindUniqueArgs<ExtArgs>>): Prisma__VehiculoClient<$Result.GetResult<Prisma.$VehiculoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vehiculo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VehiculoFindUniqueOrThrowArgs} args - Arguments to find a Vehiculo
     * @example
     * // Get one Vehiculo
     * const vehiculo = await prisma.vehiculo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehiculoFindUniqueOrThrowArgs>(args: SelectSubset<T, VehiculoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehiculoClient<$Result.GetResult<Prisma.$VehiculoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vehiculo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiculoFindFirstArgs} args - Arguments to find a Vehiculo
     * @example
     * // Get one Vehiculo
     * const vehiculo = await prisma.vehiculo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehiculoFindFirstArgs>(args?: SelectSubset<T, VehiculoFindFirstArgs<ExtArgs>>): Prisma__VehiculoClient<$Result.GetResult<Prisma.$VehiculoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vehiculo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiculoFindFirstOrThrowArgs} args - Arguments to find a Vehiculo
     * @example
     * // Get one Vehiculo
     * const vehiculo = await prisma.vehiculo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehiculoFindFirstOrThrowArgs>(args?: SelectSubset<T, VehiculoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehiculoClient<$Result.GetResult<Prisma.$VehiculoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vehiculos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiculoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehiculos
     * const vehiculos = await prisma.vehiculo.findMany()
     * 
     * // Get first 10 Vehiculos
     * const vehiculos = await prisma.vehiculo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehiculoWithIdOnly = await prisma.vehiculo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehiculoFindManyArgs>(args?: SelectSubset<T, VehiculoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiculoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vehiculo.
     * @param {VehiculoCreateArgs} args - Arguments to create a Vehiculo.
     * @example
     * // Create one Vehiculo
     * const Vehiculo = await prisma.vehiculo.create({
     *   data: {
     *     // ... data to create a Vehiculo
     *   }
     * })
     * 
     */
    create<T extends VehiculoCreateArgs>(args: SelectSubset<T, VehiculoCreateArgs<ExtArgs>>): Prisma__VehiculoClient<$Result.GetResult<Prisma.$VehiculoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vehiculos.
     * @param {VehiculoCreateManyArgs} args - Arguments to create many Vehiculos.
     * @example
     * // Create many Vehiculos
     * const vehiculo = await prisma.vehiculo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehiculoCreateManyArgs>(args?: SelectSubset<T, VehiculoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehiculos and returns the data saved in the database.
     * @param {VehiculoCreateManyAndReturnArgs} args - Arguments to create many Vehiculos.
     * @example
     * // Create many Vehiculos
     * const vehiculo = await prisma.vehiculo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehiculos and only return the `id`
     * const vehiculoWithIdOnly = await prisma.vehiculo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehiculoCreateManyAndReturnArgs>(args?: SelectSubset<T, VehiculoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiculoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vehiculo.
     * @param {VehiculoDeleteArgs} args - Arguments to delete one Vehiculo.
     * @example
     * // Delete one Vehiculo
     * const Vehiculo = await prisma.vehiculo.delete({
     *   where: {
     *     // ... filter to delete one Vehiculo
     *   }
     * })
     * 
     */
    delete<T extends VehiculoDeleteArgs>(args: SelectSubset<T, VehiculoDeleteArgs<ExtArgs>>): Prisma__VehiculoClient<$Result.GetResult<Prisma.$VehiculoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vehiculo.
     * @param {VehiculoUpdateArgs} args - Arguments to update one Vehiculo.
     * @example
     * // Update one Vehiculo
     * const vehiculo = await prisma.vehiculo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehiculoUpdateArgs>(args: SelectSubset<T, VehiculoUpdateArgs<ExtArgs>>): Prisma__VehiculoClient<$Result.GetResult<Prisma.$VehiculoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vehiculos.
     * @param {VehiculoDeleteManyArgs} args - Arguments to filter Vehiculos to delete.
     * @example
     * // Delete a few Vehiculos
     * const { count } = await prisma.vehiculo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehiculoDeleteManyArgs>(args?: SelectSubset<T, VehiculoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiculoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehiculos
     * const vehiculo = await prisma.vehiculo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehiculoUpdateManyArgs>(args: SelectSubset<T, VehiculoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehiculo.
     * @param {VehiculoUpsertArgs} args - Arguments to update or create a Vehiculo.
     * @example
     * // Update or create a Vehiculo
     * const vehiculo = await prisma.vehiculo.upsert({
     *   create: {
     *     // ... data to create a Vehiculo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehiculo we want to update
     *   }
     * })
     */
    upsert<T extends VehiculoUpsertArgs>(args: SelectSubset<T, VehiculoUpsertArgs<ExtArgs>>): Prisma__VehiculoClient<$Result.GetResult<Prisma.$VehiculoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vehiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiculoCountArgs} args - Arguments to filter Vehiculos to count.
     * @example
     * // Count the number of Vehiculos
     * const count = await prisma.vehiculo.count({
     *   where: {
     *     // ... the filter for the Vehiculos we want to count
     *   }
     * })
    **/
    count<T extends VehiculoCountArgs>(
      args?: Subset<T, VehiculoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehiculoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehiculo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiculoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehiculoAggregateArgs>(args: Subset<T, VehiculoAggregateArgs>): Prisma.PrismaPromise<GetVehiculoAggregateType<T>>

    /**
     * Group by Vehiculo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiculoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehiculoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehiculoGroupByArgs['orderBy'] }
        : { orderBy?: VehiculoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehiculoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehiculoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehiculo model
   */
  readonly fields: VehiculoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehiculo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehiculoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    viajes<T extends Vehiculo$viajesArgs<ExtArgs> = {}>(args?: Subset<T, Vehiculo$viajesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "findMany"> | Null>
    mantenimientos<T extends Vehiculo$mantenimientosArgs<ExtArgs> = {}>(args?: Subset<T, Vehiculo$mantenimientosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MantenimientoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehiculo model
   */ 
  interface VehiculoFieldRefs {
    readonly id: FieldRef<"Vehiculo", 'Int'>
    readonly placa: FieldRef<"Vehiculo", 'String'>
    readonly marca: FieldRef<"Vehiculo", 'String'>
    readonly modelo: FieldRef<"Vehiculo", 'String'>
    readonly anio: FieldRef<"Vehiculo", 'Int'>
    readonly tipo: FieldRef<"Vehiculo", 'String'>
    readonly capacidad: FieldRef<"Vehiculo", 'String'>
    readonly estado: FieldRef<"Vehiculo", 'EstadoVehiculo'>
    readonly kilometrajeActual: FieldRef<"Vehiculo", 'Int'>
    readonly fechaUltimoMantenimiento: FieldRef<"Vehiculo", 'DateTime'>
    readonly fechaProximoMantenimiento: FieldRef<"Vehiculo", 'DateTime'>
    readonly fechaVencimientoSoat: FieldRef<"Vehiculo", 'DateTime'>
    readonly fechaVencimientoSeguro: FieldRef<"Vehiculo", 'DateTime'>
    readonly fechaVencimientoMatricula: FieldRef<"Vehiculo", 'DateTime'>
    readonly observaciones: FieldRef<"Vehiculo", 'String'>
    readonly creadoEn: FieldRef<"Vehiculo", 'DateTime'>
    readonly actualizadoEn: FieldRef<"Vehiculo", 'DateTime'>
    readonly deletedAt: FieldRef<"Vehiculo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vehiculo findUnique
   */
  export type VehiculoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehiculo
     */
    select?: VehiculoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiculoInclude<ExtArgs> | null
    /**
     * Filter, which Vehiculo to fetch.
     */
    where: VehiculoWhereUniqueInput
  }

  /**
   * Vehiculo findUniqueOrThrow
   */
  export type VehiculoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehiculo
     */
    select?: VehiculoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiculoInclude<ExtArgs> | null
    /**
     * Filter, which Vehiculo to fetch.
     */
    where: VehiculoWhereUniqueInput
  }

  /**
   * Vehiculo findFirst
   */
  export type VehiculoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehiculo
     */
    select?: VehiculoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiculoInclude<ExtArgs> | null
    /**
     * Filter, which Vehiculo to fetch.
     */
    where?: VehiculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehiculos to fetch.
     */
    orderBy?: VehiculoOrderByWithRelationInput | VehiculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehiculos.
     */
    cursor?: VehiculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehiculos.
     */
    distinct?: VehiculoScalarFieldEnum | VehiculoScalarFieldEnum[]
  }

  /**
   * Vehiculo findFirstOrThrow
   */
  export type VehiculoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehiculo
     */
    select?: VehiculoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiculoInclude<ExtArgs> | null
    /**
     * Filter, which Vehiculo to fetch.
     */
    where?: VehiculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehiculos to fetch.
     */
    orderBy?: VehiculoOrderByWithRelationInput | VehiculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehiculos.
     */
    cursor?: VehiculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehiculos.
     */
    distinct?: VehiculoScalarFieldEnum | VehiculoScalarFieldEnum[]
  }

  /**
   * Vehiculo findMany
   */
  export type VehiculoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehiculo
     */
    select?: VehiculoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiculoInclude<ExtArgs> | null
    /**
     * Filter, which Vehiculos to fetch.
     */
    where?: VehiculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehiculos to fetch.
     */
    orderBy?: VehiculoOrderByWithRelationInput | VehiculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehiculos.
     */
    cursor?: VehiculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehiculos.
     */
    skip?: number
    distinct?: VehiculoScalarFieldEnum | VehiculoScalarFieldEnum[]
  }

  /**
   * Vehiculo create
   */
  export type VehiculoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehiculo
     */
    select?: VehiculoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiculoInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehiculo.
     */
    data: XOR<VehiculoCreateInput, VehiculoUncheckedCreateInput>
  }

  /**
   * Vehiculo createMany
   */
  export type VehiculoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehiculos.
     */
    data: VehiculoCreateManyInput | VehiculoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehiculo createManyAndReturn
   */
  export type VehiculoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehiculo
     */
    select?: VehiculoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Vehiculos.
     */
    data: VehiculoCreateManyInput | VehiculoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehiculo update
   */
  export type VehiculoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehiculo
     */
    select?: VehiculoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiculoInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehiculo.
     */
    data: XOR<VehiculoUpdateInput, VehiculoUncheckedUpdateInput>
    /**
     * Choose, which Vehiculo to update.
     */
    where: VehiculoWhereUniqueInput
  }

  /**
   * Vehiculo updateMany
   */
  export type VehiculoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehiculos.
     */
    data: XOR<VehiculoUpdateManyMutationInput, VehiculoUncheckedUpdateManyInput>
    /**
     * Filter which Vehiculos to update
     */
    where?: VehiculoWhereInput
  }

  /**
   * Vehiculo upsert
   */
  export type VehiculoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehiculo
     */
    select?: VehiculoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiculoInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehiculo to update in case it exists.
     */
    where: VehiculoWhereUniqueInput
    /**
     * In case the Vehiculo found by the `where` argument doesn't exist, create a new Vehiculo with this data.
     */
    create: XOR<VehiculoCreateInput, VehiculoUncheckedCreateInput>
    /**
     * In case the Vehiculo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehiculoUpdateInput, VehiculoUncheckedUpdateInput>
  }

  /**
   * Vehiculo delete
   */
  export type VehiculoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehiculo
     */
    select?: VehiculoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiculoInclude<ExtArgs> | null
    /**
     * Filter which Vehiculo to delete.
     */
    where: VehiculoWhereUniqueInput
  }

  /**
   * Vehiculo deleteMany
   */
  export type VehiculoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehiculos to delete
     */
    where?: VehiculoWhereInput
  }

  /**
   * Vehiculo.viajes
   */
  export type Vehiculo$viajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeInclude<ExtArgs> | null
    where?: ViajeWhereInput
    orderBy?: ViajeOrderByWithRelationInput | ViajeOrderByWithRelationInput[]
    cursor?: ViajeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViajeScalarFieldEnum | ViajeScalarFieldEnum[]
  }

  /**
   * Vehiculo.mantenimientos
   */
  export type Vehiculo$mantenimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mantenimiento
     */
    select?: MantenimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MantenimientoInclude<ExtArgs> | null
    where?: MantenimientoWhereInput
    orderBy?: MantenimientoOrderByWithRelationInput | MantenimientoOrderByWithRelationInput[]
    cursor?: MantenimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MantenimientoScalarFieldEnum | MantenimientoScalarFieldEnum[]
  }

  /**
   * Vehiculo without action
   */
  export type VehiculoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehiculo
     */
    select?: VehiculoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehiculoInclude<ExtArgs> | null
  }


  /**
   * Model Chofer
   */

  export type AggregateChofer = {
    _count: ChoferCountAggregateOutputType | null
    _avg: ChoferAvgAggregateOutputType | null
    _sum: ChoferSumAggregateOutputType | null
    _min: ChoferMinAggregateOutputType | null
    _max: ChoferMaxAggregateOutputType | null
  }

  export type ChoferAvgAggregateOutputType = {
    id: number | null
    sueldoMensual: Decimal | null
    diaPago: number | null
  }

  export type ChoferSumAggregateOutputType = {
    id: number | null
    sueldoMensual: Decimal | null
    diaPago: number | null
  }

  export type ChoferMinAggregateOutputType = {
    id: number | null
    nombres: string | null
    apellidos: string | null
    documentoId: string | null
    telefono: string | null
    fechaVencimientoLicencia: Date | null
    correo: string | null
    estado: $Enums.EstadoChofer | null
    modalidadPago: $Enums.ModalidadPago | null
    metodoPago: $Enums.MetodoPago | null
    banco: string | null
    numeroCuenta: string | null
    sueldoMensual: Decimal | null
    fechaContratacion: Date | null
    diaPago: number | null
    pagoQuincenal: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    deletedAt: Date | null
  }

  export type ChoferMaxAggregateOutputType = {
    id: number | null
    nombres: string | null
    apellidos: string | null
    documentoId: string | null
    telefono: string | null
    fechaVencimientoLicencia: Date | null
    correo: string | null
    estado: $Enums.EstadoChofer | null
    modalidadPago: $Enums.ModalidadPago | null
    metodoPago: $Enums.MetodoPago | null
    banco: string | null
    numeroCuenta: string | null
    sueldoMensual: Decimal | null
    fechaContratacion: Date | null
    diaPago: number | null
    pagoQuincenal: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    deletedAt: Date | null
  }

  export type ChoferCountAggregateOutputType = {
    id: number
    nombres: number
    apellidos: number
    documentoId: number
    telefono: number
    fechaVencimientoLicencia: number
    correo: number
    estado: number
    modalidadPago: number
    metodoPago: number
    banco: number
    numeroCuenta: number
    sueldoMensual: number
    fechaContratacion: number
    diaPago: number
    pagoQuincenal: number
    creadoEn: number
    actualizadoEn: number
    deletedAt: number
    _all: number
  }


  export type ChoferAvgAggregateInputType = {
    id?: true
    sueldoMensual?: true
    diaPago?: true
  }

  export type ChoferSumAggregateInputType = {
    id?: true
    sueldoMensual?: true
    diaPago?: true
  }

  export type ChoferMinAggregateInputType = {
    id?: true
    nombres?: true
    apellidos?: true
    documentoId?: true
    telefono?: true
    fechaVencimientoLicencia?: true
    correo?: true
    estado?: true
    modalidadPago?: true
    metodoPago?: true
    banco?: true
    numeroCuenta?: true
    sueldoMensual?: true
    fechaContratacion?: true
    diaPago?: true
    pagoQuincenal?: true
    creadoEn?: true
    actualizadoEn?: true
    deletedAt?: true
  }

  export type ChoferMaxAggregateInputType = {
    id?: true
    nombres?: true
    apellidos?: true
    documentoId?: true
    telefono?: true
    fechaVencimientoLicencia?: true
    correo?: true
    estado?: true
    modalidadPago?: true
    metodoPago?: true
    banco?: true
    numeroCuenta?: true
    sueldoMensual?: true
    fechaContratacion?: true
    diaPago?: true
    pagoQuincenal?: true
    creadoEn?: true
    actualizadoEn?: true
    deletedAt?: true
  }

  export type ChoferCountAggregateInputType = {
    id?: true
    nombres?: true
    apellidos?: true
    documentoId?: true
    telefono?: true
    fechaVencimientoLicencia?: true
    correo?: true
    estado?: true
    modalidadPago?: true
    metodoPago?: true
    banco?: true
    numeroCuenta?: true
    sueldoMensual?: true
    fechaContratacion?: true
    diaPago?: true
    pagoQuincenal?: true
    creadoEn?: true
    actualizadoEn?: true
    deletedAt?: true
    _all?: true
  }

  export type ChoferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chofer to aggregate.
     */
    where?: ChoferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chofers to fetch.
     */
    orderBy?: ChoferOrderByWithRelationInput | ChoferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chofers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chofers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chofers
    **/
    _count?: true | ChoferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChoferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChoferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoferMaxAggregateInputType
  }

  export type GetChoferAggregateType<T extends ChoferAggregateArgs> = {
        [P in keyof T & keyof AggregateChofer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChofer[P]>
      : GetScalarType<T[P], AggregateChofer[P]>
  }




  export type ChoferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoferWhereInput
    orderBy?: ChoferOrderByWithAggregationInput | ChoferOrderByWithAggregationInput[]
    by: ChoferScalarFieldEnum[] | ChoferScalarFieldEnum
    having?: ChoferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoferCountAggregateInputType | true
    _avg?: ChoferAvgAggregateInputType
    _sum?: ChoferSumAggregateInputType
    _min?: ChoferMinAggregateInputType
    _max?: ChoferMaxAggregateInputType
  }

  export type ChoferGroupByOutputType = {
    id: number
    nombres: string
    apellidos: string
    documentoId: string
    telefono: string | null
    fechaVencimientoLicencia: Date | null
    correo: string | null
    estado: $Enums.EstadoChofer
    modalidadPago: $Enums.ModalidadPago
    metodoPago: $Enums.MetodoPago
    banco: string | null
    numeroCuenta: string | null
    sueldoMensual: Decimal | null
    fechaContratacion: Date | null
    diaPago: number | null
    pagoQuincenal: boolean
    creadoEn: Date
    actualizadoEn: Date
    deletedAt: Date | null
    _count: ChoferCountAggregateOutputType | null
    _avg: ChoferAvgAggregateOutputType | null
    _sum: ChoferSumAggregateOutputType | null
    _min: ChoferMinAggregateOutputType | null
    _max: ChoferMaxAggregateOutputType | null
  }

  type GetChoferGroupByPayload<T extends ChoferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChoferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoferGroupByOutputType[P]>
            : GetScalarType<T[P], ChoferGroupByOutputType[P]>
        }
      >
    >


  export type ChoferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombres?: boolean
    apellidos?: boolean
    documentoId?: boolean
    telefono?: boolean
    fechaVencimientoLicencia?: boolean
    correo?: boolean
    estado?: boolean
    modalidadPago?: boolean
    metodoPago?: boolean
    banco?: boolean
    numeroCuenta?: boolean
    sueldoMensual?: boolean
    fechaContratacion?: boolean
    diaPago?: boolean
    pagoQuincenal?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    deletedAt?: boolean
    viajes?: boolean | Chofer$viajesArgs<ExtArgs>
    pagos?: boolean | Chofer$pagosArgs<ExtArgs>
    _count?: boolean | ChoferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chofer"]>

  export type ChoferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombres?: boolean
    apellidos?: boolean
    documentoId?: boolean
    telefono?: boolean
    fechaVencimientoLicencia?: boolean
    correo?: boolean
    estado?: boolean
    modalidadPago?: boolean
    metodoPago?: boolean
    banco?: boolean
    numeroCuenta?: boolean
    sueldoMensual?: boolean
    fechaContratacion?: boolean
    diaPago?: boolean
    pagoQuincenal?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["chofer"]>

  export type ChoferSelectScalar = {
    id?: boolean
    nombres?: boolean
    apellidos?: boolean
    documentoId?: boolean
    telefono?: boolean
    fechaVencimientoLicencia?: boolean
    correo?: boolean
    estado?: boolean
    modalidadPago?: boolean
    metodoPago?: boolean
    banco?: boolean
    numeroCuenta?: boolean
    sueldoMensual?: boolean
    fechaContratacion?: boolean
    diaPago?: boolean
    pagoQuincenal?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    deletedAt?: boolean
  }

  export type ChoferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viajes?: boolean | Chofer$viajesArgs<ExtArgs>
    pagos?: boolean | Chofer$pagosArgs<ExtArgs>
    _count?: boolean | ChoferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChoferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChoferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chofer"
    objects: {
      viajes: Prisma.$ViajePayload<ExtArgs>[]
      pagos: Prisma.$PagoChoferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombres: string
      apellidos: string
      documentoId: string
      telefono: string | null
      fechaVencimientoLicencia: Date | null
      correo: string | null
      estado: $Enums.EstadoChofer
      modalidadPago: $Enums.ModalidadPago
      metodoPago: $Enums.MetodoPago
      banco: string | null
      numeroCuenta: string | null
      sueldoMensual: Prisma.Decimal | null
      fechaContratacion: Date | null
      diaPago: number | null
      pagoQuincenal: boolean
      creadoEn: Date
      actualizadoEn: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["chofer"]>
    composites: {}
  }

  type ChoferGetPayload<S extends boolean | null | undefined | ChoferDefaultArgs> = $Result.GetResult<Prisma.$ChoferPayload, S>

  type ChoferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChoferFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChoferCountAggregateInputType | true
    }

  export interface ChoferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chofer'], meta: { name: 'Chofer' } }
    /**
     * Find zero or one Chofer that matches the filter.
     * @param {ChoferFindUniqueArgs} args - Arguments to find a Chofer
     * @example
     * // Get one Chofer
     * const chofer = await prisma.chofer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChoferFindUniqueArgs>(args: SelectSubset<T, ChoferFindUniqueArgs<ExtArgs>>): Prisma__ChoferClient<$Result.GetResult<Prisma.$ChoferPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chofer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChoferFindUniqueOrThrowArgs} args - Arguments to find a Chofer
     * @example
     * // Get one Chofer
     * const chofer = await prisma.chofer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChoferFindUniqueOrThrowArgs>(args: SelectSubset<T, ChoferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChoferClient<$Result.GetResult<Prisma.$ChoferPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chofer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoferFindFirstArgs} args - Arguments to find a Chofer
     * @example
     * // Get one Chofer
     * const chofer = await prisma.chofer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChoferFindFirstArgs>(args?: SelectSubset<T, ChoferFindFirstArgs<ExtArgs>>): Prisma__ChoferClient<$Result.GetResult<Prisma.$ChoferPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chofer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoferFindFirstOrThrowArgs} args - Arguments to find a Chofer
     * @example
     * // Get one Chofer
     * const chofer = await prisma.chofer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChoferFindFirstOrThrowArgs>(args?: SelectSubset<T, ChoferFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChoferClient<$Result.GetResult<Prisma.$ChoferPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chofers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chofers
     * const chofers = await prisma.chofer.findMany()
     * 
     * // Get first 10 Chofers
     * const chofers = await prisma.chofer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const choferWithIdOnly = await prisma.chofer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChoferFindManyArgs>(args?: SelectSubset<T, ChoferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoferPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chofer.
     * @param {ChoferCreateArgs} args - Arguments to create a Chofer.
     * @example
     * // Create one Chofer
     * const Chofer = await prisma.chofer.create({
     *   data: {
     *     // ... data to create a Chofer
     *   }
     * })
     * 
     */
    create<T extends ChoferCreateArgs>(args: SelectSubset<T, ChoferCreateArgs<ExtArgs>>): Prisma__ChoferClient<$Result.GetResult<Prisma.$ChoferPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chofers.
     * @param {ChoferCreateManyArgs} args - Arguments to create many Chofers.
     * @example
     * // Create many Chofers
     * const chofer = await prisma.chofer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChoferCreateManyArgs>(args?: SelectSubset<T, ChoferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chofers and returns the data saved in the database.
     * @param {ChoferCreateManyAndReturnArgs} args - Arguments to create many Chofers.
     * @example
     * // Create many Chofers
     * const chofer = await prisma.chofer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chofers and only return the `id`
     * const choferWithIdOnly = await prisma.chofer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChoferCreateManyAndReturnArgs>(args?: SelectSubset<T, ChoferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoferPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chofer.
     * @param {ChoferDeleteArgs} args - Arguments to delete one Chofer.
     * @example
     * // Delete one Chofer
     * const Chofer = await prisma.chofer.delete({
     *   where: {
     *     // ... filter to delete one Chofer
     *   }
     * })
     * 
     */
    delete<T extends ChoferDeleteArgs>(args: SelectSubset<T, ChoferDeleteArgs<ExtArgs>>): Prisma__ChoferClient<$Result.GetResult<Prisma.$ChoferPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chofer.
     * @param {ChoferUpdateArgs} args - Arguments to update one Chofer.
     * @example
     * // Update one Chofer
     * const chofer = await prisma.chofer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChoferUpdateArgs>(args: SelectSubset<T, ChoferUpdateArgs<ExtArgs>>): Prisma__ChoferClient<$Result.GetResult<Prisma.$ChoferPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chofers.
     * @param {ChoferDeleteManyArgs} args - Arguments to filter Chofers to delete.
     * @example
     * // Delete a few Chofers
     * const { count } = await prisma.chofer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChoferDeleteManyArgs>(args?: SelectSubset<T, ChoferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chofers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chofers
     * const chofer = await prisma.chofer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChoferUpdateManyArgs>(args: SelectSubset<T, ChoferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chofer.
     * @param {ChoferUpsertArgs} args - Arguments to update or create a Chofer.
     * @example
     * // Update or create a Chofer
     * const chofer = await prisma.chofer.upsert({
     *   create: {
     *     // ... data to create a Chofer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chofer we want to update
     *   }
     * })
     */
    upsert<T extends ChoferUpsertArgs>(args: SelectSubset<T, ChoferUpsertArgs<ExtArgs>>): Prisma__ChoferClient<$Result.GetResult<Prisma.$ChoferPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chofers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoferCountArgs} args - Arguments to filter Chofers to count.
     * @example
     * // Count the number of Chofers
     * const count = await prisma.chofer.count({
     *   where: {
     *     // ... the filter for the Chofers we want to count
     *   }
     * })
    **/
    count<T extends ChoferCountArgs>(
      args?: Subset<T, ChoferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chofer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoferAggregateArgs>(args: Subset<T, ChoferAggregateArgs>): Prisma.PrismaPromise<GetChoferAggregateType<T>>

    /**
     * Group by Chofer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoferGroupByArgs['orderBy'] }
        : { orderBy?: ChoferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chofer model
   */
  readonly fields: ChoferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chofer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChoferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    viajes<T extends Chofer$viajesArgs<ExtArgs> = {}>(args?: Subset<T, Chofer$viajesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "findMany"> | Null>
    pagos<T extends Chofer$pagosArgs<ExtArgs> = {}>(args?: Subset<T, Chofer$pagosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoChoferPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chofer model
   */ 
  interface ChoferFieldRefs {
    readonly id: FieldRef<"Chofer", 'Int'>
    readonly nombres: FieldRef<"Chofer", 'String'>
    readonly apellidos: FieldRef<"Chofer", 'String'>
    readonly documentoId: FieldRef<"Chofer", 'String'>
    readonly telefono: FieldRef<"Chofer", 'String'>
    readonly fechaVencimientoLicencia: FieldRef<"Chofer", 'DateTime'>
    readonly correo: FieldRef<"Chofer", 'String'>
    readonly estado: FieldRef<"Chofer", 'EstadoChofer'>
    readonly modalidadPago: FieldRef<"Chofer", 'ModalidadPago'>
    readonly metodoPago: FieldRef<"Chofer", 'MetodoPago'>
    readonly banco: FieldRef<"Chofer", 'String'>
    readonly numeroCuenta: FieldRef<"Chofer", 'String'>
    readonly sueldoMensual: FieldRef<"Chofer", 'Decimal'>
    readonly fechaContratacion: FieldRef<"Chofer", 'DateTime'>
    readonly diaPago: FieldRef<"Chofer", 'Int'>
    readonly pagoQuincenal: FieldRef<"Chofer", 'Boolean'>
    readonly creadoEn: FieldRef<"Chofer", 'DateTime'>
    readonly actualizadoEn: FieldRef<"Chofer", 'DateTime'>
    readonly deletedAt: FieldRef<"Chofer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chofer findUnique
   */
  export type ChoferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chofer
     */
    select?: ChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoferInclude<ExtArgs> | null
    /**
     * Filter, which Chofer to fetch.
     */
    where: ChoferWhereUniqueInput
  }

  /**
   * Chofer findUniqueOrThrow
   */
  export type ChoferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chofer
     */
    select?: ChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoferInclude<ExtArgs> | null
    /**
     * Filter, which Chofer to fetch.
     */
    where: ChoferWhereUniqueInput
  }

  /**
   * Chofer findFirst
   */
  export type ChoferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chofer
     */
    select?: ChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoferInclude<ExtArgs> | null
    /**
     * Filter, which Chofer to fetch.
     */
    where?: ChoferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chofers to fetch.
     */
    orderBy?: ChoferOrderByWithRelationInput | ChoferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chofers.
     */
    cursor?: ChoferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chofers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chofers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chofers.
     */
    distinct?: ChoferScalarFieldEnum | ChoferScalarFieldEnum[]
  }

  /**
   * Chofer findFirstOrThrow
   */
  export type ChoferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chofer
     */
    select?: ChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoferInclude<ExtArgs> | null
    /**
     * Filter, which Chofer to fetch.
     */
    where?: ChoferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chofers to fetch.
     */
    orderBy?: ChoferOrderByWithRelationInput | ChoferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chofers.
     */
    cursor?: ChoferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chofers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chofers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chofers.
     */
    distinct?: ChoferScalarFieldEnum | ChoferScalarFieldEnum[]
  }

  /**
   * Chofer findMany
   */
  export type ChoferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chofer
     */
    select?: ChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoferInclude<ExtArgs> | null
    /**
     * Filter, which Chofers to fetch.
     */
    where?: ChoferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chofers to fetch.
     */
    orderBy?: ChoferOrderByWithRelationInput | ChoferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chofers.
     */
    cursor?: ChoferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chofers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chofers.
     */
    skip?: number
    distinct?: ChoferScalarFieldEnum | ChoferScalarFieldEnum[]
  }

  /**
   * Chofer create
   */
  export type ChoferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chofer
     */
    select?: ChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoferInclude<ExtArgs> | null
    /**
     * The data needed to create a Chofer.
     */
    data: XOR<ChoferCreateInput, ChoferUncheckedCreateInput>
  }

  /**
   * Chofer createMany
   */
  export type ChoferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chofers.
     */
    data: ChoferCreateManyInput | ChoferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chofer createManyAndReturn
   */
  export type ChoferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chofer
     */
    select?: ChoferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Chofers.
     */
    data: ChoferCreateManyInput | ChoferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chofer update
   */
  export type ChoferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chofer
     */
    select?: ChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoferInclude<ExtArgs> | null
    /**
     * The data needed to update a Chofer.
     */
    data: XOR<ChoferUpdateInput, ChoferUncheckedUpdateInput>
    /**
     * Choose, which Chofer to update.
     */
    where: ChoferWhereUniqueInput
  }

  /**
   * Chofer updateMany
   */
  export type ChoferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chofers.
     */
    data: XOR<ChoferUpdateManyMutationInput, ChoferUncheckedUpdateManyInput>
    /**
     * Filter which Chofers to update
     */
    where?: ChoferWhereInput
  }

  /**
   * Chofer upsert
   */
  export type ChoferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chofer
     */
    select?: ChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoferInclude<ExtArgs> | null
    /**
     * The filter to search for the Chofer to update in case it exists.
     */
    where: ChoferWhereUniqueInput
    /**
     * In case the Chofer found by the `where` argument doesn't exist, create a new Chofer with this data.
     */
    create: XOR<ChoferCreateInput, ChoferUncheckedCreateInput>
    /**
     * In case the Chofer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoferUpdateInput, ChoferUncheckedUpdateInput>
  }

  /**
   * Chofer delete
   */
  export type ChoferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chofer
     */
    select?: ChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoferInclude<ExtArgs> | null
    /**
     * Filter which Chofer to delete.
     */
    where: ChoferWhereUniqueInput
  }

  /**
   * Chofer deleteMany
   */
  export type ChoferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chofers to delete
     */
    where?: ChoferWhereInput
  }

  /**
   * Chofer.viajes
   */
  export type Chofer$viajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeInclude<ExtArgs> | null
    where?: ViajeWhereInput
    orderBy?: ViajeOrderByWithRelationInput | ViajeOrderByWithRelationInput[]
    cursor?: ViajeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViajeScalarFieldEnum | ViajeScalarFieldEnum[]
  }

  /**
   * Chofer.pagos
   */
  export type Chofer$pagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoChofer
     */
    select?: PagoChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoChoferInclude<ExtArgs> | null
    where?: PagoChoferWhereInput
    orderBy?: PagoChoferOrderByWithRelationInput | PagoChoferOrderByWithRelationInput[]
    cursor?: PagoChoferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagoChoferScalarFieldEnum | PagoChoferScalarFieldEnum[]
  }

  /**
   * Chofer without action
   */
  export type ChoferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chofer
     */
    select?: ChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoferInclude<ExtArgs> | null
  }


  /**
   * Model Cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteAvgAggregateOutputType = {
    id: number | null
  }

  export type ClienteSumAggregateOutputType = {
    id: number | null
  }

  export type ClienteMinAggregateOutputType = {
    id: number | null
    nombreRazonSocial: string | null
    documentoId: string | null
    telefono: string | null
    correo: string | null
    direccion: string | null
    sector: string | null
    estado: $Enums.EstadoCliente | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    deletedAt: Date | null
  }

  export type ClienteMaxAggregateOutputType = {
    id: number | null
    nombreRazonSocial: string | null
    documentoId: string | null
    telefono: string | null
    correo: string | null
    direccion: string | null
    sector: string | null
    estado: $Enums.EstadoCliente | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    deletedAt: Date | null
  }

  export type ClienteCountAggregateOutputType = {
    id: number
    nombreRazonSocial: number
    documentoId: number
    telefono: number
    correo: number
    direccion: number
    sector: number
    estado: number
    creadoEn: number
    actualizadoEn: number
    deletedAt: number
    _all: number
  }


  export type ClienteAvgAggregateInputType = {
    id?: true
  }

  export type ClienteSumAggregateInputType = {
    id?: true
  }

  export type ClienteMinAggregateInputType = {
    id?: true
    nombreRazonSocial?: true
    documentoId?: true
    telefono?: true
    correo?: true
    direccion?: true
    sector?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    deletedAt?: true
  }

  export type ClienteMaxAggregateInputType = {
    id?: true
    nombreRazonSocial?: true
    documentoId?: true
    telefono?: true
    correo?: true
    direccion?: true
    sector?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    deletedAt?: true
  }

  export type ClienteCountAggregateInputType = {
    id?: true
    nombreRazonSocial?: true
    documentoId?: true
    telefono?: true
    correo?: true
    direccion?: true
    sector?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    deletedAt?: true
    _all?: true
  }

  export type ClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cliente to aggregate.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type ClienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteWhereInput
    orderBy?: ClienteOrderByWithAggregationInput | ClienteOrderByWithAggregationInput[]
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum
    having?: ClienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _avg?: ClienteAvgAggregateInputType
    _sum?: ClienteSumAggregateInputType
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }

  export type ClienteGroupByOutputType = {
    id: number
    nombreRazonSocial: string
    documentoId: string
    telefono: string | null
    correo: string | null
    direccion: string | null
    sector: string | null
    estado: $Enums.EstadoCliente
    creadoEn: Date
    actualizadoEn: Date
    deletedAt: Date | null
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends ClienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type ClienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombreRazonSocial?: boolean
    documentoId?: boolean
    telefono?: boolean
    correo?: boolean
    direccion?: boolean
    sector?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    deletedAt?: boolean
    viajes?: boolean | Cliente$viajesArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombreRazonSocial?: boolean
    documentoId?: boolean
    telefono?: boolean
    correo?: boolean
    direccion?: boolean
    sector?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectScalar = {
    id?: boolean
    nombreRazonSocial?: boolean
    documentoId?: boolean
    telefono?: boolean
    correo?: boolean
    direccion?: boolean
    sector?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    deletedAt?: boolean
  }

  export type ClienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viajes?: boolean | Cliente$viajesArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cliente"
    objects: {
      viajes: Prisma.$ViajePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombreRazonSocial: string
      documentoId: string
      telefono: string | null
      correo: string | null
      direccion: string | null
      sector: string | null
      estado: $Enums.EstadoCliente
      creadoEn: Date
      actualizadoEn: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["cliente"]>
    composites: {}
  }

  type ClienteGetPayload<S extends boolean | null | undefined | ClienteDefaultArgs> = $Result.GetResult<Prisma.$ClientePayload, S>

  type ClienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClienteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClienteCountAggregateInputType | true
    }

  export interface ClienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cliente'], meta: { name: 'Cliente' } }
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {ClienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClienteFindUniqueArgs>(args: SelectSubset<T, ClienteFindUniqueArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cliente that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClienteFindUniqueOrThrowArgs>(args: SelectSubset<T, ClienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClienteFindFirstArgs>(args?: SelectSubset<T, ClienteFindFirstArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClienteFindFirstOrThrowArgs>(args?: SelectSubset<T, ClienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteWithIdOnly = await prisma.cliente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClienteFindManyArgs>(args?: SelectSubset<T, ClienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cliente.
     * @param {ClienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
     */
    create<T extends ClienteCreateArgs>(args: SelectSubset<T, ClienteCreateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clientes.
     * @param {ClienteCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClienteCreateManyArgs>(args?: SelectSubset<T, ClienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clientes and returns the data saved in the database.
     * @param {ClienteCreateManyAndReturnArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clientes and only return the `id`
     * const clienteWithIdOnly = await prisma.cliente.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClienteCreateManyAndReturnArgs>(args?: SelectSubset<T, ClienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cliente.
     * @param {ClienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
     */
    delete<T extends ClienteDeleteArgs>(args: SelectSubset<T, ClienteDeleteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cliente.
     * @param {ClienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClienteUpdateArgs>(args: SelectSubset<T, ClienteUpdateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clientes.
     * @param {ClienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClienteDeleteManyArgs>(args?: SelectSubset<T, ClienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClienteUpdateManyArgs>(args: SelectSubset<T, ClienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cliente.
     * @param {ClienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
     */
    upsert<T extends ClienteUpsertArgs>(args: SelectSubset<T, ClienteUpsertArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClienteCountArgs>(
      args?: Subset<T, ClienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): Prisma.PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteGroupByArgs['orderBy'] }
        : { orderBy?: ClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cliente model
   */
  readonly fields: ClienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    viajes<T extends Cliente$viajesArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$viajesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cliente model
   */ 
  interface ClienteFieldRefs {
    readonly id: FieldRef<"Cliente", 'Int'>
    readonly nombreRazonSocial: FieldRef<"Cliente", 'String'>
    readonly documentoId: FieldRef<"Cliente", 'String'>
    readonly telefono: FieldRef<"Cliente", 'String'>
    readonly correo: FieldRef<"Cliente", 'String'>
    readonly direccion: FieldRef<"Cliente", 'String'>
    readonly sector: FieldRef<"Cliente", 'String'>
    readonly estado: FieldRef<"Cliente", 'EstadoCliente'>
    readonly creadoEn: FieldRef<"Cliente", 'DateTime'>
    readonly actualizadoEn: FieldRef<"Cliente", 'DateTime'>
    readonly deletedAt: FieldRef<"Cliente", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cliente findUnique
   */
  export type ClienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findUniqueOrThrow
   */
  export type ClienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findFirst
   */
  export type ClienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findFirstOrThrow
   */
  export type ClienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findMany
   */
  export type ClienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente create
   */
  export type ClienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to create a Cliente.
     */
    data: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
  }

  /**
   * Cliente createMany
   */
  export type ClienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cliente createManyAndReturn
   */
  export type ClienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cliente update
   */
  export type ClienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to update a Cliente.
     */
    data: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
    /**
     * Choose, which Cliente to update.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente updateMany
   */
  export type ClienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente upsert
   */
  export type ClienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The filter to search for the Cliente to update in case it exists.
     */
    where: ClienteWhereUniqueInput
    /**
     * In case the Cliente found by the `where` argument doesn't exist, create a new Cliente with this data.
     */
    create: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
    /**
     * In case the Cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
  }

  /**
   * Cliente delete
   */
  export type ClienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter which Cliente to delete.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente deleteMany
   */
  export type ClienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to delete
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente.viajes
   */
  export type Cliente$viajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeInclude<ExtArgs> | null
    where?: ViajeWhereInput
    orderBy?: ViajeOrderByWithRelationInput | ViajeOrderByWithRelationInput[]
    cursor?: ViajeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViajeScalarFieldEnum | ViajeScalarFieldEnum[]
  }

  /**
   * Cliente without action
   */
  export type ClienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    id: number | null
  }

  export type MaterialSumAggregateOutputType = {
    id: number | null
  }

  export type MaterialMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    unidadMedida: string | null
    esPeligroso: boolean | null
    descripcion: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    unidadMedida: string | null
    esPeligroso: boolean | null
    descripcion: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    nombre: number
    unidadMedida: number
    esPeligroso: number
    descripcion: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    id?: true
  }

  export type MaterialSumAggregateInputType = {
    id?: true
  }

  export type MaterialMinAggregateInputType = {
    id?: true
    nombre?: true
    unidadMedida?: true
    esPeligroso?: true
    descripcion?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    nombre?: true
    unidadMedida?: true
    esPeligroso?: true
    descripcion?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    nombre?: true
    unidadMedida?: true
    esPeligroso?: true
    descripcion?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: number
    nombre: string
    unidadMedida: string
    esPeligroso: boolean
    descripcion: string | null
    creadoEn: Date
    actualizadoEn: Date
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    unidadMedida?: boolean
    esPeligroso?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    viajes?: boolean | Material$viajesArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    unidadMedida?: boolean
    esPeligroso?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    nombre?: boolean
    unidadMedida?: boolean
    esPeligroso?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viajes?: boolean | Material$viajesArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      viajes: Prisma.$ViajePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      unidadMedida: string
      esPeligroso: boolean
      descripcion: string | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materials and returns the data saved in the database.
     * @param {MaterialCreateManyAndReturnArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    viajes<T extends Material$viajesArgs<ExtArgs> = {}>(args?: Subset<T, Material$viajesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */ 
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'Int'>
    readonly nombre: FieldRef<"Material", 'String'>
    readonly unidadMedida: FieldRef<"Material", 'String'>
    readonly esPeligroso: FieldRef<"Material", 'Boolean'>
    readonly descripcion: FieldRef<"Material", 'String'>
    readonly creadoEn: FieldRef<"Material", 'DateTime'>
    readonly actualizadoEn: FieldRef<"Material", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material createManyAndReturn
   */
  export type MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
  }

  /**
   * Material.viajes
   */
  export type Material$viajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeInclude<ExtArgs> | null
    where?: ViajeWhereInput
    orderBy?: ViajeOrderByWithRelationInput | ViajeOrderByWithRelationInput[]
    cursor?: ViajeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViajeScalarFieldEnum | ViajeScalarFieldEnum[]
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
  }


  /**
   * Model Viaje
   */

  export type AggregateViaje = {
    _count: ViajeCountAggregateOutputType | null
    _avg: ViajeAvgAggregateOutputType | null
    _sum: ViajeSumAggregateOutputType | null
    _min: ViajeMinAggregateOutputType | null
    _max: ViajeMaxAggregateOutputType | null
  }

  export type ViajeAvgAggregateOutputType = {
    id: number | null
    vehiculoId: number | null
    choferId: number | null
    clienteId: number | null
    materialId: number | null
    kilometrosEstimados: number | null
    kilometrosReales: number | null
    tarifa: Decimal | null
    montoPagadoCliente: Decimal | null
    diasCredito: number | null
    montoPagoChofer: Decimal | null
  }

  export type ViajeSumAggregateOutputType = {
    id: number | null
    vehiculoId: number | null
    choferId: number | null
    clienteId: number | null
    materialId: number | null
    kilometrosEstimados: number | null
    kilometrosReales: number | null
    tarifa: Decimal | null
    montoPagadoCliente: Decimal | null
    diasCredito: number | null
    montoPagoChofer: Decimal | null
  }

  export type ViajeMinAggregateOutputType = {
    id: number | null
    vehiculoId: number | null
    choferId: number | null
    clienteId: number | null
    materialId: number | null
    origen: string | null
    destino: string | null
    fechaSalida: Date | null
    fechaLlegadaEstimada: Date | null
    fechaLlegadaReal: Date | null
    kilometrosEstimados: number | null
    kilometrosReales: number | null
    tarifa: Decimal | null
    estadoPagoCliente: $Enums.EstadoPagoCliente | null
    montoPagadoCliente: Decimal | null
    fechaLimitePago: Date | null
    diasCredito: number | null
    montoPagoChofer: Decimal | null
    estado: $Enums.EstadoViaje | null
    observaciones: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type ViajeMaxAggregateOutputType = {
    id: number | null
    vehiculoId: number | null
    choferId: number | null
    clienteId: number | null
    materialId: number | null
    origen: string | null
    destino: string | null
    fechaSalida: Date | null
    fechaLlegadaEstimada: Date | null
    fechaLlegadaReal: Date | null
    kilometrosEstimados: number | null
    kilometrosReales: number | null
    tarifa: Decimal | null
    estadoPagoCliente: $Enums.EstadoPagoCliente | null
    montoPagadoCliente: Decimal | null
    fechaLimitePago: Date | null
    diasCredito: number | null
    montoPagoChofer: Decimal | null
    estado: $Enums.EstadoViaje | null
    observaciones: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type ViajeCountAggregateOutputType = {
    id: number
    vehiculoId: number
    choferId: number
    clienteId: number
    materialId: number
    origen: number
    destino: number
    fechaSalida: number
    fechaLlegadaEstimada: number
    fechaLlegadaReal: number
    kilometrosEstimados: number
    kilometrosReales: number
    tarifa: number
    estadoPagoCliente: number
    montoPagadoCliente: number
    fechaLimitePago: number
    diasCredito: number
    montoPagoChofer: number
    estado: number
    observaciones: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type ViajeAvgAggregateInputType = {
    id?: true
    vehiculoId?: true
    choferId?: true
    clienteId?: true
    materialId?: true
    kilometrosEstimados?: true
    kilometrosReales?: true
    tarifa?: true
    montoPagadoCliente?: true
    diasCredito?: true
    montoPagoChofer?: true
  }

  export type ViajeSumAggregateInputType = {
    id?: true
    vehiculoId?: true
    choferId?: true
    clienteId?: true
    materialId?: true
    kilometrosEstimados?: true
    kilometrosReales?: true
    tarifa?: true
    montoPagadoCliente?: true
    diasCredito?: true
    montoPagoChofer?: true
  }

  export type ViajeMinAggregateInputType = {
    id?: true
    vehiculoId?: true
    choferId?: true
    clienteId?: true
    materialId?: true
    origen?: true
    destino?: true
    fechaSalida?: true
    fechaLlegadaEstimada?: true
    fechaLlegadaReal?: true
    kilometrosEstimados?: true
    kilometrosReales?: true
    tarifa?: true
    estadoPagoCliente?: true
    montoPagadoCliente?: true
    fechaLimitePago?: true
    diasCredito?: true
    montoPagoChofer?: true
    estado?: true
    observaciones?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type ViajeMaxAggregateInputType = {
    id?: true
    vehiculoId?: true
    choferId?: true
    clienteId?: true
    materialId?: true
    origen?: true
    destino?: true
    fechaSalida?: true
    fechaLlegadaEstimada?: true
    fechaLlegadaReal?: true
    kilometrosEstimados?: true
    kilometrosReales?: true
    tarifa?: true
    estadoPagoCliente?: true
    montoPagadoCliente?: true
    fechaLimitePago?: true
    diasCredito?: true
    montoPagoChofer?: true
    estado?: true
    observaciones?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type ViajeCountAggregateInputType = {
    id?: true
    vehiculoId?: true
    choferId?: true
    clienteId?: true
    materialId?: true
    origen?: true
    destino?: true
    fechaSalida?: true
    fechaLlegadaEstimada?: true
    fechaLlegadaReal?: true
    kilometrosEstimados?: true
    kilometrosReales?: true
    tarifa?: true
    estadoPagoCliente?: true
    montoPagadoCliente?: true
    fechaLimitePago?: true
    diasCredito?: true
    montoPagoChofer?: true
    estado?: true
    observaciones?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type ViajeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Viaje to aggregate.
     */
    where?: ViajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viajes to fetch.
     */
    orderBy?: ViajeOrderByWithRelationInput | ViajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Viajes
    **/
    _count?: true | ViajeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViajeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViajeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViajeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViajeMaxAggregateInputType
  }

  export type GetViajeAggregateType<T extends ViajeAggregateArgs> = {
        [P in keyof T & keyof AggregateViaje]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViaje[P]>
      : GetScalarType<T[P], AggregateViaje[P]>
  }




  export type ViajeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViajeWhereInput
    orderBy?: ViajeOrderByWithAggregationInput | ViajeOrderByWithAggregationInput[]
    by: ViajeScalarFieldEnum[] | ViajeScalarFieldEnum
    having?: ViajeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViajeCountAggregateInputType | true
    _avg?: ViajeAvgAggregateInputType
    _sum?: ViajeSumAggregateInputType
    _min?: ViajeMinAggregateInputType
    _max?: ViajeMaxAggregateInputType
  }

  export type ViajeGroupByOutputType = {
    id: number
    vehiculoId: number
    choferId: number
    clienteId: number
    materialId: number
    origen: string
    destino: string
    fechaSalida: Date
    fechaLlegadaEstimada: Date | null
    fechaLlegadaReal: Date | null
    kilometrosEstimados: number | null
    kilometrosReales: number | null
    tarifa: Decimal
    estadoPagoCliente: $Enums.EstadoPagoCliente
    montoPagadoCliente: Decimal
    fechaLimitePago: Date | null
    diasCredito: number
    montoPagoChofer: Decimal | null
    estado: $Enums.EstadoViaje
    observaciones: string | null
    creadoEn: Date
    actualizadoEn: Date
    _count: ViajeCountAggregateOutputType | null
    _avg: ViajeAvgAggregateOutputType | null
    _sum: ViajeSumAggregateOutputType | null
    _min: ViajeMinAggregateOutputType | null
    _max: ViajeMaxAggregateOutputType | null
  }

  type GetViajeGroupByPayload<T extends ViajeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViajeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViajeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViajeGroupByOutputType[P]>
            : GetScalarType<T[P], ViajeGroupByOutputType[P]>
        }
      >
    >


  export type ViajeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehiculoId?: boolean
    choferId?: boolean
    clienteId?: boolean
    materialId?: boolean
    origen?: boolean
    destino?: boolean
    fechaSalida?: boolean
    fechaLlegadaEstimada?: boolean
    fechaLlegadaReal?: boolean
    kilometrosEstimados?: boolean
    kilometrosReales?: boolean
    tarifa?: boolean
    estadoPagoCliente?: boolean
    montoPagadoCliente?: boolean
    fechaLimitePago?: boolean
    diasCredito?: boolean
    montoPagoChofer?: boolean
    estado?: boolean
    observaciones?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    vehiculo?: boolean | VehiculoDefaultArgs<ExtArgs>
    chofer?: boolean | ChoferDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    gastos?: boolean | Viaje$gastosArgs<ExtArgs>
    pagos?: boolean | Viaje$pagosArgs<ExtArgs>
    _count?: boolean | ViajeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viaje"]>

  export type ViajeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehiculoId?: boolean
    choferId?: boolean
    clienteId?: boolean
    materialId?: boolean
    origen?: boolean
    destino?: boolean
    fechaSalida?: boolean
    fechaLlegadaEstimada?: boolean
    fechaLlegadaReal?: boolean
    kilometrosEstimados?: boolean
    kilometrosReales?: boolean
    tarifa?: boolean
    estadoPagoCliente?: boolean
    montoPagadoCliente?: boolean
    fechaLimitePago?: boolean
    diasCredito?: boolean
    montoPagoChofer?: boolean
    estado?: boolean
    observaciones?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    vehiculo?: boolean | VehiculoDefaultArgs<ExtArgs>
    chofer?: boolean | ChoferDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viaje"]>

  export type ViajeSelectScalar = {
    id?: boolean
    vehiculoId?: boolean
    choferId?: boolean
    clienteId?: boolean
    materialId?: boolean
    origen?: boolean
    destino?: boolean
    fechaSalida?: boolean
    fechaLlegadaEstimada?: boolean
    fechaLlegadaReal?: boolean
    kilometrosEstimados?: boolean
    kilometrosReales?: boolean
    tarifa?: boolean
    estadoPagoCliente?: boolean
    montoPagadoCliente?: boolean
    fechaLimitePago?: boolean
    diasCredito?: boolean
    montoPagoChofer?: boolean
    estado?: boolean
    observaciones?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type ViajeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehiculo?: boolean | VehiculoDefaultArgs<ExtArgs>
    chofer?: boolean | ChoferDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    gastos?: boolean | Viaje$gastosArgs<ExtArgs>
    pagos?: boolean | Viaje$pagosArgs<ExtArgs>
    _count?: boolean | ViajeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ViajeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehiculo?: boolean | VehiculoDefaultArgs<ExtArgs>
    chofer?: boolean | ChoferDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
  }

  export type $ViajePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Viaje"
    objects: {
      vehiculo: Prisma.$VehiculoPayload<ExtArgs>
      chofer: Prisma.$ChoferPayload<ExtArgs>
      cliente: Prisma.$ClientePayload<ExtArgs>
      material: Prisma.$MaterialPayload<ExtArgs>
      gastos: Prisma.$GastoViajePayload<ExtArgs>[]
      pagos: Prisma.$PagoChoferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vehiculoId: number
      choferId: number
      clienteId: number
      materialId: number
      origen: string
      destino: string
      fechaSalida: Date
      fechaLlegadaEstimada: Date | null
      fechaLlegadaReal: Date | null
      kilometrosEstimados: number | null
      kilometrosReales: number | null
      tarifa: Prisma.Decimal
      estadoPagoCliente: $Enums.EstadoPagoCliente
      montoPagadoCliente: Prisma.Decimal
      fechaLimitePago: Date | null
      diasCredito: number
      montoPagoChofer: Prisma.Decimal | null
      estado: $Enums.EstadoViaje
      observaciones: string | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["viaje"]>
    composites: {}
  }

  type ViajeGetPayload<S extends boolean | null | undefined | ViajeDefaultArgs> = $Result.GetResult<Prisma.$ViajePayload, S>

  type ViajeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ViajeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ViajeCountAggregateInputType | true
    }

  export interface ViajeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Viaje'], meta: { name: 'Viaje' } }
    /**
     * Find zero or one Viaje that matches the filter.
     * @param {ViajeFindUniqueArgs} args - Arguments to find a Viaje
     * @example
     * // Get one Viaje
     * const viaje = await prisma.viaje.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViajeFindUniqueArgs>(args: SelectSubset<T, ViajeFindUniqueArgs<ExtArgs>>): Prisma__ViajeClient<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Viaje that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ViajeFindUniqueOrThrowArgs} args - Arguments to find a Viaje
     * @example
     * // Get one Viaje
     * const viaje = await prisma.viaje.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViajeFindUniqueOrThrowArgs>(args: SelectSubset<T, ViajeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViajeClient<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Viaje that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViajeFindFirstArgs} args - Arguments to find a Viaje
     * @example
     * // Get one Viaje
     * const viaje = await prisma.viaje.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViajeFindFirstArgs>(args?: SelectSubset<T, ViajeFindFirstArgs<ExtArgs>>): Prisma__ViajeClient<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Viaje that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViajeFindFirstOrThrowArgs} args - Arguments to find a Viaje
     * @example
     * // Get one Viaje
     * const viaje = await prisma.viaje.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViajeFindFirstOrThrowArgs>(args?: SelectSubset<T, ViajeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViajeClient<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Viajes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViajeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Viajes
     * const viajes = await prisma.viaje.findMany()
     * 
     * // Get first 10 Viajes
     * const viajes = await prisma.viaje.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viajeWithIdOnly = await prisma.viaje.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViajeFindManyArgs>(args?: SelectSubset<T, ViajeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Viaje.
     * @param {ViajeCreateArgs} args - Arguments to create a Viaje.
     * @example
     * // Create one Viaje
     * const Viaje = await prisma.viaje.create({
     *   data: {
     *     // ... data to create a Viaje
     *   }
     * })
     * 
     */
    create<T extends ViajeCreateArgs>(args: SelectSubset<T, ViajeCreateArgs<ExtArgs>>): Prisma__ViajeClient<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Viajes.
     * @param {ViajeCreateManyArgs} args - Arguments to create many Viajes.
     * @example
     * // Create many Viajes
     * const viaje = await prisma.viaje.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViajeCreateManyArgs>(args?: SelectSubset<T, ViajeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Viajes and returns the data saved in the database.
     * @param {ViajeCreateManyAndReturnArgs} args - Arguments to create many Viajes.
     * @example
     * // Create many Viajes
     * const viaje = await prisma.viaje.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Viajes and only return the `id`
     * const viajeWithIdOnly = await prisma.viaje.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViajeCreateManyAndReturnArgs>(args?: SelectSubset<T, ViajeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Viaje.
     * @param {ViajeDeleteArgs} args - Arguments to delete one Viaje.
     * @example
     * // Delete one Viaje
     * const Viaje = await prisma.viaje.delete({
     *   where: {
     *     // ... filter to delete one Viaje
     *   }
     * })
     * 
     */
    delete<T extends ViajeDeleteArgs>(args: SelectSubset<T, ViajeDeleteArgs<ExtArgs>>): Prisma__ViajeClient<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Viaje.
     * @param {ViajeUpdateArgs} args - Arguments to update one Viaje.
     * @example
     * // Update one Viaje
     * const viaje = await prisma.viaje.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViajeUpdateArgs>(args: SelectSubset<T, ViajeUpdateArgs<ExtArgs>>): Prisma__ViajeClient<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Viajes.
     * @param {ViajeDeleteManyArgs} args - Arguments to filter Viajes to delete.
     * @example
     * // Delete a few Viajes
     * const { count } = await prisma.viaje.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViajeDeleteManyArgs>(args?: SelectSubset<T, ViajeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViajeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Viajes
     * const viaje = await prisma.viaje.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViajeUpdateManyArgs>(args: SelectSubset<T, ViajeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Viaje.
     * @param {ViajeUpsertArgs} args - Arguments to update or create a Viaje.
     * @example
     * // Update or create a Viaje
     * const viaje = await prisma.viaje.upsert({
     *   create: {
     *     // ... data to create a Viaje
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Viaje we want to update
     *   }
     * })
     */
    upsert<T extends ViajeUpsertArgs>(args: SelectSubset<T, ViajeUpsertArgs<ExtArgs>>): Prisma__ViajeClient<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Viajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViajeCountArgs} args - Arguments to filter Viajes to count.
     * @example
     * // Count the number of Viajes
     * const count = await prisma.viaje.count({
     *   where: {
     *     // ... the filter for the Viajes we want to count
     *   }
     * })
    **/
    count<T extends ViajeCountArgs>(
      args?: Subset<T, ViajeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViajeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Viaje.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViajeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViajeAggregateArgs>(args: Subset<T, ViajeAggregateArgs>): Prisma.PrismaPromise<GetViajeAggregateType<T>>

    /**
     * Group by Viaje.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViajeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViajeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViajeGroupByArgs['orderBy'] }
        : { orderBy?: ViajeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViajeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViajeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Viaje model
   */
  readonly fields: ViajeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Viaje.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViajeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehiculo<T extends VehiculoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehiculoDefaultArgs<ExtArgs>>): Prisma__VehiculoClient<$Result.GetResult<Prisma.$VehiculoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    chofer<T extends ChoferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChoferDefaultArgs<ExtArgs>>): Prisma__ChoferClient<$Result.GetResult<Prisma.$ChoferPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    gastos<T extends Viaje$gastosArgs<ExtArgs> = {}>(args?: Subset<T, Viaje$gastosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GastoViajePayload<ExtArgs>, T, "findMany"> | Null>
    pagos<T extends Viaje$pagosArgs<ExtArgs> = {}>(args?: Subset<T, Viaje$pagosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoChoferPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Viaje model
   */ 
  interface ViajeFieldRefs {
    readonly id: FieldRef<"Viaje", 'Int'>
    readonly vehiculoId: FieldRef<"Viaje", 'Int'>
    readonly choferId: FieldRef<"Viaje", 'Int'>
    readonly clienteId: FieldRef<"Viaje", 'Int'>
    readonly materialId: FieldRef<"Viaje", 'Int'>
    readonly origen: FieldRef<"Viaje", 'String'>
    readonly destino: FieldRef<"Viaje", 'String'>
    readonly fechaSalida: FieldRef<"Viaje", 'DateTime'>
    readonly fechaLlegadaEstimada: FieldRef<"Viaje", 'DateTime'>
    readonly fechaLlegadaReal: FieldRef<"Viaje", 'DateTime'>
    readonly kilometrosEstimados: FieldRef<"Viaje", 'Int'>
    readonly kilometrosReales: FieldRef<"Viaje", 'Int'>
    readonly tarifa: FieldRef<"Viaje", 'Decimal'>
    readonly estadoPagoCliente: FieldRef<"Viaje", 'EstadoPagoCliente'>
    readonly montoPagadoCliente: FieldRef<"Viaje", 'Decimal'>
    readonly fechaLimitePago: FieldRef<"Viaje", 'DateTime'>
    readonly diasCredito: FieldRef<"Viaje", 'Int'>
    readonly montoPagoChofer: FieldRef<"Viaje", 'Decimal'>
    readonly estado: FieldRef<"Viaje", 'EstadoViaje'>
    readonly observaciones: FieldRef<"Viaje", 'String'>
    readonly creadoEn: FieldRef<"Viaje", 'DateTime'>
    readonly actualizadoEn: FieldRef<"Viaje", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Viaje findUnique
   */
  export type ViajeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeInclude<ExtArgs> | null
    /**
     * Filter, which Viaje to fetch.
     */
    where: ViajeWhereUniqueInput
  }

  /**
   * Viaje findUniqueOrThrow
   */
  export type ViajeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeInclude<ExtArgs> | null
    /**
     * Filter, which Viaje to fetch.
     */
    where: ViajeWhereUniqueInput
  }

  /**
   * Viaje findFirst
   */
  export type ViajeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeInclude<ExtArgs> | null
    /**
     * Filter, which Viaje to fetch.
     */
    where?: ViajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viajes to fetch.
     */
    orderBy?: ViajeOrderByWithRelationInput | ViajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Viajes.
     */
    cursor?: ViajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Viajes.
     */
    distinct?: ViajeScalarFieldEnum | ViajeScalarFieldEnum[]
  }

  /**
   * Viaje findFirstOrThrow
   */
  export type ViajeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeInclude<ExtArgs> | null
    /**
     * Filter, which Viaje to fetch.
     */
    where?: ViajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viajes to fetch.
     */
    orderBy?: ViajeOrderByWithRelationInput | ViajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Viajes.
     */
    cursor?: ViajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Viajes.
     */
    distinct?: ViajeScalarFieldEnum | ViajeScalarFieldEnum[]
  }

  /**
   * Viaje findMany
   */
  export type ViajeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeInclude<ExtArgs> | null
    /**
     * Filter, which Viajes to fetch.
     */
    where?: ViajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viajes to fetch.
     */
    orderBy?: ViajeOrderByWithRelationInput | ViajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Viajes.
     */
    cursor?: ViajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viajes.
     */
    skip?: number
    distinct?: ViajeScalarFieldEnum | ViajeScalarFieldEnum[]
  }

  /**
   * Viaje create
   */
  export type ViajeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeInclude<ExtArgs> | null
    /**
     * The data needed to create a Viaje.
     */
    data: XOR<ViajeCreateInput, ViajeUncheckedCreateInput>
  }

  /**
   * Viaje createMany
   */
  export type ViajeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Viajes.
     */
    data: ViajeCreateManyInput | ViajeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Viaje createManyAndReturn
   */
  export type ViajeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Viajes.
     */
    data: ViajeCreateManyInput | ViajeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Viaje update
   */
  export type ViajeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeInclude<ExtArgs> | null
    /**
     * The data needed to update a Viaje.
     */
    data: XOR<ViajeUpdateInput, ViajeUncheckedUpdateInput>
    /**
     * Choose, which Viaje to update.
     */
    where: ViajeWhereUniqueInput
  }

  /**
   * Viaje updateMany
   */
  export type ViajeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Viajes.
     */
    data: XOR<ViajeUpdateManyMutationInput, ViajeUncheckedUpdateManyInput>
    /**
     * Filter which Viajes to update
     */
    where?: ViajeWhereInput
  }

  /**
   * Viaje upsert
   */
  export type ViajeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeInclude<ExtArgs> | null
    /**
     * The filter to search for the Viaje to update in case it exists.
     */
    where: ViajeWhereUniqueInput
    /**
     * In case the Viaje found by the `where` argument doesn't exist, create a new Viaje with this data.
     */
    create: XOR<ViajeCreateInput, ViajeUncheckedCreateInput>
    /**
     * In case the Viaje was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViajeUpdateInput, ViajeUncheckedUpdateInput>
  }

  /**
   * Viaje delete
   */
  export type ViajeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeInclude<ExtArgs> | null
    /**
     * Filter which Viaje to delete.
     */
    where: ViajeWhereUniqueInput
  }

  /**
   * Viaje deleteMany
   */
  export type ViajeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Viajes to delete
     */
    where?: ViajeWhereInput
  }

  /**
   * Viaje.gastos
   */
  export type Viaje$gastosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GastoViaje
     */
    select?: GastoViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GastoViajeInclude<ExtArgs> | null
    where?: GastoViajeWhereInput
    orderBy?: GastoViajeOrderByWithRelationInput | GastoViajeOrderByWithRelationInput[]
    cursor?: GastoViajeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GastoViajeScalarFieldEnum | GastoViajeScalarFieldEnum[]
  }

  /**
   * Viaje.pagos
   */
  export type Viaje$pagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoChofer
     */
    select?: PagoChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoChoferInclude<ExtArgs> | null
    where?: PagoChoferWhereInput
    orderBy?: PagoChoferOrderByWithRelationInput | PagoChoferOrderByWithRelationInput[]
    cursor?: PagoChoferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagoChoferScalarFieldEnum | PagoChoferScalarFieldEnum[]
  }

  /**
   * Viaje without action
   */
  export type ViajeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeInclude<ExtArgs> | null
  }


  /**
   * Model GastoViaje
   */

  export type AggregateGastoViaje = {
    _count: GastoViajeCountAggregateOutputType | null
    _avg: GastoViajeAvgAggregateOutputType | null
    _sum: GastoViajeSumAggregateOutputType | null
    _min: GastoViajeMinAggregateOutputType | null
    _max: GastoViajeMaxAggregateOutputType | null
  }

  export type GastoViajeAvgAggregateOutputType = {
    id: number | null
    viajeId: number | null
    monto: Decimal | null
    comprobanteId: number | null
  }

  export type GastoViajeSumAggregateOutputType = {
    id: number | null
    viajeId: number | null
    monto: Decimal | null
    comprobanteId: number | null
  }

  export type GastoViajeMinAggregateOutputType = {
    id: number | null
    viajeId: number | null
    tipoGasto: $Enums.TipoGasto | null
    monto: Decimal | null
    fecha: Date | null
    metodoPago: $Enums.MetodoPago | null
    descripcion: string | null
    comprobanteId: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type GastoViajeMaxAggregateOutputType = {
    id: number | null
    viajeId: number | null
    tipoGasto: $Enums.TipoGasto | null
    monto: Decimal | null
    fecha: Date | null
    metodoPago: $Enums.MetodoPago | null
    descripcion: string | null
    comprobanteId: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type GastoViajeCountAggregateOutputType = {
    id: number
    viajeId: number
    tipoGasto: number
    monto: number
    fecha: number
    metodoPago: number
    descripcion: number
    comprobanteId: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type GastoViajeAvgAggregateInputType = {
    id?: true
    viajeId?: true
    monto?: true
    comprobanteId?: true
  }

  export type GastoViajeSumAggregateInputType = {
    id?: true
    viajeId?: true
    monto?: true
    comprobanteId?: true
  }

  export type GastoViajeMinAggregateInputType = {
    id?: true
    viajeId?: true
    tipoGasto?: true
    monto?: true
    fecha?: true
    metodoPago?: true
    descripcion?: true
    comprobanteId?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type GastoViajeMaxAggregateInputType = {
    id?: true
    viajeId?: true
    tipoGasto?: true
    monto?: true
    fecha?: true
    metodoPago?: true
    descripcion?: true
    comprobanteId?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type GastoViajeCountAggregateInputType = {
    id?: true
    viajeId?: true
    tipoGasto?: true
    monto?: true
    fecha?: true
    metodoPago?: true
    descripcion?: true
    comprobanteId?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type GastoViajeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GastoViaje to aggregate.
     */
    where?: GastoViajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GastoViajes to fetch.
     */
    orderBy?: GastoViajeOrderByWithRelationInput | GastoViajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GastoViajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GastoViajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GastoViajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GastoViajes
    **/
    _count?: true | GastoViajeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GastoViajeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GastoViajeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GastoViajeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GastoViajeMaxAggregateInputType
  }

  export type GetGastoViajeAggregateType<T extends GastoViajeAggregateArgs> = {
        [P in keyof T & keyof AggregateGastoViaje]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGastoViaje[P]>
      : GetScalarType<T[P], AggregateGastoViaje[P]>
  }




  export type GastoViajeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GastoViajeWhereInput
    orderBy?: GastoViajeOrderByWithAggregationInput | GastoViajeOrderByWithAggregationInput[]
    by: GastoViajeScalarFieldEnum[] | GastoViajeScalarFieldEnum
    having?: GastoViajeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GastoViajeCountAggregateInputType | true
    _avg?: GastoViajeAvgAggregateInputType
    _sum?: GastoViajeSumAggregateInputType
    _min?: GastoViajeMinAggregateInputType
    _max?: GastoViajeMaxAggregateInputType
  }

  export type GastoViajeGroupByOutputType = {
    id: number
    viajeId: number
    tipoGasto: $Enums.TipoGasto
    monto: Decimal
    fecha: Date
    metodoPago: $Enums.MetodoPago
    descripcion: string | null
    comprobanteId: number | null
    creadoEn: Date
    actualizadoEn: Date
    _count: GastoViajeCountAggregateOutputType | null
    _avg: GastoViajeAvgAggregateOutputType | null
    _sum: GastoViajeSumAggregateOutputType | null
    _min: GastoViajeMinAggregateOutputType | null
    _max: GastoViajeMaxAggregateOutputType | null
  }

  type GetGastoViajeGroupByPayload<T extends GastoViajeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GastoViajeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GastoViajeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GastoViajeGroupByOutputType[P]>
            : GetScalarType<T[P], GastoViajeGroupByOutputType[P]>
        }
      >
    >


  export type GastoViajeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    viajeId?: boolean
    tipoGasto?: boolean
    monto?: boolean
    fecha?: boolean
    metodoPago?: boolean
    descripcion?: boolean
    comprobanteId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    viaje?: boolean | ViajeDefaultArgs<ExtArgs>
    comprobante?: boolean | GastoViaje$comprobanteArgs<ExtArgs>
  }, ExtArgs["result"]["gastoViaje"]>

  export type GastoViajeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    viajeId?: boolean
    tipoGasto?: boolean
    monto?: boolean
    fecha?: boolean
    metodoPago?: boolean
    descripcion?: boolean
    comprobanteId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    viaje?: boolean | ViajeDefaultArgs<ExtArgs>
    comprobante?: boolean | GastoViaje$comprobanteArgs<ExtArgs>
  }, ExtArgs["result"]["gastoViaje"]>

  export type GastoViajeSelectScalar = {
    id?: boolean
    viajeId?: boolean
    tipoGasto?: boolean
    monto?: boolean
    fecha?: boolean
    metodoPago?: boolean
    descripcion?: boolean
    comprobanteId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type GastoViajeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viaje?: boolean | ViajeDefaultArgs<ExtArgs>
    comprobante?: boolean | GastoViaje$comprobanteArgs<ExtArgs>
  }
  export type GastoViajeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viaje?: boolean | ViajeDefaultArgs<ExtArgs>
    comprobante?: boolean | GastoViaje$comprobanteArgs<ExtArgs>
  }

  export type $GastoViajePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GastoViaje"
    objects: {
      viaje: Prisma.$ViajePayload<ExtArgs>
      comprobante: Prisma.$ComprobantePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      viajeId: number
      tipoGasto: $Enums.TipoGasto
      monto: Prisma.Decimal
      fecha: Date
      metodoPago: $Enums.MetodoPago
      descripcion: string | null
      comprobanteId: number | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["gastoViaje"]>
    composites: {}
  }

  type GastoViajeGetPayload<S extends boolean | null | undefined | GastoViajeDefaultArgs> = $Result.GetResult<Prisma.$GastoViajePayload, S>

  type GastoViajeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GastoViajeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GastoViajeCountAggregateInputType | true
    }

  export interface GastoViajeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GastoViaje'], meta: { name: 'GastoViaje' } }
    /**
     * Find zero or one GastoViaje that matches the filter.
     * @param {GastoViajeFindUniqueArgs} args - Arguments to find a GastoViaje
     * @example
     * // Get one GastoViaje
     * const gastoViaje = await prisma.gastoViaje.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GastoViajeFindUniqueArgs>(args: SelectSubset<T, GastoViajeFindUniqueArgs<ExtArgs>>): Prisma__GastoViajeClient<$Result.GetResult<Prisma.$GastoViajePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GastoViaje that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GastoViajeFindUniqueOrThrowArgs} args - Arguments to find a GastoViaje
     * @example
     * // Get one GastoViaje
     * const gastoViaje = await prisma.gastoViaje.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GastoViajeFindUniqueOrThrowArgs>(args: SelectSubset<T, GastoViajeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GastoViajeClient<$Result.GetResult<Prisma.$GastoViajePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GastoViaje that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GastoViajeFindFirstArgs} args - Arguments to find a GastoViaje
     * @example
     * // Get one GastoViaje
     * const gastoViaje = await prisma.gastoViaje.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GastoViajeFindFirstArgs>(args?: SelectSubset<T, GastoViajeFindFirstArgs<ExtArgs>>): Prisma__GastoViajeClient<$Result.GetResult<Prisma.$GastoViajePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GastoViaje that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GastoViajeFindFirstOrThrowArgs} args - Arguments to find a GastoViaje
     * @example
     * // Get one GastoViaje
     * const gastoViaje = await prisma.gastoViaje.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GastoViajeFindFirstOrThrowArgs>(args?: SelectSubset<T, GastoViajeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GastoViajeClient<$Result.GetResult<Prisma.$GastoViajePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GastoViajes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GastoViajeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GastoViajes
     * const gastoViajes = await prisma.gastoViaje.findMany()
     * 
     * // Get first 10 GastoViajes
     * const gastoViajes = await prisma.gastoViaje.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gastoViajeWithIdOnly = await prisma.gastoViaje.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GastoViajeFindManyArgs>(args?: SelectSubset<T, GastoViajeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GastoViajePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GastoViaje.
     * @param {GastoViajeCreateArgs} args - Arguments to create a GastoViaje.
     * @example
     * // Create one GastoViaje
     * const GastoViaje = await prisma.gastoViaje.create({
     *   data: {
     *     // ... data to create a GastoViaje
     *   }
     * })
     * 
     */
    create<T extends GastoViajeCreateArgs>(args: SelectSubset<T, GastoViajeCreateArgs<ExtArgs>>): Prisma__GastoViajeClient<$Result.GetResult<Prisma.$GastoViajePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GastoViajes.
     * @param {GastoViajeCreateManyArgs} args - Arguments to create many GastoViajes.
     * @example
     * // Create many GastoViajes
     * const gastoViaje = await prisma.gastoViaje.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GastoViajeCreateManyArgs>(args?: SelectSubset<T, GastoViajeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GastoViajes and returns the data saved in the database.
     * @param {GastoViajeCreateManyAndReturnArgs} args - Arguments to create many GastoViajes.
     * @example
     * // Create many GastoViajes
     * const gastoViaje = await prisma.gastoViaje.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GastoViajes and only return the `id`
     * const gastoViajeWithIdOnly = await prisma.gastoViaje.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GastoViajeCreateManyAndReturnArgs>(args?: SelectSubset<T, GastoViajeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GastoViajePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GastoViaje.
     * @param {GastoViajeDeleteArgs} args - Arguments to delete one GastoViaje.
     * @example
     * // Delete one GastoViaje
     * const GastoViaje = await prisma.gastoViaje.delete({
     *   where: {
     *     // ... filter to delete one GastoViaje
     *   }
     * })
     * 
     */
    delete<T extends GastoViajeDeleteArgs>(args: SelectSubset<T, GastoViajeDeleteArgs<ExtArgs>>): Prisma__GastoViajeClient<$Result.GetResult<Prisma.$GastoViajePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GastoViaje.
     * @param {GastoViajeUpdateArgs} args - Arguments to update one GastoViaje.
     * @example
     * // Update one GastoViaje
     * const gastoViaje = await prisma.gastoViaje.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GastoViajeUpdateArgs>(args: SelectSubset<T, GastoViajeUpdateArgs<ExtArgs>>): Prisma__GastoViajeClient<$Result.GetResult<Prisma.$GastoViajePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GastoViajes.
     * @param {GastoViajeDeleteManyArgs} args - Arguments to filter GastoViajes to delete.
     * @example
     * // Delete a few GastoViajes
     * const { count } = await prisma.gastoViaje.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GastoViajeDeleteManyArgs>(args?: SelectSubset<T, GastoViajeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GastoViajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GastoViajeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GastoViajes
     * const gastoViaje = await prisma.gastoViaje.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GastoViajeUpdateManyArgs>(args: SelectSubset<T, GastoViajeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GastoViaje.
     * @param {GastoViajeUpsertArgs} args - Arguments to update or create a GastoViaje.
     * @example
     * // Update or create a GastoViaje
     * const gastoViaje = await prisma.gastoViaje.upsert({
     *   create: {
     *     // ... data to create a GastoViaje
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GastoViaje we want to update
     *   }
     * })
     */
    upsert<T extends GastoViajeUpsertArgs>(args: SelectSubset<T, GastoViajeUpsertArgs<ExtArgs>>): Prisma__GastoViajeClient<$Result.GetResult<Prisma.$GastoViajePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GastoViajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GastoViajeCountArgs} args - Arguments to filter GastoViajes to count.
     * @example
     * // Count the number of GastoViajes
     * const count = await prisma.gastoViaje.count({
     *   where: {
     *     // ... the filter for the GastoViajes we want to count
     *   }
     * })
    **/
    count<T extends GastoViajeCountArgs>(
      args?: Subset<T, GastoViajeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GastoViajeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GastoViaje.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GastoViajeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GastoViajeAggregateArgs>(args: Subset<T, GastoViajeAggregateArgs>): Prisma.PrismaPromise<GetGastoViajeAggregateType<T>>

    /**
     * Group by GastoViaje.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GastoViajeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GastoViajeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GastoViajeGroupByArgs['orderBy'] }
        : { orderBy?: GastoViajeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GastoViajeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGastoViajeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GastoViaje model
   */
  readonly fields: GastoViajeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GastoViaje.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GastoViajeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    viaje<T extends ViajeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ViajeDefaultArgs<ExtArgs>>): Prisma__ViajeClient<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comprobante<T extends GastoViaje$comprobanteArgs<ExtArgs> = {}>(args?: Subset<T, GastoViaje$comprobanteArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GastoViaje model
   */ 
  interface GastoViajeFieldRefs {
    readonly id: FieldRef<"GastoViaje", 'Int'>
    readonly viajeId: FieldRef<"GastoViaje", 'Int'>
    readonly tipoGasto: FieldRef<"GastoViaje", 'TipoGasto'>
    readonly monto: FieldRef<"GastoViaje", 'Decimal'>
    readonly fecha: FieldRef<"GastoViaje", 'DateTime'>
    readonly metodoPago: FieldRef<"GastoViaje", 'MetodoPago'>
    readonly descripcion: FieldRef<"GastoViaje", 'String'>
    readonly comprobanteId: FieldRef<"GastoViaje", 'Int'>
    readonly creadoEn: FieldRef<"GastoViaje", 'DateTime'>
    readonly actualizadoEn: FieldRef<"GastoViaje", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GastoViaje findUnique
   */
  export type GastoViajeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GastoViaje
     */
    select?: GastoViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GastoViajeInclude<ExtArgs> | null
    /**
     * Filter, which GastoViaje to fetch.
     */
    where: GastoViajeWhereUniqueInput
  }

  /**
   * GastoViaje findUniqueOrThrow
   */
  export type GastoViajeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GastoViaje
     */
    select?: GastoViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GastoViajeInclude<ExtArgs> | null
    /**
     * Filter, which GastoViaje to fetch.
     */
    where: GastoViajeWhereUniqueInput
  }

  /**
   * GastoViaje findFirst
   */
  export type GastoViajeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GastoViaje
     */
    select?: GastoViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GastoViajeInclude<ExtArgs> | null
    /**
     * Filter, which GastoViaje to fetch.
     */
    where?: GastoViajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GastoViajes to fetch.
     */
    orderBy?: GastoViajeOrderByWithRelationInput | GastoViajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GastoViajes.
     */
    cursor?: GastoViajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GastoViajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GastoViajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GastoViajes.
     */
    distinct?: GastoViajeScalarFieldEnum | GastoViajeScalarFieldEnum[]
  }

  /**
   * GastoViaje findFirstOrThrow
   */
  export type GastoViajeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GastoViaje
     */
    select?: GastoViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GastoViajeInclude<ExtArgs> | null
    /**
     * Filter, which GastoViaje to fetch.
     */
    where?: GastoViajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GastoViajes to fetch.
     */
    orderBy?: GastoViajeOrderByWithRelationInput | GastoViajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GastoViajes.
     */
    cursor?: GastoViajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GastoViajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GastoViajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GastoViajes.
     */
    distinct?: GastoViajeScalarFieldEnum | GastoViajeScalarFieldEnum[]
  }

  /**
   * GastoViaje findMany
   */
  export type GastoViajeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GastoViaje
     */
    select?: GastoViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GastoViajeInclude<ExtArgs> | null
    /**
     * Filter, which GastoViajes to fetch.
     */
    where?: GastoViajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GastoViajes to fetch.
     */
    orderBy?: GastoViajeOrderByWithRelationInput | GastoViajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GastoViajes.
     */
    cursor?: GastoViajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GastoViajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GastoViajes.
     */
    skip?: number
    distinct?: GastoViajeScalarFieldEnum | GastoViajeScalarFieldEnum[]
  }

  /**
   * GastoViaje create
   */
  export type GastoViajeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GastoViaje
     */
    select?: GastoViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GastoViajeInclude<ExtArgs> | null
    /**
     * The data needed to create a GastoViaje.
     */
    data: XOR<GastoViajeCreateInput, GastoViajeUncheckedCreateInput>
  }

  /**
   * GastoViaje createMany
   */
  export type GastoViajeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GastoViajes.
     */
    data: GastoViajeCreateManyInput | GastoViajeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GastoViaje createManyAndReturn
   */
  export type GastoViajeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GastoViaje
     */
    select?: GastoViajeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GastoViajes.
     */
    data: GastoViajeCreateManyInput | GastoViajeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GastoViajeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GastoViaje update
   */
  export type GastoViajeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GastoViaje
     */
    select?: GastoViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GastoViajeInclude<ExtArgs> | null
    /**
     * The data needed to update a GastoViaje.
     */
    data: XOR<GastoViajeUpdateInput, GastoViajeUncheckedUpdateInput>
    /**
     * Choose, which GastoViaje to update.
     */
    where: GastoViajeWhereUniqueInput
  }

  /**
   * GastoViaje updateMany
   */
  export type GastoViajeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GastoViajes.
     */
    data: XOR<GastoViajeUpdateManyMutationInput, GastoViajeUncheckedUpdateManyInput>
    /**
     * Filter which GastoViajes to update
     */
    where?: GastoViajeWhereInput
  }

  /**
   * GastoViaje upsert
   */
  export type GastoViajeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GastoViaje
     */
    select?: GastoViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GastoViajeInclude<ExtArgs> | null
    /**
     * The filter to search for the GastoViaje to update in case it exists.
     */
    where: GastoViajeWhereUniqueInput
    /**
     * In case the GastoViaje found by the `where` argument doesn't exist, create a new GastoViaje with this data.
     */
    create: XOR<GastoViajeCreateInput, GastoViajeUncheckedCreateInput>
    /**
     * In case the GastoViaje was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GastoViajeUpdateInput, GastoViajeUncheckedUpdateInput>
  }

  /**
   * GastoViaje delete
   */
  export type GastoViajeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GastoViaje
     */
    select?: GastoViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GastoViajeInclude<ExtArgs> | null
    /**
     * Filter which GastoViaje to delete.
     */
    where: GastoViajeWhereUniqueInput
  }

  /**
   * GastoViaje deleteMany
   */
  export type GastoViajeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GastoViajes to delete
     */
    where?: GastoViajeWhereInput
  }

  /**
   * GastoViaje.comprobante
   */
  export type GastoViaje$comprobanteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    where?: ComprobanteWhereInput
  }

  /**
   * GastoViaje without action
   */
  export type GastoViajeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GastoViaje
     */
    select?: GastoViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GastoViajeInclude<ExtArgs> | null
  }


  /**
   * Model Comprobante
   */

  export type AggregateComprobante = {
    _count: ComprobanteCountAggregateOutputType | null
    _avg: ComprobanteAvgAggregateOutputType | null
    _sum: ComprobanteSumAggregateOutputType | null
    _min: ComprobanteMinAggregateOutputType | null
    _max: ComprobanteMaxAggregateOutputType | null
  }

  export type ComprobanteAvgAggregateOutputType = {
    id: number | null
    referenciaId: number | null
  }

  export type ComprobanteSumAggregateOutputType = {
    id: number | null
    referenciaId: number | null
  }

  export type ComprobanteMinAggregateOutputType = {
    id: number | null
    tipo: $Enums.TipoComprobante | null
    referenciaId: number | null
    url: string | null
    publicId: string | null
    nombreArchivoOriginal: string | null
    creadoEn: Date | null
  }

  export type ComprobanteMaxAggregateOutputType = {
    id: number | null
    tipo: $Enums.TipoComprobante | null
    referenciaId: number | null
    url: string | null
    publicId: string | null
    nombreArchivoOriginal: string | null
    creadoEn: Date | null
  }

  export type ComprobanteCountAggregateOutputType = {
    id: number
    tipo: number
    referenciaId: number
    url: number
    publicId: number
    nombreArchivoOriginal: number
    creadoEn: number
    _all: number
  }


  export type ComprobanteAvgAggregateInputType = {
    id?: true
    referenciaId?: true
  }

  export type ComprobanteSumAggregateInputType = {
    id?: true
    referenciaId?: true
  }

  export type ComprobanteMinAggregateInputType = {
    id?: true
    tipo?: true
    referenciaId?: true
    url?: true
    publicId?: true
    nombreArchivoOriginal?: true
    creadoEn?: true
  }

  export type ComprobanteMaxAggregateInputType = {
    id?: true
    tipo?: true
    referenciaId?: true
    url?: true
    publicId?: true
    nombreArchivoOriginal?: true
    creadoEn?: true
  }

  export type ComprobanteCountAggregateInputType = {
    id?: true
    tipo?: true
    referenciaId?: true
    url?: true
    publicId?: true
    nombreArchivoOriginal?: true
    creadoEn?: true
    _all?: true
  }

  export type ComprobanteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comprobante to aggregate.
     */
    where?: ComprobanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comprobantes to fetch.
     */
    orderBy?: ComprobanteOrderByWithRelationInput | ComprobanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComprobanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comprobantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comprobantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comprobantes
    **/
    _count?: true | ComprobanteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComprobanteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComprobanteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComprobanteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComprobanteMaxAggregateInputType
  }

  export type GetComprobanteAggregateType<T extends ComprobanteAggregateArgs> = {
        [P in keyof T & keyof AggregateComprobante]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComprobante[P]>
      : GetScalarType<T[P], AggregateComprobante[P]>
  }




  export type ComprobanteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComprobanteWhereInput
    orderBy?: ComprobanteOrderByWithAggregationInput | ComprobanteOrderByWithAggregationInput[]
    by: ComprobanteScalarFieldEnum[] | ComprobanteScalarFieldEnum
    having?: ComprobanteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComprobanteCountAggregateInputType | true
    _avg?: ComprobanteAvgAggregateInputType
    _sum?: ComprobanteSumAggregateInputType
    _min?: ComprobanteMinAggregateInputType
    _max?: ComprobanteMaxAggregateInputType
  }

  export type ComprobanteGroupByOutputType = {
    id: number
    tipo: $Enums.TipoComprobante
    referenciaId: number | null
    url: string
    publicId: string
    nombreArchivoOriginal: string
    creadoEn: Date
    _count: ComprobanteCountAggregateOutputType | null
    _avg: ComprobanteAvgAggregateOutputType | null
    _sum: ComprobanteSumAggregateOutputType | null
    _min: ComprobanteMinAggregateOutputType | null
    _max: ComprobanteMaxAggregateOutputType | null
  }

  type GetComprobanteGroupByPayload<T extends ComprobanteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComprobanteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComprobanteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComprobanteGroupByOutputType[P]>
            : GetScalarType<T[P], ComprobanteGroupByOutputType[P]>
        }
      >
    >


  export type ComprobanteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    referenciaId?: boolean
    url?: boolean
    publicId?: boolean
    nombreArchivoOriginal?: boolean
    creadoEn?: boolean
    gastosViaje?: boolean | Comprobante$gastosViajeArgs<ExtArgs>
    mantenimientos?: boolean | Comprobante$mantenimientosArgs<ExtArgs>
    pagosChofer?: boolean | Comprobante$pagosChoferArgs<ExtArgs>
    _count?: boolean | ComprobanteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comprobante"]>

  export type ComprobanteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    referenciaId?: boolean
    url?: boolean
    publicId?: boolean
    nombreArchivoOriginal?: boolean
    creadoEn?: boolean
  }, ExtArgs["result"]["comprobante"]>

  export type ComprobanteSelectScalar = {
    id?: boolean
    tipo?: boolean
    referenciaId?: boolean
    url?: boolean
    publicId?: boolean
    nombreArchivoOriginal?: boolean
    creadoEn?: boolean
  }

  export type ComprobanteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gastosViaje?: boolean | Comprobante$gastosViajeArgs<ExtArgs>
    mantenimientos?: boolean | Comprobante$mantenimientosArgs<ExtArgs>
    pagosChofer?: boolean | Comprobante$pagosChoferArgs<ExtArgs>
    _count?: boolean | ComprobanteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComprobanteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ComprobantePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comprobante"
    objects: {
      gastosViaje: Prisma.$GastoViajePayload<ExtArgs>[]
      mantenimientos: Prisma.$MantenimientoPayload<ExtArgs>[]
      pagosChofer: Prisma.$PagoChoferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipo: $Enums.TipoComprobante
      referenciaId: number | null
      url: string
      publicId: string
      nombreArchivoOriginal: string
      creadoEn: Date
    }, ExtArgs["result"]["comprobante"]>
    composites: {}
  }

  type ComprobanteGetPayload<S extends boolean | null | undefined | ComprobanteDefaultArgs> = $Result.GetResult<Prisma.$ComprobantePayload, S>

  type ComprobanteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComprobanteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComprobanteCountAggregateInputType | true
    }

  export interface ComprobanteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comprobante'], meta: { name: 'Comprobante' } }
    /**
     * Find zero or one Comprobante that matches the filter.
     * @param {ComprobanteFindUniqueArgs} args - Arguments to find a Comprobante
     * @example
     * // Get one Comprobante
     * const comprobante = await prisma.comprobante.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComprobanteFindUniqueArgs>(args: SelectSubset<T, ComprobanteFindUniqueArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comprobante that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComprobanteFindUniqueOrThrowArgs} args - Arguments to find a Comprobante
     * @example
     * // Get one Comprobante
     * const comprobante = await prisma.comprobante.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComprobanteFindUniqueOrThrowArgs>(args: SelectSubset<T, ComprobanteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comprobante that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprobanteFindFirstArgs} args - Arguments to find a Comprobante
     * @example
     * // Get one Comprobante
     * const comprobante = await prisma.comprobante.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComprobanteFindFirstArgs>(args?: SelectSubset<T, ComprobanteFindFirstArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comprobante that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprobanteFindFirstOrThrowArgs} args - Arguments to find a Comprobante
     * @example
     * // Get one Comprobante
     * const comprobante = await prisma.comprobante.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComprobanteFindFirstOrThrowArgs>(args?: SelectSubset<T, ComprobanteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comprobantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprobanteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comprobantes
     * const comprobantes = await prisma.comprobante.findMany()
     * 
     * // Get first 10 Comprobantes
     * const comprobantes = await prisma.comprobante.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comprobanteWithIdOnly = await prisma.comprobante.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComprobanteFindManyArgs>(args?: SelectSubset<T, ComprobanteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comprobante.
     * @param {ComprobanteCreateArgs} args - Arguments to create a Comprobante.
     * @example
     * // Create one Comprobante
     * const Comprobante = await prisma.comprobante.create({
     *   data: {
     *     // ... data to create a Comprobante
     *   }
     * })
     * 
     */
    create<T extends ComprobanteCreateArgs>(args: SelectSubset<T, ComprobanteCreateArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comprobantes.
     * @param {ComprobanteCreateManyArgs} args - Arguments to create many Comprobantes.
     * @example
     * // Create many Comprobantes
     * const comprobante = await prisma.comprobante.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComprobanteCreateManyArgs>(args?: SelectSubset<T, ComprobanteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comprobantes and returns the data saved in the database.
     * @param {ComprobanteCreateManyAndReturnArgs} args - Arguments to create many Comprobantes.
     * @example
     * // Create many Comprobantes
     * const comprobante = await prisma.comprobante.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comprobantes and only return the `id`
     * const comprobanteWithIdOnly = await prisma.comprobante.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComprobanteCreateManyAndReturnArgs>(args?: SelectSubset<T, ComprobanteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comprobante.
     * @param {ComprobanteDeleteArgs} args - Arguments to delete one Comprobante.
     * @example
     * // Delete one Comprobante
     * const Comprobante = await prisma.comprobante.delete({
     *   where: {
     *     // ... filter to delete one Comprobante
     *   }
     * })
     * 
     */
    delete<T extends ComprobanteDeleteArgs>(args: SelectSubset<T, ComprobanteDeleteArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comprobante.
     * @param {ComprobanteUpdateArgs} args - Arguments to update one Comprobante.
     * @example
     * // Update one Comprobante
     * const comprobante = await prisma.comprobante.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComprobanteUpdateArgs>(args: SelectSubset<T, ComprobanteUpdateArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comprobantes.
     * @param {ComprobanteDeleteManyArgs} args - Arguments to filter Comprobantes to delete.
     * @example
     * // Delete a few Comprobantes
     * const { count } = await prisma.comprobante.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComprobanteDeleteManyArgs>(args?: SelectSubset<T, ComprobanteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comprobantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprobanteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comprobantes
     * const comprobante = await prisma.comprobante.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComprobanteUpdateManyArgs>(args: SelectSubset<T, ComprobanteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comprobante.
     * @param {ComprobanteUpsertArgs} args - Arguments to update or create a Comprobante.
     * @example
     * // Update or create a Comprobante
     * const comprobante = await prisma.comprobante.upsert({
     *   create: {
     *     // ... data to create a Comprobante
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comprobante we want to update
     *   }
     * })
     */
    upsert<T extends ComprobanteUpsertArgs>(args: SelectSubset<T, ComprobanteUpsertArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comprobantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprobanteCountArgs} args - Arguments to filter Comprobantes to count.
     * @example
     * // Count the number of Comprobantes
     * const count = await prisma.comprobante.count({
     *   where: {
     *     // ... the filter for the Comprobantes we want to count
     *   }
     * })
    **/
    count<T extends ComprobanteCountArgs>(
      args?: Subset<T, ComprobanteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComprobanteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comprobante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprobanteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComprobanteAggregateArgs>(args: Subset<T, ComprobanteAggregateArgs>): Prisma.PrismaPromise<GetComprobanteAggregateType<T>>

    /**
     * Group by Comprobante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprobanteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComprobanteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComprobanteGroupByArgs['orderBy'] }
        : { orderBy?: ComprobanteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComprobanteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComprobanteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comprobante model
   */
  readonly fields: ComprobanteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comprobante.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComprobanteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gastosViaje<T extends Comprobante$gastosViajeArgs<ExtArgs> = {}>(args?: Subset<T, Comprobante$gastosViajeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GastoViajePayload<ExtArgs>, T, "findMany"> | Null>
    mantenimientos<T extends Comprobante$mantenimientosArgs<ExtArgs> = {}>(args?: Subset<T, Comprobante$mantenimientosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MantenimientoPayload<ExtArgs>, T, "findMany"> | Null>
    pagosChofer<T extends Comprobante$pagosChoferArgs<ExtArgs> = {}>(args?: Subset<T, Comprobante$pagosChoferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoChoferPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comprobante model
   */ 
  interface ComprobanteFieldRefs {
    readonly id: FieldRef<"Comprobante", 'Int'>
    readonly tipo: FieldRef<"Comprobante", 'TipoComprobante'>
    readonly referenciaId: FieldRef<"Comprobante", 'Int'>
    readonly url: FieldRef<"Comprobante", 'String'>
    readonly publicId: FieldRef<"Comprobante", 'String'>
    readonly nombreArchivoOriginal: FieldRef<"Comprobante", 'String'>
    readonly creadoEn: FieldRef<"Comprobante", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comprobante findUnique
   */
  export type ComprobanteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * Filter, which Comprobante to fetch.
     */
    where: ComprobanteWhereUniqueInput
  }

  /**
   * Comprobante findUniqueOrThrow
   */
  export type ComprobanteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * Filter, which Comprobante to fetch.
     */
    where: ComprobanteWhereUniqueInput
  }

  /**
   * Comprobante findFirst
   */
  export type ComprobanteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * Filter, which Comprobante to fetch.
     */
    where?: ComprobanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comprobantes to fetch.
     */
    orderBy?: ComprobanteOrderByWithRelationInput | ComprobanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comprobantes.
     */
    cursor?: ComprobanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comprobantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comprobantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comprobantes.
     */
    distinct?: ComprobanteScalarFieldEnum | ComprobanteScalarFieldEnum[]
  }

  /**
   * Comprobante findFirstOrThrow
   */
  export type ComprobanteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * Filter, which Comprobante to fetch.
     */
    where?: ComprobanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comprobantes to fetch.
     */
    orderBy?: ComprobanteOrderByWithRelationInput | ComprobanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comprobantes.
     */
    cursor?: ComprobanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comprobantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comprobantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comprobantes.
     */
    distinct?: ComprobanteScalarFieldEnum | ComprobanteScalarFieldEnum[]
  }

  /**
   * Comprobante findMany
   */
  export type ComprobanteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * Filter, which Comprobantes to fetch.
     */
    where?: ComprobanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comprobantes to fetch.
     */
    orderBy?: ComprobanteOrderByWithRelationInput | ComprobanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comprobantes.
     */
    cursor?: ComprobanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comprobantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comprobantes.
     */
    skip?: number
    distinct?: ComprobanteScalarFieldEnum | ComprobanteScalarFieldEnum[]
  }

  /**
   * Comprobante create
   */
  export type ComprobanteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * The data needed to create a Comprobante.
     */
    data: XOR<ComprobanteCreateInput, ComprobanteUncheckedCreateInput>
  }

  /**
   * Comprobante createMany
   */
  export type ComprobanteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comprobantes.
     */
    data: ComprobanteCreateManyInput | ComprobanteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comprobante createManyAndReturn
   */
  export type ComprobanteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comprobantes.
     */
    data: ComprobanteCreateManyInput | ComprobanteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comprobante update
   */
  export type ComprobanteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * The data needed to update a Comprobante.
     */
    data: XOR<ComprobanteUpdateInput, ComprobanteUncheckedUpdateInput>
    /**
     * Choose, which Comprobante to update.
     */
    where: ComprobanteWhereUniqueInput
  }

  /**
   * Comprobante updateMany
   */
  export type ComprobanteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comprobantes.
     */
    data: XOR<ComprobanteUpdateManyMutationInput, ComprobanteUncheckedUpdateManyInput>
    /**
     * Filter which Comprobantes to update
     */
    where?: ComprobanteWhereInput
  }

  /**
   * Comprobante upsert
   */
  export type ComprobanteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * The filter to search for the Comprobante to update in case it exists.
     */
    where: ComprobanteWhereUniqueInput
    /**
     * In case the Comprobante found by the `where` argument doesn't exist, create a new Comprobante with this data.
     */
    create: XOR<ComprobanteCreateInput, ComprobanteUncheckedCreateInput>
    /**
     * In case the Comprobante was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComprobanteUpdateInput, ComprobanteUncheckedUpdateInput>
  }

  /**
   * Comprobante delete
   */
  export type ComprobanteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * Filter which Comprobante to delete.
     */
    where: ComprobanteWhereUniqueInput
  }

  /**
   * Comprobante deleteMany
   */
  export type ComprobanteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comprobantes to delete
     */
    where?: ComprobanteWhereInput
  }

  /**
   * Comprobante.gastosViaje
   */
  export type Comprobante$gastosViajeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GastoViaje
     */
    select?: GastoViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GastoViajeInclude<ExtArgs> | null
    where?: GastoViajeWhereInput
    orderBy?: GastoViajeOrderByWithRelationInput | GastoViajeOrderByWithRelationInput[]
    cursor?: GastoViajeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GastoViajeScalarFieldEnum | GastoViajeScalarFieldEnum[]
  }

  /**
   * Comprobante.mantenimientos
   */
  export type Comprobante$mantenimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mantenimiento
     */
    select?: MantenimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MantenimientoInclude<ExtArgs> | null
    where?: MantenimientoWhereInput
    orderBy?: MantenimientoOrderByWithRelationInput | MantenimientoOrderByWithRelationInput[]
    cursor?: MantenimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MantenimientoScalarFieldEnum | MantenimientoScalarFieldEnum[]
  }

  /**
   * Comprobante.pagosChofer
   */
  export type Comprobante$pagosChoferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoChofer
     */
    select?: PagoChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoChoferInclude<ExtArgs> | null
    where?: PagoChoferWhereInput
    orderBy?: PagoChoferOrderByWithRelationInput | PagoChoferOrderByWithRelationInput[]
    cursor?: PagoChoferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagoChoferScalarFieldEnum | PagoChoferScalarFieldEnum[]
  }

  /**
   * Comprobante without action
   */
  export type ComprobanteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
  }


  /**
   * Model Mantenimiento
   */

  export type AggregateMantenimiento = {
    _count: MantenimientoCountAggregateOutputType | null
    _avg: MantenimientoAvgAggregateOutputType | null
    _sum: MantenimientoSumAggregateOutputType | null
    _min: MantenimientoMinAggregateOutputType | null
    _max: MantenimientoMaxAggregateOutputType | null
  }

  export type MantenimientoAvgAggregateOutputType = {
    id: number | null
    vehiculoId: number | null
    costoManoObra: Decimal | null
    costoRepuestos: Decimal | null
    costoTotal: Decimal | null
    kilometrajeAlMomento: number | null
    proximoKilometraje: number | null
    comprobanteId: number | null
  }

  export type MantenimientoSumAggregateOutputType = {
    id: number | null
    vehiculoId: number | null
    costoManoObra: Decimal | null
    costoRepuestos: Decimal | null
    costoTotal: Decimal | null
    kilometrajeAlMomento: number | null
    proximoKilometraje: number | null
    comprobanteId: number | null
  }

  export type MantenimientoMinAggregateOutputType = {
    id: number | null
    vehiculoId: number | null
    tipo: $Enums.TipoMantenimiento | null
    estado: $Enums.EstadoMantenimiento | null
    descripcion: string | null
    taller: string | null
    esExterno: boolean | null
    costoManoObra: Decimal | null
    costoRepuestos: Decimal | null
    costoTotal: Decimal | null
    fecha: Date | null
    fechaInicio: Date | null
    fechaFin: Date | null
    kilometrajeAlMomento: number | null
    proximaFecha: Date | null
    proximoKilometraje: number | null
    comprobanteId: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type MantenimientoMaxAggregateOutputType = {
    id: number | null
    vehiculoId: number | null
    tipo: $Enums.TipoMantenimiento | null
    estado: $Enums.EstadoMantenimiento | null
    descripcion: string | null
    taller: string | null
    esExterno: boolean | null
    costoManoObra: Decimal | null
    costoRepuestos: Decimal | null
    costoTotal: Decimal | null
    fecha: Date | null
    fechaInicio: Date | null
    fechaFin: Date | null
    kilometrajeAlMomento: number | null
    proximaFecha: Date | null
    proximoKilometraje: number | null
    comprobanteId: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type MantenimientoCountAggregateOutputType = {
    id: number
    vehiculoId: number
    tipo: number
    estado: number
    descripcion: number
    taller: number
    esExterno: number
    costoManoObra: number
    costoRepuestos: number
    costoTotal: number
    fecha: number
    fechaInicio: number
    fechaFin: number
    kilometrajeAlMomento: number
    proximaFecha: number
    proximoKilometraje: number
    comprobanteId: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type MantenimientoAvgAggregateInputType = {
    id?: true
    vehiculoId?: true
    costoManoObra?: true
    costoRepuestos?: true
    costoTotal?: true
    kilometrajeAlMomento?: true
    proximoKilometraje?: true
    comprobanteId?: true
  }

  export type MantenimientoSumAggregateInputType = {
    id?: true
    vehiculoId?: true
    costoManoObra?: true
    costoRepuestos?: true
    costoTotal?: true
    kilometrajeAlMomento?: true
    proximoKilometraje?: true
    comprobanteId?: true
  }

  export type MantenimientoMinAggregateInputType = {
    id?: true
    vehiculoId?: true
    tipo?: true
    estado?: true
    descripcion?: true
    taller?: true
    esExterno?: true
    costoManoObra?: true
    costoRepuestos?: true
    costoTotal?: true
    fecha?: true
    fechaInicio?: true
    fechaFin?: true
    kilometrajeAlMomento?: true
    proximaFecha?: true
    proximoKilometraje?: true
    comprobanteId?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type MantenimientoMaxAggregateInputType = {
    id?: true
    vehiculoId?: true
    tipo?: true
    estado?: true
    descripcion?: true
    taller?: true
    esExterno?: true
    costoManoObra?: true
    costoRepuestos?: true
    costoTotal?: true
    fecha?: true
    fechaInicio?: true
    fechaFin?: true
    kilometrajeAlMomento?: true
    proximaFecha?: true
    proximoKilometraje?: true
    comprobanteId?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type MantenimientoCountAggregateInputType = {
    id?: true
    vehiculoId?: true
    tipo?: true
    estado?: true
    descripcion?: true
    taller?: true
    esExterno?: true
    costoManoObra?: true
    costoRepuestos?: true
    costoTotal?: true
    fecha?: true
    fechaInicio?: true
    fechaFin?: true
    kilometrajeAlMomento?: true
    proximaFecha?: true
    proximoKilometraje?: true
    comprobanteId?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type MantenimientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mantenimiento to aggregate.
     */
    where?: MantenimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mantenimientos to fetch.
     */
    orderBy?: MantenimientoOrderByWithRelationInput | MantenimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MantenimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mantenimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mantenimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mantenimientos
    **/
    _count?: true | MantenimientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MantenimientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MantenimientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MantenimientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MantenimientoMaxAggregateInputType
  }

  export type GetMantenimientoAggregateType<T extends MantenimientoAggregateArgs> = {
        [P in keyof T & keyof AggregateMantenimiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMantenimiento[P]>
      : GetScalarType<T[P], AggregateMantenimiento[P]>
  }




  export type MantenimientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MantenimientoWhereInput
    orderBy?: MantenimientoOrderByWithAggregationInput | MantenimientoOrderByWithAggregationInput[]
    by: MantenimientoScalarFieldEnum[] | MantenimientoScalarFieldEnum
    having?: MantenimientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MantenimientoCountAggregateInputType | true
    _avg?: MantenimientoAvgAggregateInputType
    _sum?: MantenimientoSumAggregateInputType
    _min?: MantenimientoMinAggregateInputType
    _max?: MantenimientoMaxAggregateInputType
  }

  export type MantenimientoGroupByOutputType = {
    id: number
    vehiculoId: number
    tipo: $Enums.TipoMantenimiento
    estado: $Enums.EstadoMantenimiento
    descripcion: string | null
    taller: string | null
    esExterno: boolean
    costoManoObra: Decimal
    costoRepuestos: Decimal
    costoTotal: Decimal
    fecha: Date
    fechaInicio: Date | null
    fechaFin: Date | null
    kilometrajeAlMomento: number | null
    proximaFecha: Date | null
    proximoKilometraje: number | null
    comprobanteId: number | null
    creadoEn: Date
    actualizadoEn: Date
    _count: MantenimientoCountAggregateOutputType | null
    _avg: MantenimientoAvgAggregateOutputType | null
    _sum: MantenimientoSumAggregateOutputType | null
    _min: MantenimientoMinAggregateOutputType | null
    _max: MantenimientoMaxAggregateOutputType | null
  }

  type GetMantenimientoGroupByPayload<T extends MantenimientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MantenimientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MantenimientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MantenimientoGroupByOutputType[P]>
            : GetScalarType<T[P], MantenimientoGroupByOutputType[P]>
        }
      >
    >


  export type MantenimientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehiculoId?: boolean
    tipo?: boolean
    estado?: boolean
    descripcion?: boolean
    taller?: boolean
    esExterno?: boolean
    costoManoObra?: boolean
    costoRepuestos?: boolean
    costoTotal?: boolean
    fecha?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    kilometrajeAlMomento?: boolean
    proximaFecha?: boolean
    proximoKilometraje?: boolean
    comprobanteId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    vehiculo?: boolean | VehiculoDefaultArgs<ExtArgs>
    comprobante?: boolean | Mantenimiento$comprobanteArgs<ExtArgs>
  }, ExtArgs["result"]["mantenimiento"]>

  export type MantenimientoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehiculoId?: boolean
    tipo?: boolean
    estado?: boolean
    descripcion?: boolean
    taller?: boolean
    esExterno?: boolean
    costoManoObra?: boolean
    costoRepuestos?: boolean
    costoTotal?: boolean
    fecha?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    kilometrajeAlMomento?: boolean
    proximaFecha?: boolean
    proximoKilometraje?: boolean
    comprobanteId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    vehiculo?: boolean | VehiculoDefaultArgs<ExtArgs>
    comprobante?: boolean | Mantenimiento$comprobanteArgs<ExtArgs>
  }, ExtArgs["result"]["mantenimiento"]>

  export type MantenimientoSelectScalar = {
    id?: boolean
    vehiculoId?: boolean
    tipo?: boolean
    estado?: boolean
    descripcion?: boolean
    taller?: boolean
    esExterno?: boolean
    costoManoObra?: boolean
    costoRepuestos?: boolean
    costoTotal?: boolean
    fecha?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    kilometrajeAlMomento?: boolean
    proximaFecha?: boolean
    proximoKilometraje?: boolean
    comprobanteId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type MantenimientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehiculo?: boolean | VehiculoDefaultArgs<ExtArgs>
    comprobante?: boolean | Mantenimiento$comprobanteArgs<ExtArgs>
  }
  export type MantenimientoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehiculo?: boolean | VehiculoDefaultArgs<ExtArgs>
    comprobante?: boolean | Mantenimiento$comprobanteArgs<ExtArgs>
  }

  export type $MantenimientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mantenimiento"
    objects: {
      vehiculo: Prisma.$VehiculoPayload<ExtArgs>
      comprobante: Prisma.$ComprobantePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vehiculoId: number
      tipo: $Enums.TipoMantenimiento
      estado: $Enums.EstadoMantenimiento
      descripcion: string | null
      taller: string | null
      esExterno: boolean
      costoManoObra: Prisma.Decimal
      costoRepuestos: Prisma.Decimal
      costoTotal: Prisma.Decimal
      fecha: Date
      fechaInicio: Date | null
      fechaFin: Date | null
      kilometrajeAlMomento: number | null
      proximaFecha: Date | null
      proximoKilometraje: number | null
      comprobanteId: number | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["mantenimiento"]>
    composites: {}
  }

  type MantenimientoGetPayload<S extends boolean | null | undefined | MantenimientoDefaultArgs> = $Result.GetResult<Prisma.$MantenimientoPayload, S>

  type MantenimientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MantenimientoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MantenimientoCountAggregateInputType | true
    }

  export interface MantenimientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mantenimiento'], meta: { name: 'Mantenimiento' } }
    /**
     * Find zero or one Mantenimiento that matches the filter.
     * @param {MantenimientoFindUniqueArgs} args - Arguments to find a Mantenimiento
     * @example
     * // Get one Mantenimiento
     * const mantenimiento = await prisma.mantenimiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MantenimientoFindUniqueArgs>(args: SelectSubset<T, MantenimientoFindUniqueArgs<ExtArgs>>): Prisma__MantenimientoClient<$Result.GetResult<Prisma.$MantenimientoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mantenimiento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MantenimientoFindUniqueOrThrowArgs} args - Arguments to find a Mantenimiento
     * @example
     * // Get one Mantenimiento
     * const mantenimiento = await prisma.mantenimiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MantenimientoFindUniqueOrThrowArgs>(args: SelectSubset<T, MantenimientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MantenimientoClient<$Result.GetResult<Prisma.$MantenimientoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mantenimiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MantenimientoFindFirstArgs} args - Arguments to find a Mantenimiento
     * @example
     * // Get one Mantenimiento
     * const mantenimiento = await prisma.mantenimiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MantenimientoFindFirstArgs>(args?: SelectSubset<T, MantenimientoFindFirstArgs<ExtArgs>>): Prisma__MantenimientoClient<$Result.GetResult<Prisma.$MantenimientoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mantenimiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MantenimientoFindFirstOrThrowArgs} args - Arguments to find a Mantenimiento
     * @example
     * // Get one Mantenimiento
     * const mantenimiento = await prisma.mantenimiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MantenimientoFindFirstOrThrowArgs>(args?: SelectSubset<T, MantenimientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__MantenimientoClient<$Result.GetResult<Prisma.$MantenimientoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mantenimientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MantenimientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mantenimientos
     * const mantenimientos = await prisma.mantenimiento.findMany()
     * 
     * // Get first 10 Mantenimientos
     * const mantenimientos = await prisma.mantenimiento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mantenimientoWithIdOnly = await prisma.mantenimiento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MantenimientoFindManyArgs>(args?: SelectSubset<T, MantenimientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MantenimientoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mantenimiento.
     * @param {MantenimientoCreateArgs} args - Arguments to create a Mantenimiento.
     * @example
     * // Create one Mantenimiento
     * const Mantenimiento = await prisma.mantenimiento.create({
     *   data: {
     *     // ... data to create a Mantenimiento
     *   }
     * })
     * 
     */
    create<T extends MantenimientoCreateArgs>(args: SelectSubset<T, MantenimientoCreateArgs<ExtArgs>>): Prisma__MantenimientoClient<$Result.GetResult<Prisma.$MantenimientoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mantenimientos.
     * @param {MantenimientoCreateManyArgs} args - Arguments to create many Mantenimientos.
     * @example
     * // Create many Mantenimientos
     * const mantenimiento = await prisma.mantenimiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MantenimientoCreateManyArgs>(args?: SelectSubset<T, MantenimientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mantenimientos and returns the data saved in the database.
     * @param {MantenimientoCreateManyAndReturnArgs} args - Arguments to create many Mantenimientos.
     * @example
     * // Create many Mantenimientos
     * const mantenimiento = await prisma.mantenimiento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mantenimientos and only return the `id`
     * const mantenimientoWithIdOnly = await prisma.mantenimiento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MantenimientoCreateManyAndReturnArgs>(args?: SelectSubset<T, MantenimientoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MantenimientoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mantenimiento.
     * @param {MantenimientoDeleteArgs} args - Arguments to delete one Mantenimiento.
     * @example
     * // Delete one Mantenimiento
     * const Mantenimiento = await prisma.mantenimiento.delete({
     *   where: {
     *     // ... filter to delete one Mantenimiento
     *   }
     * })
     * 
     */
    delete<T extends MantenimientoDeleteArgs>(args: SelectSubset<T, MantenimientoDeleteArgs<ExtArgs>>): Prisma__MantenimientoClient<$Result.GetResult<Prisma.$MantenimientoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mantenimiento.
     * @param {MantenimientoUpdateArgs} args - Arguments to update one Mantenimiento.
     * @example
     * // Update one Mantenimiento
     * const mantenimiento = await prisma.mantenimiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MantenimientoUpdateArgs>(args: SelectSubset<T, MantenimientoUpdateArgs<ExtArgs>>): Prisma__MantenimientoClient<$Result.GetResult<Prisma.$MantenimientoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mantenimientos.
     * @param {MantenimientoDeleteManyArgs} args - Arguments to filter Mantenimientos to delete.
     * @example
     * // Delete a few Mantenimientos
     * const { count } = await prisma.mantenimiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MantenimientoDeleteManyArgs>(args?: SelectSubset<T, MantenimientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mantenimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MantenimientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mantenimientos
     * const mantenimiento = await prisma.mantenimiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MantenimientoUpdateManyArgs>(args: SelectSubset<T, MantenimientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mantenimiento.
     * @param {MantenimientoUpsertArgs} args - Arguments to update or create a Mantenimiento.
     * @example
     * // Update or create a Mantenimiento
     * const mantenimiento = await prisma.mantenimiento.upsert({
     *   create: {
     *     // ... data to create a Mantenimiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mantenimiento we want to update
     *   }
     * })
     */
    upsert<T extends MantenimientoUpsertArgs>(args: SelectSubset<T, MantenimientoUpsertArgs<ExtArgs>>): Prisma__MantenimientoClient<$Result.GetResult<Prisma.$MantenimientoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mantenimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MantenimientoCountArgs} args - Arguments to filter Mantenimientos to count.
     * @example
     * // Count the number of Mantenimientos
     * const count = await prisma.mantenimiento.count({
     *   where: {
     *     // ... the filter for the Mantenimientos we want to count
     *   }
     * })
    **/
    count<T extends MantenimientoCountArgs>(
      args?: Subset<T, MantenimientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MantenimientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mantenimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MantenimientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MantenimientoAggregateArgs>(args: Subset<T, MantenimientoAggregateArgs>): Prisma.PrismaPromise<GetMantenimientoAggregateType<T>>

    /**
     * Group by Mantenimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MantenimientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MantenimientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MantenimientoGroupByArgs['orderBy'] }
        : { orderBy?: MantenimientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MantenimientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMantenimientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mantenimiento model
   */
  readonly fields: MantenimientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mantenimiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MantenimientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehiculo<T extends VehiculoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehiculoDefaultArgs<ExtArgs>>): Prisma__VehiculoClient<$Result.GetResult<Prisma.$VehiculoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comprobante<T extends Mantenimiento$comprobanteArgs<ExtArgs> = {}>(args?: Subset<T, Mantenimiento$comprobanteArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mantenimiento model
   */ 
  interface MantenimientoFieldRefs {
    readonly id: FieldRef<"Mantenimiento", 'Int'>
    readonly vehiculoId: FieldRef<"Mantenimiento", 'Int'>
    readonly tipo: FieldRef<"Mantenimiento", 'TipoMantenimiento'>
    readonly estado: FieldRef<"Mantenimiento", 'EstadoMantenimiento'>
    readonly descripcion: FieldRef<"Mantenimiento", 'String'>
    readonly taller: FieldRef<"Mantenimiento", 'String'>
    readonly esExterno: FieldRef<"Mantenimiento", 'Boolean'>
    readonly costoManoObra: FieldRef<"Mantenimiento", 'Decimal'>
    readonly costoRepuestos: FieldRef<"Mantenimiento", 'Decimal'>
    readonly costoTotal: FieldRef<"Mantenimiento", 'Decimal'>
    readonly fecha: FieldRef<"Mantenimiento", 'DateTime'>
    readonly fechaInicio: FieldRef<"Mantenimiento", 'DateTime'>
    readonly fechaFin: FieldRef<"Mantenimiento", 'DateTime'>
    readonly kilometrajeAlMomento: FieldRef<"Mantenimiento", 'Int'>
    readonly proximaFecha: FieldRef<"Mantenimiento", 'DateTime'>
    readonly proximoKilometraje: FieldRef<"Mantenimiento", 'Int'>
    readonly comprobanteId: FieldRef<"Mantenimiento", 'Int'>
    readonly creadoEn: FieldRef<"Mantenimiento", 'DateTime'>
    readonly actualizadoEn: FieldRef<"Mantenimiento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mantenimiento findUnique
   */
  export type MantenimientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mantenimiento
     */
    select?: MantenimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MantenimientoInclude<ExtArgs> | null
    /**
     * Filter, which Mantenimiento to fetch.
     */
    where: MantenimientoWhereUniqueInput
  }

  /**
   * Mantenimiento findUniqueOrThrow
   */
  export type MantenimientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mantenimiento
     */
    select?: MantenimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MantenimientoInclude<ExtArgs> | null
    /**
     * Filter, which Mantenimiento to fetch.
     */
    where: MantenimientoWhereUniqueInput
  }

  /**
   * Mantenimiento findFirst
   */
  export type MantenimientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mantenimiento
     */
    select?: MantenimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MantenimientoInclude<ExtArgs> | null
    /**
     * Filter, which Mantenimiento to fetch.
     */
    where?: MantenimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mantenimientos to fetch.
     */
    orderBy?: MantenimientoOrderByWithRelationInput | MantenimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mantenimientos.
     */
    cursor?: MantenimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mantenimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mantenimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mantenimientos.
     */
    distinct?: MantenimientoScalarFieldEnum | MantenimientoScalarFieldEnum[]
  }

  /**
   * Mantenimiento findFirstOrThrow
   */
  export type MantenimientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mantenimiento
     */
    select?: MantenimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MantenimientoInclude<ExtArgs> | null
    /**
     * Filter, which Mantenimiento to fetch.
     */
    where?: MantenimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mantenimientos to fetch.
     */
    orderBy?: MantenimientoOrderByWithRelationInput | MantenimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mantenimientos.
     */
    cursor?: MantenimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mantenimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mantenimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mantenimientos.
     */
    distinct?: MantenimientoScalarFieldEnum | MantenimientoScalarFieldEnum[]
  }

  /**
   * Mantenimiento findMany
   */
  export type MantenimientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mantenimiento
     */
    select?: MantenimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MantenimientoInclude<ExtArgs> | null
    /**
     * Filter, which Mantenimientos to fetch.
     */
    where?: MantenimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mantenimientos to fetch.
     */
    orderBy?: MantenimientoOrderByWithRelationInput | MantenimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mantenimientos.
     */
    cursor?: MantenimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mantenimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mantenimientos.
     */
    skip?: number
    distinct?: MantenimientoScalarFieldEnum | MantenimientoScalarFieldEnum[]
  }

  /**
   * Mantenimiento create
   */
  export type MantenimientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mantenimiento
     */
    select?: MantenimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MantenimientoInclude<ExtArgs> | null
    /**
     * The data needed to create a Mantenimiento.
     */
    data: XOR<MantenimientoCreateInput, MantenimientoUncheckedCreateInput>
  }

  /**
   * Mantenimiento createMany
   */
  export type MantenimientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mantenimientos.
     */
    data: MantenimientoCreateManyInput | MantenimientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mantenimiento createManyAndReturn
   */
  export type MantenimientoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mantenimiento
     */
    select?: MantenimientoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Mantenimientos.
     */
    data: MantenimientoCreateManyInput | MantenimientoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MantenimientoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mantenimiento update
   */
  export type MantenimientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mantenimiento
     */
    select?: MantenimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MantenimientoInclude<ExtArgs> | null
    /**
     * The data needed to update a Mantenimiento.
     */
    data: XOR<MantenimientoUpdateInput, MantenimientoUncheckedUpdateInput>
    /**
     * Choose, which Mantenimiento to update.
     */
    where: MantenimientoWhereUniqueInput
  }

  /**
   * Mantenimiento updateMany
   */
  export type MantenimientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mantenimientos.
     */
    data: XOR<MantenimientoUpdateManyMutationInput, MantenimientoUncheckedUpdateManyInput>
    /**
     * Filter which Mantenimientos to update
     */
    where?: MantenimientoWhereInput
  }

  /**
   * Mantenimiento upsert
   */
  export type MantenimientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mantenimiento
     */
    select?: MantenimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MantenimientoInclude<ExtArgs> | null
    /**
     * The filter to search for the Mantenimiento to update in case it exists.
     */
    where: MantenimientoWhereUniqueInput
    /**
     * In case the Mantenimiento found by the `where` argument doesn't exist, create a new Mantenimiento with this data.
     */
    create: XOR<MantenimientoCreateInput, MantenimientoUncheckedCreateInput>
    /**
     * In case the Mantenimiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MantenimientoUpdateInput, MantenimientoUncheckedUpdateInput>
  }

  /**
   * Mantenimiento delete
   */
  export type MantenimientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mantenimiento
     */
    select?: MantenimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MantenimientoInclude<ExtArgs> | null
    /**
     * Filter which Mantenimiento to delete.
     */
    where: MantenimientoWhereUniqueInput
  }

  /**
   * Mantenimiento deleteMany
   */
  export type MantenimientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mantenimientos to delete
     */
    where?: MantenimientoWhereInput
  }

  /**
   * Mantenimiento.comprobante
   */
  export type Mantenimiento$comprobanteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    where?: ComprobanteWhereInput
  }

  /**
   * Mantenimiento without action
   */
  export type MantenimientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mantenimiento
     */
    select?: MantenimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MantenimientoInclude<ExtArgs> | null
  }


  /**
   * Model PagoChofer
   */

  export type AggregatePagoChofer = {
    _count: PagoChoferCountAggregateOutputType | null
    _avg: PagoChoferAvgAggregateOutputType | null
    _sum: PagoChoferSumAggregateOutputType | null
    _min: PagoChoferMinAggregateOutputType | null
    _max: PagoChoferMaxAggregateOutputType | null
  }

  export type PagoChoferAvgAggregateOutputType = {
    id: number | null
    choferId: number | null
    monto: Decimal | null
    comprobanteId: number | null
    viajeId: number | null
  }

  export type PagoChoferSumAggregateOutputType = {
    id: number | null
    choferId: number | null
    monto: Decimal | null
    comprobanteId: number | null
    viajeId: number | null
  }

  export type PagoChoferMinAggregateOutputType = {
    id: number | null
    choferId: number | null
    monto: Decimal | null
    fecha: Date | null
    metodoPago: $Enums.MetodoPago | null
    descripcion: string | null
    estado: $Enums.EstadoPagoChofer | null
    fechaPagoReal: Date | null
    comprobanteId: number | null
    viajeId: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type PagoChoferMaxAggregateOutputType = {
    id: number | null
    choferId: number | null
    monto: Decimal | null
    fecha: Date | null
    metodoPago: $Enums.MetodoPago | null
    descripcion: string | null
    estado: $Enums.EstadoPagoChofer | null
    fechaPagoReal: Date | null
    comprobanteId: number | null
    viajeId: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type PagoChoferCountAggregateOutputType = {
    id: number
    choferId: number
    monto: number
    fecha: number
    metodoPago: number
    descripcion: number
    estado: number
    fechaPagoReal: number
    comprobanteId: number
    viajeId: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type PagoChoferAvgAggregateInputType = {
    id?: true
    choferId?: true
    monto?: true
    comprobanteId?: true
    viajeId?: true
  }

  export type PagoChoferSumAggregateInputType = {
    id?: true
    choferId?: true
    monto?: true
    comprobanteId?: true
    viajeId?: true
  }

  export type PagoChoferMinAggregateInputType = {
    id?: true
    choferId?: true
    monto?: true
    fecha?: true
    metodoPago?: true
    descripcion?: true
    estado?: true
    fechaPagoReal?: true
    comprobanteId?: true
    viajeId?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type PagoChoferMaxAggregateInputType = {
    id?: true
    choferId?: true
    monto?: true
    fecha?: true
    metodoPago?: true
    descripcion?: true
    estado?: true
    fechaPagoReal?: true
    comprobanteId?: true
    viajeId?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type PagoChoferCountAggregateInputType = {
    id?: true
    choferId?: true
    monto?: true
    fecha?: true
    metodoPago?: true
    descripcion?: true
    estado?: true
    fechaPagoReal?: true
    comprobanteId?: true
    viajeId?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type PagoChoferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PagoChofer to aggregate.
     */
    where?: PagoChoferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagoChofers to fetch.
     */
    orderBy?: PagoChoferOrderByWithRelationInput | PagoChoferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagoChoferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagoChofers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagoChofers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PagoChofers
    **/
    _count?: true | PagoChoferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagoChoferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagoChoferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagoChoferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagoChoferMaxAggregateInputType
  }

  export type GetPagoChoferAggregateType<T extends PagoChoferAggregateArgs> = {
        [P in keyof T & keyof AggregatePagoChofer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagoChofer[P]>
      : GetScalarType<T[P], AggregatePagoChofer[P]>
  }




  export type PagoChoferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoChoferWhereInput
    orderBy?: PagoChoferOrderByWithAggregationInput | PagoChoferOrderByWithAggregationInput[]
    by: PagoChoferScalarFieldEnum[] | PagoChoferScalarFieldEnum
    having?: PagoChoferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagoChoferCountAggregateInputType | true
    _avg?: PagoChoferAvgAggregateInputType
    _sum?: PagoChoferSumAggregateInputType
    _min?: PagoChoferMinAggregateInputType
    _max?: PagoChoferMaxAggregateInputType
  }

  export type PagoChoferGroupByOutputType = {
    id: number
    choferId: number
    monto: Decimal
    fecha: Date
    metodoPago: $Enums.MetodoPago
    descripcion: string | null
    estado: $Enums.EstadoPagoChofer
    fechaPagoReal: Date | null
    comprobanteId: number | null
    viajeId: number | null
    creadoEn: Date
    actualizadoEn: Date
    _count: PagoChoferCountAggregateOutputType | null
    _avg: PagoChoferAvgAggregateOutputType | null
    _sum: PagoChoferSumAggregateOutputType | null
    _min: PagoChoferMinAggregateOutputType | null
    _max: PagoChoferMaxAggregateOutputType | null
  }

  type GetPagoChoferGroupByPayload<T extends PagoChoferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagoChoferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagoChoferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagoChoferGroupByOutputType[P]>
            : GetScalarType<T[P], PagoChoferGroupByOutputType[P]>
        }
      >
    >


  export type PagoChoferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    choferId?: boolean
    monto?: boolean
    fecha?: boolean
    metodoPago?: boolean
    descripcion?: boolean
    estado?: boolean
    fechaPagoReal?: boolean
    comprobanteId?: boolean
    viajeId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    chofer?: boolean | ChoferDefaultArgs<ExtArgs>
    comprobante?: boolean | PagoChofer$comprobanteArgs<ExtArgs>
    viaje?: boolean | PagoChofer$viajeArgs<ExtArgs>
  }, ExtArgs["result"]["pagoChofer"]>

  export type PagoChoferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    choferId?: boolean
    monto?: boolean
    fecha?: boolean
    metodoPago?: boolean
    descripcion?: boolean
    estado?: boolean
    fechaPagoReal?: boolean
    comprobanteId?: boolean
    viajeId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    chofer?: boolean | ChoferDefaultArgs<ExtArgs>
    comprobante?: boolean | PagoChofer$comprobanteArgs<ExtArgs>
    viaje?: boolean | PagoChofer$viajeArgs<ExtArgs>
  }, ExtArgs["result"]["pagoChofer"]>

  export type PagoChoferSelectScalar = {
    id?: boolean
    choferId?: boolean
    monto?: boolean
    fecha?: boolean
    metodoPago?: boolean
    descripcion?: boolean
    estado?: boolean
    fechaPagoReal?: boolean
    comprobanteId?: boolean
    viajeId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type PagoChoferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chofer?: boolean | ChoferDefaultArgs<ExtArgs>
    comprobante?: boolean | PagoChofer$comprobanteArgs<ExtArgs>
    viaje?: boolean | PagoChofer$viajeArgs<ExtArgs>
  }
  export type PagoChoferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chofer?: boolean | ChoferDefaultArgs<ExtArgs>
    comprobante?: boolean | PagoChofer$comprobanteArgs<ExtArgs>
    viaje?: boolean | PagoChofer$viajeArgs<ExtArgs>
  }

  export type $PagoChoferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PagoChofer"
    objects: {
      chofer: Prisma.$ChoferPayload<ExtArgs>
      comprobante: Prisma.$ComprobantePayload<ExtArgs> | null
      viaje: Prisma.$ViajePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      choferId: number
      monto: Prisma.Decimal
      fecha: Date
      metodoPago: $Enums.MetodoPago
      descripcion: string | null
      estado: $Enums.EstadoPagoChofer
      fechaPagoReal: Date | null
      comprobanteId: number | null
      viajeId: number | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["pagoChofer"]>
    composites: {}
  }

  type PagoChoferGetPayload<S extends boolean | null | undefined | PagoChoferDefaultArgs> = $Result.GetResult<Prisma.$PagoChoferPayload, S>

  type PagoChoferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PagoChoferFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PagoChoferCountAggregateInputType | true
    }

  export interface PagoChoferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PagoChofer'], meta: { name: 'PagoChofer' } }
    /**
     * Find zero or one PagoChofer that matches the filter.
     * @param {PagoChoferFindUniqueArgs} args - Arguments to find a PagoChofer
     * @example
     * // Get one PagoChofer
     * const pagoChofer = await prisma.pagoChofer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagoChoferFindUniqueArgs>(args: SelectSubset<T, PagoChoferFindUniqueArgs<ExtArgs>>): Prisma__PagoChoferClient<$Result.GetResult<Prisma.$PagoChoferPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PagoChofer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PagoChoferFindUniqueOrThrowArgs} args - Arguments to find a PagoChofer
     * @example
     * // Get one PagoChofer
     * const pagoChofer = await prisma.pagoChofer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagoChoferFindUniqueOrThrowArgs>(args: SelectSubset<T, PagoChoferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PagoChoferClient<$Result.GetResult<Prisma.$PagoChoferPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PagoChofer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoChoferFindFirstArgs} args - Arguments to find a PagoChofer
     * @example
     * // Get one PagoChofer
     * const pagoChofer = await prisma.pagoChofer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagoChoferFindFirstArgs>(args?: SelectSubset<T, PagoChoferFindFirstArgs<ExtArgs>>): Prisma__PagoChoferClient<$Result.GetResult<Prisma.$PagoChoferPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PagoChofer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoChoferFindFirstOrThrowArgs} args - Arguments to find a PagoChofer
     * @example
     * // Get one PagoChofer
     * const pagoChofer = await prisma.pagoChofer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagoChoferFindFirstOrThrowArgs>(args?: SelectSubset<T, PagoChoferFindFirstOrThrowArgs<ExtArgs>>): Prisma__PagoChoferClient<$Result.GetResult<Prisma.$PagoChoferPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PagoChofers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoChoferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PagoChofers
     * const pagoChofers = await prisma.pagoChofer.findMany()
     * 
     * // Get first 10 PagoChofers
     * const pagoChofers = await prisma.pagoChofer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagoChoferWithIdOnly = await prisma.pagoChofer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PagoChoferFindManyArgs>(args?: SelectSubset<T, PagoChoferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoChoferPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PagoChofer.
     * @param {PagoChoferCreateArgs} args - Arguments to create a PagoChofer.
     * @example
     * // Create one PagoChofer
     * const PagoChofer = await prisma.pagoChofer.create({
     *   data: {
     *     // ... data to create a PagoChofer
     *   }
     * })
     * 
     */
    create<T extends PagoChoferCreateArgs>(args: SelectSubset<T, PagoChoferCreateArgs<ExtArgs>>): Prisma__PagoChoferClient<$Result.GetResult<Prisma.$PagoChoferPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PagoChofers.
     * @param {PagoChoferCreateManyArgs} args - Arguments to create many PagoChofers.
     * @example
     * // Create many PagoChofers
     * const pagoChofer = await prisma.pagoChofer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PagoChoferCreateManyArgs>(args?: SelectSubset<T, PagoChoferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PagoChofers and returns the data saved in the database.
     * @param {PagoChoferCreateManyAndReturnArgs} args - Arguments to create many PagoChofers.
     * @example
     * // Create many PagoChofers
     * const pagoChofer = await prisma.pagoChofer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PagoChofers and only return the `id`
     * const pagoChoferWithIdOnly = await prisma.pagoChofer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PagoChoferCreateManyAndReturnArgs>(args?: SelectSubset<T, PagoChoferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoChoferPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PagoChofer.
     * @param {PagoChoferDeleteArgs} args - Arguments to delete one PagoChofer.
     * @example
     * // Delete one PagoChofer
     * const PagoChofer = await prisma.pagoChofer.delete({
     *   where: {
     *     // ... filter to delete one PagoChofer
     *   }
     * })
     * 
     */
    delete<T extends PagoChoferDeleteArgs>(args: SelectSubset<T, PagoChoferDeleteArgs<ExtArgs>>): Prisma__PagoChoferClient<$Result.GetResult<Prisma.$PagoChoferPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PagoChofer.
     * @param {PagoChoferUpdateArgs} args - Arguments to update one PagoChofer.
     * @example
     * // Update one PagoChofer
     * const pagoChofer = await prisma.pagoChofer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PagoChoferUpdateArgs>(args: SelectSubset<T, PagoChoferUpdateArgs<ExtArgs>>): Prisma__PagoChoferClient<$Result.GetResult<Prisma.$PagoChoferPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PagoChofers.
     * @param {PagoChoferDeleteManyArgs} args - Arguments to filter PagoChofers to delete.
     * @example
     * // Delete a few PagoChofers
     * const { count } = await prisma.pagoChofer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PagoChoferDeleteManyArgs>(args?: SelectSubset<T, PagoChoferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PagoChofers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoChoferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PagoChofers
     * const pagoChofer = await prisma.pagoChofer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PagoChoferUpdateManyArgs>(args: SelectSubset<T, PagoChoferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PagoChofer.
     * @param {PagoChoferUpsertArgs} args - Arguments to update or create a PagoChofer.
     * @example
     * // Update or create a PagoChofer
     * const pagoChofer = await prisma.pagoChofer.upsert({
     *   create: {
     *     // ... data to create a PagoChofer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PagoChofer we want to update
     *   }
     * })
     */
    upsert<T extends PagoChoferUpsertArgs>(args: SelectSubset<T, PagoChoferUpsertArgs<ExtArgs>>): Prisma__PagoChoferClient<$Result.GetResult<Prisma.$PagoChoferPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PagoChofers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoChoferCountArgs} args - Arguments to filter PagoChofers to count.
     * @example
     * // Count the number of PagoChofers
     * const count = await prisma.pagoChofer.count({
     *   where: {
     *     // ... the filter for the PagoChofers we want to count
     *   }
     * })
    **/
    count<T extends PagoChoferCountArgs>(
      args?: Subset<T, PagoChoferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagoChoferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PagoChofer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoChoferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagoChoferAggregateArgs>(args: Subset<T, PagoChoferAggregateArgs>): Prisma.PrismaPromise<GetPagoChoferAggregateType<T>>

    /**
     * Group by PagoChofer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoChoferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagoChoferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagoChoferGroupByArgs['orderBy'] }
        : { orderBy?: PagoChoferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagoChoferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagoChoferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PagoChofer model
   */
  readonly fields: PagoChoferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PagoChofer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagoChoferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chofer<T extends ChoferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChoferDefaultArgs<ExtArgs>>): Prisma__ChoferClient<$Result.GetResult<Prisma.$ChoferPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comprobante<T extends PagoChofer$comprobanteArgs<ExtArgs> = {}>(args?: Subset<T, PagoChofer$comprobanteArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    viaje<T extends PagoChofer$viajeArgs<ExtArgs> = {}>(args?: Subset<T, PagoChofer$viajeArgs<ExtArgs>>): Prisma__ViajeClient<$Result.GetResult<Prisma.$ViajePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PagoChofer model
   */ 
  interface PagoChoferFieldRefs {
    readonly id: FieldRef<"PagoChofer", 'Int'>
    readonly choferId: FieldRef<"PagoChofer", 'Int'>
    readonly monto: FieldRef<"PagoChofer", 'Decimal'>
    readonly fecha: FieldRef<"PagoChofer", 'DateTime'>
    readonly metodoPago: FieldRef<"PagoChofer", 'MetodoPago'>
    readonly descripcion: FieldRef<"PagoChofer", 'String'>
    readonly estado: FieldRef<"PagoChofer", 'EstadoPagoChofer'>
    readonly fechaPagoReal: FieldRef<"PagoChofer", 'DateTime'>
    readonly comprobanteId: FieldRef<"PagoChofer", 'Int'>
    readonly viajeId: FieldRef<"PagoChofer", 'Int'>
    readonly creadoEn: FieldRef<"PagoChofer", 'DateTime'>
    readonly actualizadoEn: FieldRef<"PagoChofer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PagoChofer findUnique
   */
  export type PagoChoferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoChofer
     */
    select?: PagoChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoChoferInclude<ExtArgs> | null
    /**
     * Filter, which PagoChofer to fetch.
     */
    where: PagoChoferWhereUniqueInput
  }

  /**
   * PagoChofer findUniqueOrThrow
   */
  export type PagoChoferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoChofer
     */
    select?: PagoChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoChoferInclude<ExtArgs> | null
    /**
     * Filter, which PagoChofer to fetch.
     */
    where: PagoChoferWhereUniqueInput
  }

  /**
   * PagoChofer findFirst
   */
  export type PagoChoferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoChofer
     */
    select?: PagoChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoChoferInclude<ExtArgs> | null
    /**
     * Filter, which PagoChofer to fetch.
     */
    where?: PagoChoferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagoChofers to fetch.
     */
    orderBy?: PagoChoferOrderByWithRelationInput | PagoChoferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PagoChofers.
     */
    cursor?: PagoChoferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagoChofers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagoChofers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PagoChofers.
     */
    distinct?: PagoChoferScalarFieldEnum | PagoChoferScalarFieldEnum[]
  }

  /**
   * PagoChofer findFirstOrThrow
   */
  export type PagoChoferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoChofer
     */
    select?: PagoChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoChoferInclude<ExtArgs> | null
    /**
     * Filter, which PagoChofer to fetch.
     */
    where?: PagoChoferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagoChofers to fetch.
     */
    orderBy?: PagoChoferOrderByWithRelationInput | PagoChoferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PagoChofers.
     */
    cursor?: PagoChoferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagoChofers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagoChofers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PagoChofers.
     */
    distinct?: PagoChoferScalarFieldEnum | PagoChoferScalarFieldEnum[]
  }

  /**
   * PagoChofer findMany
   */
  export type PagoChoferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoChofer
     */
    select?: PagoChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoChoferInclude<ExtArgs> | null
    /**
     * Filter, which PagoChofers to fetch.
     */
    where?: PagoChoferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagoChofers to fetch.
     */
    orderBy?: PagoChoferOrderByWithRelationInput | PagoChoferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PagoChofers.
     */
    cursor?: PagoChoferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagoChofers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagoChofers.
     */
    skip?: number
    distinct?: PagoChoferScalarFieldEnum | PagoChoferScalarFieldEnum[]
  }

  /**
   * PagoChofer create
   */
  export type PagoChoferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoChofer
     */
    select?: PagoChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoChoferInclude<ExtArgs> | null
    /**
     * The data needed to create a PagoChofer.
     */
    data: XOR<PagoChoferCreateInput, PagoChoferUncheckedCreateInput>
  }

  /**
   * PagoChofer createMany
   */
  export type PagoChoferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PagoChofers.
     */
    data: PagoChoferCreateManyInput | PagoChoferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PagoChofer createManyAndReturn
   */
  export type PagoChoferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoChofer
     */
    select?: PagoChoferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PagoChofers.
     */
    data: PagoChoferCreateManyInput | PagoChoferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoChoferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PagoChofer update
   */
  export type PagoChoferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoChofer
     */
    select?: PagoChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoChoferInclude<ExtArgs> | null
    /**
     * The data needed to update a PagoChofer.
     */
    data: XOR<PagoChoferUpdateInput, PagoChoferUncheckedUpdateInput>
    /**
     * Choose, which PagoChofer to update.
     */
    where: PagoChoferWhereUniqueInput
  }

  /**
   * PagoChofer updateMany
   */
  export type PagoChoferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PagoChofers.
     */
    data: XOR<PagoChoferUpdateManyMutationInput, PagoChoferUncheckedUpdateManyInput>
    /**
     * Filter which PagoChofers to update
     */
    where?: PagoChoferWhereInput
  }

  /**
   * PagoChofer upsert
   */
  export type PagoChoferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoChofer
     */
    select?: PagoChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoChoferInclude<ExtArgs> | null
    /**
     * The filter to search for the PagoChofer to update in case it exists.
     */
    where: PagoChoferWhereUniqueInput
    /**
     * In case the PagoChofer found by the `where` argument doesn't exist, create a new PagoChofer with this data.
     */
    create: XOR<PagoChoferCreateInput, PagoChoferUncheckedCreateInput>
    /**
     * In case the PagoChofer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagoChoferUpdateInput, PagoChoferUncheckedUpdateInput>
  }

  /**
   * PagoChofer delete
   */
  export type PagoChoferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoChofer
     */
    select?: PagoChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoChoferInclude<ExtArgs> | null
    /**
     * Filter which PagoChofer to delete.
     */
    where: PagoChoferWhereUniqueInput
  }

  /**
   * PagoChofer deleteMany
   */
  export type PagoChoferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PagoChofers to delete
     */
    where?: PagoChoferWhereInput
  }

  /**
   * PagoChofer.comprobante
   */
  export type PagoChofer$comprobanteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    where?: ComprobanteWhereInput
  }

  /**
   * PagoChofer.viaje
   */
  export type PagoChofer$viajeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viaje
     */
    select?: ViajeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViajeInclude<ExtArgs> | null
    where?: ViajeWhereInput
  }

  /**
   * PagoChofer without action
   */
  export type PagoChoferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoChofer
     */
    select?: PagoChoferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoChoferInclude<ExtArgs> | null
  }


  /**
   * Model RegistroAuditoria
   */

  export type AggregateRegistroAuditoria = {
    _count: RegistroAuditoriaCountAggregateOutputType | null
    _avg: RegistroAuditoriaAvgAggregateOutputType | null
    _sum: RegistroAuditoriaSumAggregateOutputType | null
    _min: RegistroAuditoriaMinAggregateOutputType | null
    _max: RegistroAuditoriaMaxAggregateOutputType | null
  }

  export type RegistroAuditoriaAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    entidadId: number | null
  }

  export type RegistroAuditoriaSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    entidadId: number | null
  }

  export type RegistroAuditoriaMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    accion: $Enums.AccionAuditoria | null
    entidad: string | null
    entidadId: number | null
    fechaHora: Date | null
    ipAddress: string | null
  }

  export type RegistroAuditoriaMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    accion: $Enums.AccionAuditoria | null
    entidad: string | null
    entidadId: number | null
    fechaHora: Date | null
    ipAddress: string | null
  }

  export type RegistroAuditoriaCountAggregateOutputType = {
    id: number
    usuarioId: number
    accion: number
    entidad: number
    entidadId: number
    datosAnteriores: number
    datosNuevos: number
    fechaHora: number
    ipAddress: number
    _all: number
  }


  export type RegistroAuditoriaAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    entidadId?: true
  }

  export type RegistroAuditoriaSumAggregateInputType = {
    id?: true
    usuarioId?: true
    entidadId?: true
  }

  export type RegistroAuditoriaMinAggregateInputType = {
    id?: true
    usuarioId?: true
    accion?: true
    entidad?: true
    entidadId?: true
    fechaHora?: true
    ipAddress?: true
  }

  export type RegistroAuditoriaMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    accion?: true
    entidad?: true
    entidadId?: true
    fechaHora?: true
    ipAddress?: true
  }

  export type RegistroAuditoriaCountAggregateInputType = {
    id?: true
    usuarioId?: true
    accion?: true
    entidad?: true
    entidadId?: true
    datosAnteriores?: true
    datosNuevos?: true
    fechaHora?: true
    ipAddress?: true
    _all?: true
  }

  export type RegistroAuditoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegistroAuditoria to aggregate.
     */
    where?: RegistroAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroAuditorias to fetch.
     */
    orderBy?: RegistroAuditoriaOrderByWithRelationInput | RegistroAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegistroAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroAuditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegistroAuditorias
    **/
    _count?: true | RegistroAuditoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegistroAuditoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegistroAuditoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegistroAuditoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegistroAuditoriaMaxAggregateInputType
  }

  export type GetRegistroAuditoriaAggregateType<T extends RegistroAuditoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateRegistroAuditoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegistroAuditoria[P]>
      : GetScalarType<T[P], AggregateRegistroAuditoria[P]>
  }




  export type RegistroAuditoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegistroAuditoriaWhereInput
    orderBy?: RegistroAuditoriaOrderByWithAggregationInput | RegistroAuditoriaOrderByWithAggregationInput[]
    by: RegistroAuditoriaScalarFieldEnum[] | RegistroAuditoriaScalarFieldEnum
    having?: RegistroAuditoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegistroAuditoriaCountAggregateInputType | true
    _avg?: RegistroAuditoriaAvgAggregateInputType
    _sum?: RegistroAuditoriaSumAggregateInputType
    _min?: RegistroAuditoriaMinAggregateInputType
    _max?: RegistroAuditoriaMaxAggregateInputType
  }

  export type RegistroAuditoriaGroupByOutputType = {
    id: number
    usuarioId: number
    accion: $Enums.AccionAuditoria
    entidad: string
    entidadId: number
    datosAnteriores: JsonValue | null
    datosNuevos: JsonValue | null
    fechaHora: Date
    ipAddress: string | null
    _count: RegistroAuditoriaCountAggregateOutputType | null
    _avg: RegistroAuditoriaAvgAggregateOutputType | null
    _sum: RegistroAuditoriaSumAggregateOutputType | null
    _min: RegistroAuditoriaMinAggregateOutputType | null
    _max: RegistroAuditoriaMaxAggregateOutputType | null
  }

  type GetRegistroAuditoriaGroupByPayload<T extends RegistroAuditoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegistroAuditoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegistroAuditoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegistroAuditoriaGroupByOutputType[P]>
            : GetScalarType<T[P], RegistroAuditoriaGroupByOutputType[P]>
        }
      >
    >


  export type RegistroAuditoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    datosAnteriores?: boolean
    datosNuevos?: boolean
    fechaHora?: boolean
    ipAddress?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registroAuditoria"]>

  export type RegistroAuditoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    datosAnteriores?: boolean
    datosNuevos?: boolean
    fechaHora?: boolean
    ipAddress?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registroAuditoria"]>

  export type RegistroAuditoriaSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    datosAnteriores?: boolean
    datosNuevos?: boolean
    fechaHora?: boolean
    ipAddress?: boolean
  }

  export type RegistroAuditoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type RegistroAuditoriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $RegistroAuditoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegistroAuditoria"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      accion: $Enums.AccionAuditoria
      entidad: string
      entidadId: number
      datosAnteriores: Prisma.JsonValue | null
      datosNuevos: Prisma.JsonValue | null
      fechaHora: Date
      ipAddress: string | null
    }, ExtArgs["result"]["registroAuditoria"]>
    composites: {}
  }

  type RegistroAuditoriaGetPayload<S extends boolean | null | undefined | RegistroAuditoriaDefaultArgs> = $Result.GetResult<Prisma.$RegistroAuditoriaPayload, S>

  type RegistroAuditoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RegistroAuditoriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RegistroAuditoriaCountAggregateInputType | true
    }

  export interface RegistroAuditoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegistroAuditoria'], meta: { name: 'RegistroAuditoria' } }
    /**
     * Find zero or one RegistroAuditoria that matches the filter.
     * @param {RegistroAuditoriaFindUniqueArgs} args - Arguments to find a RegistroAuditoria
     * @example
     * // Get one RegistroAuditoria
     * const registroAuditoria = await prisma.registroAuditoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegistroAuditoriaFindUniqueArgs>(args: SelectSubset<T, RegistroAuditoriaFindUniqueArgs<ExtArgs>>): Prisma__RegistroAuditoriaClient<$Result.GetResult<Prisma.$RegistroAuditoriaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RegistroAuditoria that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RegistroAuditoriaFindUniqueOrThrowArgs} args - Arguments to find a RegistroAuditoria
     * @example
     * // Get one RegistroAuditoria
     * const registroAuditoria = await prisma.registroAuditoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegistroAuditoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, RegistroAuditoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegistroAuditoriaClient<$Result.GetResult<Prisma.$RegistroAuditoriaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RegistroAuditoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroAuditoriaFindFirstArgs} args - Arguments to find a RegistroAuditoria
     * @example
     * // Get one RegistroAuditoria
     * const registroAuditoria = await prisma.registroAuditoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegistroAuditoriaFindFirstArgs>(args?: SelectSubset<T, RegistroAuditoriaFindFirstArgs<ExtArgs>>): Prisma__RegistroAuditoriaClient<$Result.GetResult<Prisma.$RegistroAuditoriaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RegistroAuditoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroAuditoriaFindFirstOrThrowArgs} args - Arguments to find a RegistroAuditoria
     * @example
     * // Get one RegistroAuditoria
     * const registroAuditoria = await prisma.registroAuditoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegistroAuditoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, RegistroAuditoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegistroAuditoriaClient<$Result.GetResult<Prisma.$RegistroAuditoriaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RegistroAuditorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroAuditoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegistroAuditorias
     * const registroAuditorias = await prisma.registroAuditoria.findMany()
     * 
     * // Get first 10 RegistroAuditorias
     * const registroAuditorias = await prisma.registroAuditoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const registroAuditoriaWithIdOnly = await prisma.registroAuditoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegistroAuditoriaFindManyArgs>(args?: SelectSubset<T, RegistroAuditoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistroAuditoriaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RegistroAuditoria.
     * @param {RegistroAuditoriaCreateArgs} args - Arguments to create a RegistroAuditoria.
     * @example
     * // Create one RegistroAuditoria
     * const RegistroAuditoria = await prisma.registroAuditoria.create({
     *   data: {
     *     // ... data to create a RegistroAuditoria
     *   }
     * })
     * 
     */
    create<T extends RegistroAuditoriaCreateArgs>(args: SelectSubset<T, RegistroAuditoriaCreateArgs<ExtArgs>>): Prisma__RegistroAuditoriaClient<$Result.GetResult<Prisma.$RegistroAuditoriaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RegistroAuditorias.
     * @param {RegistroAuditoriaCreateManyArgs} args - Arguments to create many RegistroAuditorias.
     * @example
     * // Create many RegistroAuditorias
     * const registroAuditoria = await prisma.registroAuditoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegistroAuditoriaCreateManyArgs>(args?: SelectSubset<T, RegistroAuditoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RegistroAuditorias and returns the data saved in the database.
     * @param {RegistroAuditoriaCreateManyAndReturnArgs} args - Arguments to create many RegistroAuditorias.
     * @example
     * // Create many RegistroAuditorias
     * const registroAuditoria = await prisma.registroAuditoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RegistroAuditorias and only return the `id`
     * const registroAuditoriaWithIdOnly = await prisma.registroAuditoria.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegistroAuditoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, RegistroAuditoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistroAuditoriaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RegistroAuditoria.
     * @param {RegistroAuditoriaDeleteArgs} args - Arguments to delete one RegistroAuditoria.
     * @example
     * // Delete one RegistroAuditoria
     * const RegistroAuditoria = await prisma.registroAuditoria.delete({
     *   where: {
     *     // ... filter to delete one RegistroAuditoria
     *   }
     * })
     * 
     */
    delete<T extends RegistroAuditoriaDeleteArgs>(args: SelectSubset<T, RegistroAuditoriaDeleteArgs<ExtArgs>>): Prisma__RegistroAuditoriaClient<$Result.GetResult<Prisma.$RegistroAuditoriaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RegistroAuditoria.
     * @param {RegistroAuditoriaUpdateArgs} args - Arguments to update one RegistroAuditoria.
     * @example
     * // Update one RegistroAuditoria
     * const registroAuditoria = await prisma.registroAuditoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegistroAuditoriaUpdateArgs>(args: SelectSubset<T, RegistroAuditoriaUpdateArgs<ExtArgs>>): Prisma__RegistroAuditoriaClient<$Result.GetResult<Prisma.$RegistroAuditoriaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RegistroAuditorias.
     * @param {RegistroAuditoriaDeleteManyArgs} args - Arguments to filter RegistroAuditorias to delete.
     * @example
     * // Delete a few RegistroAuditorias
     * const { count } = await prisma.registroAuditoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegistroAuditoriaDeleteManyArgs>(args?: SelectSubset<T, RegistroAuditoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegistroAuditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroAuditoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegistroAuditorias
     * const registroAuditoria = await prisma.registroAuditoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegistroAuditoriaUpdateManyArgs>(args: SelectSubset<T, RegistroAuditoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RegistroAuditoria.
     * @param {RegistroAuditoriaUpsertArgs} args - Arguments to update or create a RegistroAuditoria.
     * @example
     * // Update or create a RegistroAuditoria
     * const registroAuditoria = await prisma.registroAuditoria.upsert({
     *   create: {
     *     // ... data to create a RegistroAuditoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegistroAuditoria we want to update
     *   }
     * })
     */
    upsert<T extends RegistroAuditoriaUpsertArgs>(args: SelectSubset<T, RegistroAuditoriaUpsertArgs<ExtArgs>>): Prisma__RegistroAuditoriaClient<$Result.GetResult<Prisma.$RegistroAuditoriaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RegistroAuditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroAuditoriaCountArgs} args - Arguments to filter RegistroAuditorias to count.
     * @example
     * // Count the number of RegistroAuditorias
     * const count = await prisma.registroAuditoria.count({
     *   where: {
     *     // ... the filter for the RegistroAuditorias we want to count
     *   }
     * })
    **/
    count<T extends RegistroAuditoriaCountArgs>(
      args?: Subset<T, RegistroAuditoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegistroAuditoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegistroAuditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroAuditoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegistroAuditoriaAggregateArgs>(args: Subset<T, RegistroAuditoriaAggregateArgs>): Prisma.PrismaPromise<GetRegistroAuditoriaAggregateType<T>>

    /**
     * Group by RegistroAuditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroAuditoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegistroAuditoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegistroAuditoriaGroupByArgs['orderBy'] }
        : { orderBy?: RegistroAuditoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegistroAuditoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegistroAuditoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegistroAuditoria model
   */
  readonly fields: RegistroAuditoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegistroAuditoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegistroAuditoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegistroAuditoria model
   */ 
  interface RegistroAuditoriaFieldRefs {
    readonly id: FieldRef<"RegistroAuditoria", 'Int'>
    readonly usuarioId: FieldRef<"RegistroAuditoria", 'Int'>
    readonly accion: FieldRef<"RegistroAuditoria", 'AccionAuditoria'>
    readonly entidad: FieldRef<"RegistroAuditoria", 'String'>
    readonly entidadId: FieldRef<"RegistroAuditoria", 'Int'>
    readonly datosAnteriores: FieldRef<"RegistroAuditoria", 'Json'>
    readonly datosNuevos: FieldRef<"RegistroAuditoria", 'Json'>
    readonly fechaHora: FieldRef<"RegistroAuditoria", 'DateTime'>
    readonly ipAddress: FieldRef<"RegistroAuditoria", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RegistroAuditoria findUnique
   */
  export type RegistroAuditoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAuditoria
     */
    select?: RegistroAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which RegistroAuditoria to fetch.
     */
    where: RegistroAuditoriaWhereUniqueInput
  }

  /**
   * RegistroAuditoria findUniqueOrThrow
   */
  export type RegistroAuditoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAuditoria
     */
    select?: RegistroAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which RegistroAuditoria to fetch.
     */
    where: RegistroAuditoriaWhereUniqueInput
  }

  /**
   * RegistroAuditoria findFirst
   */
  export type RegistroAuditoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAuditoria
     */
    select?: RegistroAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which RegistroAuditoria to fetch.
     */
    where?: RegistroAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroAuditorias to fetch.
     */
    orderBy?: RegistroAuditoriaOrderByWithRelationInput | RegistroAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegistroAuditorias.
     */
    cursor?: RegistroAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroAuditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegistroAuditorias.
     */
    distinct?: RegistroAuditoriaScalarFieldEnum | RegistroAuditoriaScalarFieldEnum[]
  }

  /**
   * RegistroAuditoria findFirstOrThrow
   */
  export type RegistroAuditoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAuditoria
     */
    select?: RegistroAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which RegistroAuditoria to fetch.
     */
    where?: RegistroAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroAuditorias to fetch.
     */
    orderBy?: RegistroAuditoriaOrderByWithRelationInput | RegistroAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegistroAuditorias.
     */
    cursor?: RegistroAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroAuditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegistroAuditorias.
     */
    distinct?: RegistroAuditoriaScalarFieldEnum | RegistroAuditoriaScalarFieldEnum[]
  }

  /**
   * RegistroAuditoria findMany
   */
  export type RegistroAuditoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAuditoria
     */
    select?: RegistroAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which RegistroAuditorias to fetch.
     */
    where?: RegistroAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroAuditorias to fetch.
     */
    orderBy?: RegistroAuditoriaOrderByWithRelationInput | RegistroAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegistroAuditorias.
     */
    cursor?: RegistroAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroAuditorias.
     */
    skip?: number
    distinct?: RegistroAuditoriaScalarFieldEnum | RegistroAuditoriaScalarFieldEnum[]
  }

  /**
   * RegistroAuditoria create
   */
  export type RegistroAuditoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAuditoria
     */
    select?: RegistroAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAuditoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a RegistroAuditoria.
     */
    data: XOR<RegistroAuditoriaCreateInput, RegistroAuditoriaUncheckedCreateInput>
  }

  /**
   * RegistroAuditoria createMany
   */
  export type RegistroAuditoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegistroAuditorias.
     */
    data: RegistroAuditoriaCreateManyInput | RegistroAuditoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegistroAuditoria createManyAndReturn
   */
  export type RegistroAuditoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAuditoria
     */
    select?: RegistroAuditoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RegistroAuditorias.
     */
    data: RegistroAuditoriaCreateManyInput | RegistroAuditoriaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAuditoriaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RegistroAuditoria update
   */
  export type RegistroAuditoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAuditoria
     */
    select?: RegistroAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAuditoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a RegistroAuditoria.
     */
    data: XOR<RegistroAuditoriaUpdateInput, RegistroAuditoriaUncheckedUpdateInput>
    /**
     * Choose, which RegistroAuditoria to update.
     */
    where: RegistroAuditoriaWhereUniqueInput
  }

  /**
   * RegistroAuditoria updateMany
   */
  export type RegistroAuditoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegistroAuditorias.
     */
    data: XOR<RegistroAuditoriaUpdateManyMutationInput, RegistroAuditoriaUncheckedUpdateManyInput>
    /**
     * Filter which RegistroAuditorias to update
     */
    where?: RegistroAuditoriaWhereInput
  }

  /**
   * RegistroAuditoria upsert
   */
  export type RegistroAuditoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAuditoria
     */
    select?: RegistroAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAuditoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the RegistroAuditoria to update in case it exists.
     */
    where: RegistroAuditoriaWhereUniqueInput
    /**
     * In case the RegistroAuditoria found by the `where` argument doesn't exist, create a new RegistroAuditoria with this data.
     */
    create: XOR<RegistroAuditoriaCreateInput, RegistroAuditoriaUncheckedCreateInput>
    /**
     * In case the RegistroAuditoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegistroAuditoriaUpdateInput, RegistroAuditoriaUncheckedUpdateInput>
  }

  /**
   * RegistroAuditoria delete
   */
  export type RegistroAuditoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAuditoria
     */
    select?: RegistroAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAuditoriaInclude<ExtArgs> | null
    /**
     * Filter which RegistroAuditoria to delete.
     */
    where: RegistroAuditoriaWhereUniqueInput
  }

  /**
   * RegistroAuditoria deleteMany
   */
  export type RegistroAuditoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegistroAuditorias to delete
     */
    where?: RegistroAuditoriaWhereInput
  }

  /**
   * RegistroAuditoria without action
   */
  export type RegistroAuditoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAuditoria
     */
    select?: RegistroAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAuditoriaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombreUsuario: 'nombreUsuario',
    email: 'email',
    passwordHash: 'passwordHash',
    nombreCompleto: 'nombreCompleto',
    rol: 'rol',
    activo: 'activo',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    deletedAt: 'deletedAt'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const VehiculoScalarFieldEnum: {
    id: 'id',
    placa: 'placa',
    marca: 'marca',
    modelo: 'modelo',
    anio: 'anio',
    tipo: 'tipo',
    capacidad: 'capacidad',
    estado: 'estado',
    kilometrajeActual: 'kilometrajeActual',
    fechaUltimoMantenimiento: 'fechaUltimoMantenimiento',
    fechaProximoMantenimiento: 'fechaProximoMantenimiento',
    fechaVencimientoSoat: 'fechaVencimientoSoat',
    fechaVencimientoSeguro: 'fechaVencimientoSeguro',
    fechaVencimientoMatricula: 'fechaVencimientoMatricula',
    observaciones: 'observaciones',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    deletedAt: 'deletedAt'
  };

  export type VehiculoScalarFieldEnum = (typeof VehiculoScalarFieldEnum)[keyof typeof VehiculoScalarFieldEnum]


  export const ChoferScalarFieldEnum: {
    id: 'id',
    nombres: 'nombres',
    apellidos: 'apellidos',
    documentoId: 'documentoId',
    telefono: 'telefono',
    fechaVencimientoLicencia: 'fechaVencimientoLicencia',
    correo: 'correo',
    estado: 'estado',
    modalidadPago: 'modalidadPago',
    metodoPago: 'metodoPago',
    banco: 'banco',
    numeroCuenta: 'numeroCuenta',
    sueldoMensual: 'sueldoMensual',
    fechaContratacion: 'fechaContratacion',
    diaPago: 'diaPago',
    pagoQuincenal: 'pagoQuincenal',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    deletedAt: 'deletedAt'
  };

  export type ChoferScalarFieldEnum = (typeof ChoferScalarFieldEnum)[keyof typeof ChoferScalarFieldEnum]


  export const ClienteScalarFieldEnum: {
    id: 'id',
    nombreRazonSocial: 'nombreRazonSocial',
    documentoId: 'documentoId',
    telefono: 'telefono',
    correo: 'correo',
    direccion: 'direccion',
    sector: 'sector',
    estado: 'estado',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    deletedAt: 'deletedAt'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    unidadMedida: 'unidadMedida',
    esPeligroso: 'esPeligroso',
    descripcion: 'descripcion',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const ViajeScalarFieldEnum: {
    id: 'id',
    vehiculoId: 'vehiculoId',
    choferId: 'choferId',
    clienteId: 'clienteId',
    materialId: 'materialId',
    origen: 'origen',
    destino: 'destino',
    fechaSalida: 'fechaSalida',
    fechaLlegadaEstimada: 'fechaLlegadaEstimada',
    fechaLlegadaReal: 'fechaLlegadaReal',
    kilometrosEstimados: 'kilometrosEstimados',
    kilometrosReales: 'kilometrosReales',
    tarifa: 'tarifa',
    estadoPagoCliente: 'estadoPagoCliente',
    montoPagadoCliente: 'montoPagadoCliente',
    fechaLimitePago: 'fechaLimitePago',
    diasCredito: 'diasCredito',
    montoPagoChofer: 'montoPagoChofer',
    estado: 'estado',
    observaciones: 'observaciones',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type ViajeScalarFieldEnum = (typeof ViajeScalarFieldEnum)[keyof typeof ViajeScalarFieldEnum]


  export const GastoViajeScalarFieldEnum: {
    id: 'id',
    viajeId: 'viajeId',
    tipoGasto: 'tipoGasto',
    monto: 'monto',
    fecha: 'fecha',
    metodoPago: 'metodoPago',
    descripcion: 'descripcion',
    comprobanteId: 'comprobanteId',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type GastoViajeScalarFieldEnum = (typeof GastoViajeScalarFieldEnum)[keyof typeof GastoViajeScalarFieldEnum]


  export const ComprobanteScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    referenciaId: 'referenciaId',
    url: 'url',
    publicId: 'publicId',
    nombreArchivoOriginal: 'nombreArchivoOriginal',
    creadoEn: 'creadoEn'
  };

  export type ComprobanteScalarFieldEnum = (typeof ComprobanteScalarFieldEnum)[keyof typeof ComprobanteScalarFieldEnum]


  export const MantenimientoScalarFieldEnum: {
    id: 'id',
    vehiculoId: 'vehiculoId',
    tipo: 'tipo',
    estado: 'estado',
    descripcion: 'descripcion',
    taller: 'taller',
    esExterno: 'esExterno',
    costoManoObra: 'costoManoObra',
    costoRepuestos: 'costoRepuestos',
    costoTotal: 'costoTotal',
    fecha: 'fecha',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    kilometrajeAlMomento: 'kilometrajeAlMomento',
    proximaFecha: 'proximaFecha',
    proximoKilometraje: 'proximoKilometraje',
    comprobanteId: 'comprobanteId',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type MantenimientoScalarFieldEnum = (typeof MantenimientoScalarFieldEnum)[keyof typeof MantenimientoScalarFieldEnum]


  export const PagoChoferScalarFieldEnum: {
    id: 'id',
    choferId: 'choferId',
    monto: 'monto',
    fecha: 'fecha',
    metodoPago: 'metodoPago',
    descripcion: 'descripcion',
    estado: 'estado',
    fechaPagoReal: 'fechaPagoReal',
    comprobanteId: 'comprobanteId',
    viajeId: 'viajeId',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type PagoChoferScalarFieldEnum = (typeof PagoChoferScalarFieldEnum)[keyof typeof PagoChoferScalarFieldEnum]


  export const RegistroAuditoriaScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    accion: 'accion',
    entidad: 'entidad',
    entidadId: 'entidadId',
    datosAnteriores: 'datosAnteriores',
    datosNuevos: 'datosNuevos',
    fechaHora: 'fechaHora',
    ipAddress: 'ipAddress'
  };

  export type RegistroAuditoriaScalarFieldEnum = (typeof RegistroAuditoriaScalarFieldEnum)[keyof typeof RegistroAuditoriaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'RolUsuario'
   */
  export type EnumRolUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RolUsuario'>
    


  /**
   * Reference to a field of type 'RolUsuario[]'
   */
  export type ListEnumRolUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RolUsuario[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'EstadoVehiculo'
   */
  export type EnumEstadoVehiculoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoVehiculo'>
    


  /**
   * Reference to a field of type 'EstadoVehiculo[]'
   */
  export type ListEnumEstadoVehiculoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoVehiculo[]'>
    


  /**
   * Reference to a field of type 'EstadoChofer'
   */
  export type EnumEstadoChoferFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoChofer'>
    


  /**
   * Reference to a field of type 'EstadoChofer[]'
   */
  export type ListEnumEstadoChoferFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoChofer[]'>
    


  /**
   * Reference to a field of type 'ModalidadPago'
   */
  export type EnumModalidadPagoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModalidadPago'>
    


  /**
   * Reference to a field of type 'ModalidadPago[]'
   */
  export type ListEnumModalidadPagoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModalidadPago[]'>
    


  /**
   * Reference to a field of type 'MetodoPago'
   */
  export type EnumMetodoPagoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetodoPago'>
    


  /**
   * Reference to a field of type 'MetodoPago[]'
   */
  export type ListEnumMetodoPagoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetodoPago[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'EstadoCliente'
   */
  export type EnumEstadoClienteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoCliente'>
    


  /**
   * Reference to a field of type 'EstadoCliente[]'
   */
  export type ListEnumEstadoClienteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoCliente[]'>
    


  /**
   * Reference to a field of type 'EstadoPagoCliente'
   */
  export type EnumEstadoPagoClienteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoPagoCliente'>
    


  /**
   * Reference to a field of type 'EstadoPagoCliente[]'
   */
  export type ListEnumEstadoPagoClienteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoPagoCliente[]'>
    


  /**
   * Reference to a field of type 'EstadoViaje'
   */
  export type EnumEstadoViajeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoViaje'>
    


  /**
   * Reference to a field of type 'EstadoViaje[]'
   */
  export type ListEnumEstadoViajeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoViaje[]'>
    


  /**
   * Reference to a field of type 'TipoGasto'
   */
  export type EnumTipoGastoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoGasto'>
    


  /**
   * Reference to a field of type 'TipoGasto[]'
   */
  export type ListEnumTipoGastoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoGasto[]'>
    


  /**
   * Reference to a field of type 'TipoComprobante'
   */
  export type EnumTipoComprobanteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoComprobante'>
    


  /**
   * Reference to a field of type 'TipoComprobante[]'
   */
  export type ListEnumTipoComprobanteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoComprobante[]'>
    


  /**
   * Reference to a field of type 'TipoMantenimiento'
   */
  export type EnumTipoMantenimientoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoMantenimiento'>
    


  /**
   * Reference to a field of type 'TipoMantenimiento[]'
   */
  export type ListEnumTipoMantenimientoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoMantenimiento[]'>
    


  /**
   * Reference to a field of type 'EstadoMantenimiento'
   */
  export type EnumEstadoMantenimientoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoMantenimiento'>
    


  /**
   * Reference to a field of type 'EstadoMantenimiento[]'
   */
  export type ListEnumEstadoMantenimientoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoMantenimiento[]'>
    


  /**
   * Reference to a field of type 'EstadoPagoChofer'
   */
  export type EnumEstadoPagoChoferFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoPagoChofer'>
    


  /**
   * Reference to a field of type 'EstadoPagoChofer[]'
   */
  export type ListEnumEstadoPagoChoferFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoPagoChofer[]'>
    


  /**
   * Reference to a field of type 'AccionAuditoria'
   */
  export type EnumAccionAuditoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccionAuditoria'>
    


  /**
   * Reference to a field of type 'AccionAuditoria[]'
   */
  export type ListEnumAccionAuditoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccionAuditoria[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    nombreUsuario?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    passwordHash?: StringFilter<"Usuario"> | string
    nombreCompleto?: StringFilter<"Usuario"> | string
    rol?: EnumRolUsuarioFilter<"Usuario"> | $Enums.RolUsuario
    activo?: BoolFilter<"Usuario"> | boolean
    creadoEn?: DateTimeFilter<"Usuario"> | Date | string
    actualizadoEn?: DateTimeFilter<"Usuario"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    registrosAuditoria?: RegistroAuditoriaListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombreUsuario?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    nombreCompleto?: SortOrder
    rol?: SortOrder
    activo?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    registrosAuditoria?: RegistroAuditoriaOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombreUsuario?: string
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    passwordHash?: StringFilter<"Usuario"> | string
    nombreCompleto?: StringFilter<"Usuario"> | string
    rol?: EnumRolUsuarioFilter<"Usuario"> | $Enums.RolUsuario
    activo?: BoolFilter<"Usuario"> | boolean
    creadoEn?: DateTimeFilter<"Usuario"> | Date | string
    actualizadoEn?: DateTimeFilter<"Usuario"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    registrosAuditoria?: RegistroAuditoriaListRelationFilter
  }, "id" | "nombreUsuario" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombreUsuario?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    nombreCompleto?: SortOrder
    rol?: SortOrder
    activo?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    nombreUsuario?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    passwordHash?: StringWithAggregatesFilter<"Usuario"> | string
    nombreCompleto?: StringWithAggregatesFilter<"Usuario"> | string
    rol?: EnumRolUsuarioWithAggregatesFilter<"Usuario"> | $Enums.RolUsuario
    activo?: BoolWithAggregatesFilter<"Usuario"> | boolean
    creadoEn?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
  }

  export type VehiculoWhereInput = {
    AND?: VehiculoWhereInput | VehiculoWhereInput[]
    OR?: VehiculoWhereInput[]
    NOT?: VehiculoWhereInput | VehiculoWhereInput[]
    id?: IntFilter<"Vehiculo"> | number
    placa?: StringFilter<"Vehiculo"> | string
    marca?: StringFilter<"Vehiculo"> | string
    modelo?: StringFilter<"Vehiculo"> | string
    anio?: IntFilter<"Vehiculo"> | number
    tipo?: StringFilter<"Vehiculo"> | string
    capacidad?: StringFilter<"Vehiculo"> | string
    estado?: EnumEstadoVehiculoFilter<"Vehiculo"> | $Enums.EstadoVehiculo
    kilometrajeActual?: IntFilter<"Vehiculo"> | number
    fechaUltimoMantenimiento?: DateTimeNullableFilter<"Vehiculo"> | Date | string | null
    fechaProximoMantenimiento?: DateTimeNullableFilter<"Vehiculo"> | Date | string | null
    fechaVencimientoSoat?: DateTimeNullableFilter<"Vehiculo"> | Date | string | null
    fechaVencimientoSeguro?: DateTimeNullableFilter<"Vehiculo"> | Date | string | null
    fechaVencimientoMatricula?: DateTimeNullableFilter<"Vehiculo"> | Date | string | null
    observaciones?: StringNullableFilter<"Vehiculo"> | string | null
    creadoEn?: DateTimeFilter<"Vehiculo"> | Date | string
    actualizadoEn?: DateTimeFilter<"Vehiculo"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Vehiculo"> | Date | string | null
    viajes?: ViajeListRelationFilter
    mantenimientos?: MantenimientoListRelationFilter
  }

  export type VehiculoOrderByWithRelationInput = {
    id?: SortOrder
    placa?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    anio?: SortOrder
    tipo?: SortOrder
    capacidad?: SortOrder
    estado?: SortOrder
    kilometrajeActual?: SortOrder
    fechaUltimoMantenimiento?: SortOrderInput | SortOrder
    fechaProximoMantenimiento?: SortOrderInput | SortOrder
    fechaVencimientoSoat?: SortOrderInput | SortOrder
    fechaVencimientoSeguro?: SortOrderInput | SortOrder
    fechaVencimientoMatricula?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    viajes?: ViajeOrderByRelationAggregateInput
    mantenimientos?: MantenimientoOrderByRelationAggregateInput
  }

  export type VehiculoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    placa?: string
    AND?: VehiculoWhereInput | VehiculoWhereInput[]
    OR?: VehiculoWhereInput[]
    NOT?: VehiculoWhereInput | VehiculoWhereInput[]
    marca?: StringFilter<"Vehiculo"> | string
    modelo?: StringFilter<"Vehiculo"> | string
    anio?: IntFilter<"Vehiculo"> | number
    tipo?: StringFilter<"Vehiculo"> | string
    capacidad?: StringFilter<"Vehiculo"> | string
    estado?: EnumEstadoVehiculoFilter<"Vehiculo"> | $Enums.EstadoVehiculo
    kilometrajeActual?: IntFilter<"Vehiculo"> | number
    fechaUltimoMantenimiento?: DateTimeNullableFilter<"Vehiculo"> | Date | string | null
    fechaProximoMantenimiento?: DateTimeNullableFilter<"Vehiculo"> | Date | string | null
    fechaVencimientoSoat?: DateTimeNullableFilter<"Vehiculo"> | Date | string | null
    fechaVencimientoSeguro?: DateTimeNullableFilter<"Vehiculo"> | Date | string | null
    fechaVencimientoMatricula?: DateTimeNullableFilter<"Vehiculo"> | Date | string | null
    observaciones?: StringNullableFilter<"Vehiculo"> | string | null
    creadoEn?: DateTimeFilter<"Vehiculo"> | Date | string
    actualizadoEn?: DateTimeFilter<"Vehiculo"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Vehiculo"> | Date | string | null
    viajes?: ViajeListRelationFilter
    mantenimientos?: MantenimientoListRelationFilter
  }, "id" | "placa">

  export type VehiculoOrderByWithAggregationInput = {
    id?: SortOrder
    placa?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    anio?: SortOrder
    tipo?: SortOrder
    capacidad?: SortOrder
    estado?: SortOrder
    kilometrajeActual?: SortOrder
    fechaUltimoMantenimiento?: SortOrderInput | SortOrder
    fechaProximoMantenimiento?: SortOrderInput | SortOrder
    fechaVencimientoSoat?: SortOrderInput | SortOrder
    fechaVencimientoSeguro?: SortOrderInput | SortOrder
    fechaVencimientoMatricula?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: VehiculoCountOrderByAggregateInput
    _avg?: VehiculoAvgOrderByAggregateInput
    _max?: VehiculoMaxOrderByAggregateInput
    _min?: VehiculoMinOrderByAggregateInput
    _sum?: VehiculoSumOrderByAggregateInput
  }

  export type VehiculoScalarWhereWithAggregatesInput = {
    AND?: VehiculoScalarWhereWithAggregatesInput | VehiculoScalarWhereWithAggregatesInput[]
    OR?: VehiculoScalarWhereWithAggregatesInput[]
    NOT?: VehiculoScalarWhereWithAggregatesInput | VehiculoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vehiculo"> | number
    placa?: StringWithAggregatesFilter<"Vehiculo"> | string
    marca?: StringWithAggregatesFilter<"Vehiculo"> | string
    modelo?: StringWithAggregatesFilter<"Vehiculo"> | string
    anio?: IntWithAggregatesFilter<"Vehiculo"> | number
    tipo?: StringWithAggregatesFilter<"Vehiculo"> | string
    capacidad?: StringWithAggregatesFilter<"Vehiculo"> | string
    estado?: EnumEstadoVehiculoWithAggregatesFilter<"Vehiculo"> | $Enums.EstadoVehiculo
    kilometrajeActual?: IntWithAggregatesFilter<"Vehiculo"> | number
    fechaUltimoMantenimiento?: DateTimeNullableWithAggregatesFilter<"Vehiculo"> | Date | string | null
    fechaProximoMantenimiento?: DateTimeNullableWithAggregatesFilter<"Vehiculo"> | Date | string | null
    fechaVencimientoSoat?: DateTimeNullableWithAggregatesFilter<"Vehiculo"> | Date | string | null
    fechaVencimientoSeguro?: DateTimeNullableWithAggregatesFilter<"Vehiculo"> | Date | string | null
    fechaVencimientoMatricula?: DateTimeNullableWithAggregatesFilter<"Vehiculo"> | Date | string | null
    observaciones?: StringNullableWithAggregatesFilter<"Vehiculo"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"Vehiculo"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"Vehiculo"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Vehiculo"> | Date | string | null
  }

  export type ChoferWhereInput = {
    AND?: ChoferWhereInput | ChoferWhereInput[]
    OR?: ChoferWhereInput[]
    NOT?: ChoferWhereInput | ChoferWhereInput[]
    id?: IntFilter<"Chofer"> | number
    nombres?: StringFilter<"Chofer"> | string
    apellidos?: StringFilter<"Chofer"> | string
    documentoId?: StringFilter<"Chofer"> | string
    telefono?: StringNullableFilter<"Chofer"> | string | null
    fechaVencimientoLicencia?: DateTimeNullableFilter<"Chofer"> | Date | string | null
    correo?: StringNullableFilter<"Chofer"> | string | null
    estado?: EnumEstadoChoferFilter<"Chofer"> | $Enums.EstadoChofer
    modalidadPago?: EnumModalidadPagoFilter<"Chofer"> | $Enums.ModalidadPago
    metodoPago?: EnumMetodoPagoFilter<"Chofer"> | $Enums.MetodoPago
    banco?: StringNullableFilter<"Chofer"> | string | null
    numeroCuenta?: StringNullableFilter<"Chofer"> | string | null
    sueldoMensual?: DecimalNullableFilter<"Chofer"> | Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: DateTimeNullableFilter<"Chofer"> | Date | string | null
    diaPago?: IntNullableFilter<"Chofer"> | number | null
    pagoQuincenal?: BoolFilter<"Chofer"> | boolean
    creadoEn?: DateTimeFilter<"Chofer"> | Date | string
    actualizadoEn?: DateTimeFilter<"Chofer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Chofer"> | Date | string | null
    viajes?: ViajeListRelationFilter
    pagos?: PagoChoferListRelationFilter
  }

  export type ChoferOrderByWithRelationInput = {
    id?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    documentoId?: SortOrder
    telefono?: SortOrderInput | SortOrder
    fechaVencimientoLicencia?: SortOrderInput | SortOrder
    correo?: SortOrderInput | SortOrder
    estado?: SortOrder
    modalidadPago?: SortOrder
    metodoPago?: SortOrder
    banco?: SortOrderInput | SortOrder
    numeroCuenta?: SortOrderInput | SortOrder
    sueldoMensual?: SortOrderInput | SortOrder
    fechaContratacion?: SortOrderInput | SortOrder
    diaPago?: SortOrderInput | SortOrder
    pagoQuincenal?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    viajes?: ViajeOrderByRelationAggregateInput
    pagos?: PagoChoferOrderByRelationAggregateInput
  }

  export type ChoferWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    documentoId?: string
    AND?: ChoferWhereInput | ChoferWhereInput[]
    OR?: ChoferWhereInput[]
    NOT?: ChoferWhereInput | ChoferWhereInput[]
    nombres?: StringFilter<"Chofer"> | string
    apellidos?: StringFilter<"Chofer"> | string
    telefono?: StringNullableFilter<"Chofer"> | string | null
    fechaVencimientoLicencia?: DateTimeNullableFilter<"Chofer"> | Date | string | null
    correo?: StringNullableFilter<"Chofer"> | string | null
    estado?: EnumEstadoChoferFilter<"Chofer"> | $Enums.EstadoChofer
    modalidadPago?: EnumModalidadPagoFilter<"Chofer"> | $Enums.ModalidadPago
    metodoPago?: EnumMetodoPagoFilter<"Chofer"> | $Enums.MetodoPago
    banco?: StringNullableFilter<"Chofer"> | string | null
    numeroCuenta?: StringNullableFilter<"Chofer"> | string | null
    sueldoMensual?: DecimalNullableFilter<"Chofer"> | Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: DateTimeNullableFilter<"Chofer"> | Date | string | null
    diaPago?: IntNullableFilter<"Chofer"> | number | null
    pagoQuincenal?: BoolFilter<"Chofer"> | boolean
    creadoEn?: DateTimeFilter<"Chofer"> | Date | string
    actualizadoEn?: DateTimeFilter<"Chofer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Chofer"> | Date | string | null
    viajes?: ViajeListRelationFilter
    pagos?: PagoChoferListRelationFilter
  }, "id" | "documentoId">

  export type ChoferOrderByWithAggregationInput = {
    id?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    documentoId?: SortOrder
    telefono?: SortOrderInput | SortOrder
    fechaVencimientoLicencia?: SortOrderInput | SortOrder
    correo?: SortOrderInput | SortOrder
    estado?: SortOrder
    modalidadPago?: SortOrder
    metodoPago?: SortOrder
    banco?: SortOrderInput | SortOrder
    numeroCuenta?: SortOrderInput | SortOrder
    sueldoMensual?: SortOrderInput | SortOrder
    fechaContratacion?: SortOrderInput | SortOrder
    diaPago?: SortOrderInput | SortOrder
    pagoQuincenal?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ChoferCountOrderByAggregateInput
    _avg?: ChoferAvgOrderByAggregateInput
    _max?: ChoferMaxOrderByAggregateInput
    _min?: ChoferMinOrderByAggregateInput
    _sum?: ChoferSumOrderByAggregateInput
  }

  export type ChoferScalarWhereWithAggregatesInput = {
    AND?: ChoferScalarWhereWithAggregatesInput | ChoferScalarWhereWithAggregatesInput[]
    OR?: ChoferScalarWhereWithAggregatesInput[]
    NOT?: ChoferScalarWhereWithAggregatesInput | ChoferScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Chofer"> | number
    nombres?: StringWithAggregatesFilter<"Chofer"> | string
    apellidos?: StringWithAggregatesFilter<"Chofer"> | string
    documentoId?: StringWithAggregatesFilter<"Chofer"> | string
    telefono?: StringNullableWithAggregatesFilter<"Chofer"> | string | null
    fechaVencimientoLicencia?: DateTimeNullableWithAggregatesFilter<"Chofer"> | Date | string | null
    correo?: StringNullableWithAggregatesFilter<"Chofer"> | string | null
    estado?: EnumEstadoChoferWithAggregatesFilter<"Chofer"> | $Enums.EstadoChofer
    modalidadPago?: EnumModalidadPagoWithAggregatesFilter<"Chofer"> | $Enums.ModalidadPago
    metodoPago?: EnumMetodoPagoWithAggregatesFilter<"Chofer"> | $Enums.MetodoPago
    banco?: StringNullableWithAggregatesFilter<"Chofer"> | string | null
    numeroCuenta?: StringNullableWithAggregatesFilter<"Chofer"> | string | null
    sueldoMensual?: DecimalNullableWithAggregatesFilter<"Chofer"> | Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: DateTimeNullableWithAggregatesFilter<"Chofer"> | Date | string | null
    diaPago?: IntNullableWithAggregatesFilter<"Chofer"> | number | null
    pagoQuincenal?: BoolWithAggregatesFilter<"Chofer"> | boolean
    creadoEn?: DateTimeWithAggregatesFilter<"Chofer"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"Chofer"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Chofer"> | Date | string | null
  }

  export type ClienteWhereInput = {
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    id?: IntFilter<"Cliente"> | number
    nombreRazonSocial?: StringFilter<"Cliente"> | string
    documentoId?: StringFilter<"Cliente"> | string
    telefono?: StringNullableFilter<"Cliente"> | string | null
    correo?: StringNullableFilter<"Cliente"> | string | null
    direccion?: StringNullableFilter<"Cliente"> | string | null
    sector?: StringNullableFilter<"Cliente"> | string | null
    estado?: EnumEstadoClienteFilter<"Cliente"> | $Enums.EstadoCliente
    creadoEn?: DateTimeFilter<"Cliente"> | Date | string
    actualizadoEn?: DateTimeFilter<"Cliente"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Cliente"> | Date | string | null
    viajes?: ViajeListRelationFilter
  }

  export type ClienteOrderByWithRelationInput = {
    id?: SortOrder
    nombreRazonSocial?: SortOrder
    documentoId?: SortOrder
    telefono?: SortOrderInput | SortOrder
    correo?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    sector?: SortOrderInput | SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    viajes?: ViajeOrderByRelationAggregateInput
  }

  export type ClienteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    documentoId?: string
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    nombreRazonSocial?: StringFilter<"Cliente"> | string
    telefono?: StringNullableFilter<"Cliente"> | string | null
    correo?: StringNullableFilter<"Cliente"> | string | null
    direccion?: StringNullableFilter<"Cliente"> | string | null
    sector?: StringNullableFilter<"Cliente"> | string | null
    estado?: EnumEstadoClienteFilter<"Cliente"> | $Enums.EstadoCliente
    creadoEn?: DateTimeFilter<"Cliente"> | Date | string
    actualizadoEn?: DateTimeFilter<"Cliente"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Cliente"> | Date | string | null
    viajes?: ViajeListRelationFilter
  }, "id" | "documentoId">

  export type ClienteOrderByWithAggregationInput = {
    id?: SortOrder
    nombreRazonSocial?: SortOrder
    documentoId?: SortOrder
    telefono?: SortOrderInput | SortOrder
    correo?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    sector?: SortOrderInput | SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ClienteCountOrderByAggregateInput
    _avg?: ClienteAvgOrderByAggregateInput
    _max?: ClienteMaxOrderByAggregateInput
    _min?: ClienteMinOrderByAggregateInput
    _sum?: ClienteSumOrderByAggregateInput
  }

  export type ClienteScalarWhereWithAggregatesInput = {
    AND?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    OR?: ClienteScalarWhereWithAggregatesInput[]
    NOT?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cliente"> | number
    nombreRazonSocial?: StringWithAggregatesFilter<"Cliente"> | string
    documentoId?: StringWithAggregatesFilter<"Cliente"> | string
    telefono?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    correo?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    sector?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    estado?: EnumEstadoClienteWithAggregatesFilter<"Cliente"> | $Enums.EstadoCliente
    creadoEn?: DateTimeWithAggregatesFilter<"Cliente"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"Cliente"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Cliente"> | Date | string | null
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: IntFilter<"Material"> | number
    nombre?: StringFilter<"Material"> | string
    unidadMedida?: StringFilter<"Material"> | string
    esPeligroso?: BoolFilter<"Material"> | boolean
    descripcion?: StringNullableFilter<"Material"> | string | null
    creadoEn?: DateTimeFilter<"Material"> | Date | string
    actualizadoEn?: DateTimeFilter<"Material"> | Date | string
    viajes?: ViajeListRelationFilter
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    unidadMedida?: SortOrder
    esPeligroso?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    viajes?: ViajeOrderByRelationAggregateInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    unidadMedida?: StringFilter<"Material"> | string
    esPeligroso?: BoolFilter<"Material"> | boolean
    descripcion?: StringNullableFilter<"Material"> | string | null
    creadoEn?: DateTimeFilter<"Material"> | Date | string
    actualizadoEn?: DateTimeFilter<"Material"> | Date | string
    viajes?: ViajeListRelationFilter
  }, "id" | "nombre">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    unidadMedida?: SortOrder
    esPeligroso?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _avg?: MaterialAvgOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
    _sum?: MaterialSumOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Material"> | number
    nombre?: StringWithAggregatesFilter<"Material"> | string
    unidadMedida?: StringWithAggregatesFilter<"Material"> | string
    esPeligroso?: BoolWithAggregatesFilter<"Material"> | boolean
    descripcion?: StringNullableWithAggregatesFilter<"Material"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"Material"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"Material"> | Date | string
  }

  export type ViajeWhereInput = {
    AND?: ViajeWhereInput | ViajeWhereInput[]
    OR?: ViajeWhereInput[]
    NOT?: ViajeWhereInput | ViajeWhereInput[]
    id?: IntFilter<"Viaje"> | number
    vehiculoId?: IntFilter<"Viaje"> | number
    choferId?: IntFilter<"Viaje"> | number
    clienteId?: IntFilter<"Viaje"> | number
    materialId?: IntFilter<"Viaje"> | number
    origen?: StringFilter<"Viaje"> | string
    destino?: StringFilter<"Viaje"> | string
    fechaSalida?: DateTimeFilter<"Viaje"> | Date | string
    fechaLlegadaEstimada?: DateTimeNullableFilter<"Viaje"> | Date | string | null
    fechaLlegadaReal?: DateTimeNullableFilter<"Viaje"> | Date | string | null
    kilometrosEstimados?: IntNullableFilter<"Viaje"> | number | null
    kilometrosReales?: IntNullableFilter<"Viaje"> | number | null
    tarifa?: DecimalFilter<"Viaje"> | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFilter<"Viaje"> | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFilter<"Viaje"> | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: DateTimeNullableFilter<"Viaje"> | Date | string | null
    diasCredito?: IntFilter<"Viaje"> | number
    montoPagoChofer?: DecimalNullableFilter<"Viaje"> | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFilter<"Viaje"> | $Enums.EstadoViaje
    observaciones?: StringNullableFilter<"Viaje"> | string | null
    creadoEn?: DateTimeFilter<"Viaje"> | Date | string
    actualizadoEn?: DateTimeFilter<"Viaje"> | Date | string
    vehiculo?: XOR<VehiculoRelationFilter, VehiculoWhereInput>
    chofer?: XOR<ChoferRelationFilter, ChoferWhereInput>
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
    gastos?: GastoViajeListRelationFilter
    pagos?: PagoChoferListRelationFilter
  }

  export type ViajeOrderByWithRelationInput = {
    id?: SortOrder
    vehiculoId?: SortOrder
    choferId?: SortOrder
    clienteId?: SortOrder
    materialId?: SortOrder
    origen?: SortOrder
    destino?: SortOrder
    fechaSalida?: SortOrder
    fechaLlegadaEstimada?: SortOrderInput | SortOrder
    fechaLlegadaReal?: SortOrderInput | SortOrder
    kilometrosEstimados?: SortOrderInput | SortOrder
    kilometrosReales?: SortOrderInput | SortOrder
    tarifa?: SortOrder
    estadoPagoCliente?: SortOrder
    montoPagadoCliente?: SortOrder
    fechaLimitePago?: SortOrderInput | SortOrder
    diasCredito?: SortOrder
    montoPagoChofer?: SortOrderInput | SortOrder
    estado?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    vehiculo?: VehiculoOrderByWithRelationInput
    chofer?: ChoferOrderByWithRelationInput
    cliente?: ClienteOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
    gastos?: GastoViajeOrderByRelationAggregateInput
    pagos?: PagoChoferOrderByRelationAggregateInput
  }

  export type ViajeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ViajeWhereInput | ViajeWhereInput[]
    OR?: ViajeWhereInput[]
    NOT?: ViajeWhereInput | ViajeWhereInput[]
    vehiculoId?: IntFilter<"Viaje"> | number
    choferId?: IntFilter<"Viaje"> | number
    clienteId?: IntFilter<"Viaje"> | number
    materialId?: IntFilter<"Viaje"> | number
    origen?: StringFilter<"Viaje"> | string
    destino?: StringFilter<"Viaje"> | string
    fechaSalida?: DateTimeFilter<"Viaje"> | Date | string
    fechaLlegadaEstimada?: DateTimeNullableFilter<"Viaje"> | Date | string | null
    fechaLlegadaReal?: DateTimeNullableFilter<"Viaje"> | Date | string | null
    kilometrosEstimados?: IntNullableFilter<"Viaje"> | number | null
    kilometrosReales?: IntNullableFilter<"Viaje"> | number | null
    tarifa?: DecimalFilter<"Viaje"> | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFilter<"Viaje"> | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFilter<"Viaje"> | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: DateTimeNullableFilter<"Viaje"> | Date | string | null
    diasCredito?: IntFilter<"Viaje"> | number
    montoPagoChofer?: DecimalNullableFilter<"Viaje"> | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFilter<"Viaje"> | $Enums.EstadoViaje
    observaciones?: StringNullableFilter<"Viaje"> | string | null
    creadoEn?: DateTimeFilter<"Viaje"> | Date | string
    actualizadoEn?: DateTimeFilter<"Viaje"> | Date | string
    vehiculo?: XOR<VehiculoRelationFilter, VehiculoWhereInput>
    chofer?: XOR<ChoferRelationFilter, ChoferWhereInput>
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
    gastos?: GastoViajeListRelationFilter
    pagos?: PagoChoferListRelationFilter
  }, "id">

  export type ViajeOrderByWithAggregationInput = {
    id?: SortOrder
    vehiculoId?: SortOrder
    choferId?: SortOrder
    clienteId?: SortOrder
    materialId?: SortOrder
    origen?: SortOrder
    destino?: SortOrder
    fechaSalida?: SortOrder
    fechaLlegadaEstimada?: SortOrderInput | SortOrder
    fechaLlegadaReal?: SortOrderInput | SortOrder
    kilometrosEstimados?: SortOrderInput | SortOrder
    kilometrosReales?: SortOrderInput | SortOrder
    tarifa?: SortOrder
    estadoPagoCliente?: SortOrder
    montoPagadoCliente?: SortOrder
    fechaLimitePago?: SortOrderInput | SortOrder
    diasCredito?: SortOrder
    montoPagoChofer?: SortOrderInput | SortOrder
    estado?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: ViajeCountOrderByAggregateInput
    _avg?: ViajeAvgOrderByAggregateInput
    _max?: ViajeMaxOrderByAggregateInput
    _min?: ViajeMinOrderByAggregateInput
    _sum?: ViajeSumOrderByAggregateInput
  }

  export type ViajeScalarWhereWithAggregatesInput = {
    AND?: ViajeScalarWhereWithAggregatesInput | ViajeScalarWhereWithAggregatesInput[]
    OR?: ViajeScalarWhereWithAggregatesInput[]
    NOT?: ViajeScalarWhereWithAggregatesInput | ViajeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Viaje"> | number
    vehiculoId?: IntWithAggregatesFilter<"Viaje"> | number
    choferId?: IntWithAggregatesFilter<"Viaje"> | number
    clienteId?: IntWithAggregatesFilter<"Viaje"> | number
    materialId?: IntWithAggregatesFilter<"Viaje"> | number
    origen?: StringWithAggregatesFilter<"Viaje"> | string
    destino?: StringWithAggregatesFilter<"Viaje"> | string
    fechaSalida?: DateTimeWithAggregatesFilter<"Viaje"> | Date | string
    fechaLlegadaEstimada?: DateTimeNullableWithAggregatesFilter<"Viaje"> | Date | string | null
    fechaLlegadaReal?: DateTimeNullableWithAggregatesFilter<"Viaje"> | Date | string | null
    kilometrosEstimados?: IntNullableWithAggregatesFilter<"Viaje"> | number | null
    kilometrosReales?: IntNullableWithAggregatesFilter<"Viaje"> | number | null
    tarifa?: DecimalWithAggregatesFilter<"Viaje"> | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteWithAggregatesFilter<"Viaje"> | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalWithAggregatesFilter<"Viaje"> | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: DateTimeNullableWithAggregatesFilter<"Viaje"> | Date | string | null
    diasCredito?: IntWithAggregatesFilter<"Viaje"> | number
    montoPagoChofer?: DecimalNullableWithAggregatesFilter<"Viaje"> | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeWithAggregatesFilter<"Viaje"> | $Enums.EstadoViaje
    observaciones?: StringNullableWithAggregatesFilter<"Viaje"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"Viaje"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"Viaje"> | Date | string
  }

  export type GastoViajeWhereInput = {
    AND?: GastoViajeWhereInput | GastoViajeWhereInput[]
    OR?: GastoViajeWhereInput[]
    NOT?: GastoViajeWhereInput | GastoViajeWhereInput[]
    id?: IntFilter<"GastoViaje"> | number
    viajeId?: IntFilter<"GastoViaje"> | number
    tipoGasto?: EnumTipoGastoFilter<"GastoViaje"> | $Enums.TipoGasto
    monto?: DecimalFilter<"GastoViaje"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter<"GastoViaje"> | Date | string
    metodoPago?: EnumMetodoPagoFilter<"GastoViaje"> | $Enums.MetodoPago
    descripcion?: StringNullableFilter<"GastoViaje"> | string | null
    comprobanteId?: IntNullableFilter<"GastoViaje"> | number | null
    creadoEn?: DateTimeFilter<"GastoViaje"> | Date | string
    actualizadoEn?: DateTimeFilter<"GastoViaje"> | Date | string
    viaje?: XOR<ViajeRelationFilter, ViajeWhereInput>
    comprobante?: XOR<ComprobanteNullableRelationFilter, ComprobanteWhereInput> | null
  }

  export type GastoViajeOrderByWithRelationInput = {
    id?: SortOrder
    viajeId?: SortOrder
    tipoGasto?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    metodoPago?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    comprobanteId?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    viaje?: ViajeOrderByWithRelationInput
    comprobante?: ComprobanteOrderByWithRelationInput
  }

  export type GastoViajeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GastoViajeWhereInput | GastoViajeWhereInput[]
    OR?: GastoViajeWhereInput[]
    NOT?: GastoViajeWhereInput | GastoViajeWhereInput[]
    viajeId?: IntFilter<"GastoViaje"> | number
    tipoGasto?: EnumTipoGastoFilter<"GastoViaje"> | $Enums.TipoGasto
    monto?: DecimalFilter<"GastoViaje"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter<"GastoViaje"> | Date | string
    metodoPago?: EnumMetodoPagoFilter<"GastoViaje"> | $Enums.MetodoPago
    descripcion?: StringNullableFilter<"GastoViaje"> | string | null
    comprobanteId?: IntNullableFilter<"GastoViaje"> | number | null
    creadoEn?: DateTimeFilter<"GastoViaje"> | Date | string
    actualizadoEn?: DateTimeFilter<"GastoViaje"> | Date | string
    viaje?: XOR<ViajeRelationFilter, ViajeWhereInput>
    comprobante?: XOR<ComprobanteNullableRelationFilter, ComprobanteWhereInput> | null
  }, "id">

  export type GastoViajeOrderByWithAggregationInput = {
    id?: SortOrder
    viajeId?: SortOrder
    tipoGasto?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    metodoPago?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    comprobanteId?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: GastoViajeCountOrderByAggregateInput
    _avg?: GastoViajeAvgOrderByAggregateInput
    _max?: GastoViajeMaxOrderByAggregateInput
    _min?: GastoViajeMinOrderByAggregateInput
    _sum?: GastoViajeSumOrderByAggregateInput
  }

  export type GastoViajeScalarWhereWithAggregatesInput = {
    AND?: GastoViajeScalarWhereWithAggregatesInput | GastoViajeScalarWhereWithAggregatesInput[]
    OR?: GastoViajeScalarWhereWithAggregatesInput[]
    NOT?: GastoViajeScalarWhereWithAggregatesInput | GastoViajeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GastoViaje"> | number
    viajeId?: IntWithAggregatesFilter<"GastoViaje"> | number
    tipoGasto?: EnumTipoGastoWithAggregatesFilter<"GastoViaje"> | $Enums.TipoGasto
    monto?: DecimalWithAggregatesFilter<"GastoViaje"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeWithAggregatesFilter<"GastoViaje"> | Date | string
    metodoPago?: EnumMetodoPagoWithAggregatesFilter<"GastoViaje"> | $Enums.MetodoPago
    descripcion?: StringNullableWithAggregatesFilter<"GastoViaje"> | string | null
    comprobanteId?: IntNullableWithAggregatesFilter<"GastoViaje"> | number | null
    creadoEn?: DateTimeWithAggregatesFilter<"GastoViaje"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"GastoViaje"> | Date | string
  }

  export type ComprobanteWhereInput = {
    AND?: ComprobanteWhereInput | ComprobanteWhereInput[]
    OR?: ComprobanteWhereInput[]
    NOT?: ComprobanteWhereInput | ComprobanteWhereInput[]
    id?: IntFilter<"Comprobante"> | number
    tipo?: EnumTipoComprobanteFilter<"Comprobante"> | $Enums.TipoComprobante
    referenciaId?: IntNullableFilter<"Comprobante"> | number | null
    url?: StringFilter<"Comprobante"> | string
    publicId?: StringFilter<"Comprobante"> | string
    nombreArchivoOriginal?: StringFilter<"Comprobante"> | string
    creadoEn?: DateTimeFilter<"Comprobante"> | Date | string
    gastosViaje?: GastoViajeListRelationFilter
    mantenimientos?: MantenimientoListRelationFilter
    pagosChofer?: PagoChoferListRelationFilter
  }

  export type ComprobanteOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    referenciaId?: SortOrderInput | SortOrder
    url?: SortOrder
    publicId?: SortOrder
    nombreArchivoOriginal?: SortOrder
    creadoEn?: SortOrder
    gastosViaje?: GastoViajeOrderByRelationAggregateInput
    mantenimientos?: MantenimientoOrderByRelationAggregateInput
    pagosChofer?: PagoChoferOrderByRelationAggregateInput
  }

  export type ComprobanteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComprobanteWhereInput | ComprobanteWhereInput[]
    OR?: ComprobanteWhereInput[]
    NOT?: ComprobanteWhereInput | ComprobanteWhereInput[]
    tipo?: EnumTipoComprobanteFilter<"Comprobante"> | $Enums.TipoComprobante
    referenciaId?: IntNullableFilter<"Comprobante"> | number | null
    url?: StringFilter<"Comprobante"> | string
    publicId?: StringFilter<"Comprobante"> | string
    nombreArchivoOriginal?: StringFilter<"Comprobante"> | string
    creadoEn?: DateTimeFilter<"Comprobante"> | Date | string
    gastosViaje?: GastoViajeListRelationFilter
    mantenimientos?: MantenimientoListRelationFilter
    pagosChofer?: PagoChoferListRelationFilter
  }, "id">

  export type ComprobanteOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    referenciaId?: SortOrderInput | SortOrder
    url?: SortOrder
    publicId?: SortOrder
    nombreArchivoOriginal?: SortOrder
    creadoEn?: SortOrder
    _count?: ComprobanteCountOrderByAggregateInput
    _avg?: ComprobanteAvgOrderByAggregateInput
    _max?: ComprobanteMaxOrderByAggregateInput
    _min?: ComprobanteMinOrderByAggregateInput
    _sum?: ComprobanteSumOrderByAggregateInput
  }

  export type ComprobanteScalarWhereWithAggregatesInput = {
    AND?: ComprobanteScalarWhereWithAggregatesInput | ComprobanteScalarWhereWithAggregatesInput[]
    OR?: ComprobanteScalarWhereWithAggregatesInput[]
    NOT?: ComprobanteScalarWhereWithAggregatesInput | ComprobanteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comprobante"> | number
    tipo?: EnumTipoComprobanteWithAggregatesFilter<"Comprobante"> | $Enums.TipoComprobante
    referenciaId?: IntNullableWithAggregatesFilter<"Comprobante"> | number | null
    url?: StringWithAggregatesFilter<"Comprobante"> | string
    publicId?: StringWithAggregatesFilter<"Comprobante"> | string
    nombreArchivoOriginal?: StringWithAggregatesFilter<"Comprobante"> | string
    creadoEn?: DateTimeWithAggregatesFilter<"Comprobante"> | Date | string
  }

  export type MantenimientoWhereInput = {
    AND?: MantenimientoWhereInput | MantenimientoWhereInput[]
    OR?: MantenimientoWhereInput[]
    NOT?: MantenimientoWhereInput | MantenimientoWhereInput[]
    id?: IntFilter<"Mantenimiento"> | number
    vehiculoId?: IntFilter<"Mantenimiento"> | number
    tipo?: EnumTipoMantenimientoFilter<"Mantenimiento"> | $Enums.TipoMantenimiento
    estado?: EnumEstadoMantenimientoFilter<"Mantenimiento"> | $Enums.EstadoMantenimiento
    descripcion?: StringNullableFilter<"Mantenimiento"> | string | null
    taller?: StringNullableFilter<"Mantenimiento"> | string | null
    esExterno?: BoolFilter<"Mantenimiento"> | boolean
    costoManoObra?: DecimalFilter<"Mantenimiento"> | Decimal | DecimalJsLike | number | string
    costoRepuestos?: DecimalFilter<"Mantenimiento"> | Decimal | DecimalJsLike | number | string
    costoTotal?: DecimalFilter<"Mantenimiento"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter<"Mantenimiento"> | Date | string
    fechaInicio?: DateTimeNullableFilter<"Mantenimiento"> | Date | string | null
    fechaFin?: DateTimeNullableFilter<"Mantenimiento"> | Date | string | null
    kilometrajeAlMomento?: IntNullableFilter<"Mantenimiento"> | number | null
    proximaFecha?: DateTimeNullableFilter<"Mantenimiento"> | Date | string | null
    proximoKilometraje?: IntNullableFilter<"Mantenimiento"> | number | null
    comprobanteId?: IntNullableFilter<"Mantenimiento"> | number | null
    creadoEn?: DateTimeFilter<"Mantenimiento"> | Date | string
    actualizadoEn?: DateTimeFilter<"Mantenimiento"> | Date | string
    vehiculo?: XOR<VehiculoRelationFilter, VehiculoWhereInput>
    comprobante?: XOR<ComprobanteNullableRelationFilter, ComprobanteWhereInput> | null
  }

  export type MantenimientoOrderByWithRelationInput = {
    id?: SortOrder
    vehiculoId?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    taller?: SortOrderInput | SortOrder
    esExterno?: SortOrder
    costoManoObra?: SortOrder
    costoRepuestos?: SortOrder
    costoTotal?: SortOrder
    fecha?: SortOrder
    fechaInicio?: SortOrderInput | SortOrder
    fechaFin?: SortOrderInput | SortOrder
    kilometrajeAlMomento?: SortOrderInput | SortOrder
    proximaFecha?: SortOrderInput | SortOrder
    proximoKilometraje?: SortOrderInput | SortOrder
    comprobanteId?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    vehiculo?: VehiculoOrderByWithRelationInput
    comprobante?: ComprobanteOrderByWithRelationInput
  }

  export type MantenimientoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MantenimientoWhereInput | MantenimientoWhereInput[]
    OR?: MantenimientoWhereInput[]
    NOT?: MantenimientoWhereInput | MantenimientoWhereInput[]
    vehiculoId?: IntFilter<"Mantenimiento"> | number
    tipo?: EnumTipoMantenimientoFilter<"Mantenimiento"> | $Enums.TipoMantenimiento
    estado?: EnumEstadoMantenimientoFilter<"Mantenimiento"> | $Enums.EstadoMantenimiento
    descripcion?: StringNullableFilter<"Mantenimiento"> | string | null
    taller?: StringNullableFilter<"Mantenimiento"> | string | null
    esExterno?: BoolFilter<"Mantenimiento"> | boolean
    costoManoObra?: DecimalFilter<"Mantenimiento"> | Decimal | DecimalJsLike | number | string
    costoRepuestos?: DecimalFilter<"Mantenimiento"> | Decimal | DecimalJsLike | number | string
    costoTotal?: DecimalFilter<"Mantenimiento"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter<"Mantenimiento"> | Date | string
    fechaInicio?: DateTimeNullableFilter<"Mantenimiento"> | Date | string | null
    fechaFin?: DateTimeNullableFilter<"Mantenimiento"> | Date | string | null
    kilometrajeAlMomento?: IntNullableFilter<"Mantenimiento"> | number | null
    proximaFecha?: DateTimeNullableFilter<"Mantenimiento"> | Date | string | null
    proximoKilometraje?: IntNullableFilter<"Mantenimiento"> | number | null
    comprobanteId?: IntNullableFilter<"Mantenimiento"> | number | null
    creadoEn?: DateTimeFilter<"Mantenimiento"> | Date | string
    actualizadoEn?: DateTimeFilter<"Mantenimiento"> | Date | string
    vehiculo?: XOR<VehiculoRelationFilter, VehiculoWhereInput>
    comprobante?: XOR<ComprobanteNullableRelationFilter, ComprobanteWhereInput> | null
  }, "id">

  export type MantenimientoOrderByWithAggregationInput = {
    id?: SortOrder
    vehiculoId?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    taller?: SortOrderInput | SortOrder
    esExterno?: SortOrder
    costoManoObra?: SortOrder
    costoRepuestos?: SortOrder
    costoTotal?: SortOrder
    fecha?: SortOrder
    fechaInicio?: SortOrderInput | SortOrder
    fechaFin?: SortOrderInput | SortOrder
    kilometrajeAlMomento?: SortOrderInput | SortOrder
    proximaFecha?: SortOrderInput | SortOrder
    proximoKilometraje?: SortOrderInput | SortOrder
    comprobanteId?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: MantenimientoCountOrderByAggregateInput
    _avg?: MantenimientoAvgOrderByAggregateInput
    _max?: MantenimientoMaxOrderByAggregateInput
    _min?: MantenimientoMinOrderByAggregateInput
    _sum?: MantenimientoSumOrderByAggregateInput
  }

  export type MantenimientoScalarWhereWithAggregatesInput = {
    AND?: MantenimientoScalarWhereWithAggregatesInput | MantenimientoScalarWhereWithAggregatesInput[]
    OR?: MantenimientoScalarWhereWithAggregatesInput[]
    NOT?: MantenimientoScalarWhereWithAggregatesInput | MantenimientoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Mantenimiento"> | number
    vehiculoId?: IntWithAggregatesFilter<"Mantenimiento"> | number
    tipo?: EnumTipoMantenimientoWithAggregatesFilter<"Mantenimiento"> | $Enums.TipoMantenimiento
    estado?: EnumEstadoMantenimientoWithAggregatesFilter<"Mantenimiento"> | $Enums.EstadoMantenimiento
    descripcion?: StringNullableWithAggregatesFilter<"Mantenimiento"> | string | null
    taller?: StringNullableWithAggregatesFilter<"Mantenimiento"> | string | null
    esExterno?: BoolWithAggregatesFilter<"Mantenimiento"> | boolean
    costoManoObra?: DecimalWithAggregatesFilter<"Mantenimiento"> | Decimal | DecimalJsLike | number | string
    costoRepuestos?: DecimalWithAggregatesFilter<"Mantenimiento"> | Decimal | DecimalJsLike | number | string
    costoTotal?: DecimalWithAggregatesFilter<"Mantenimiento"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeWithAggregatesFilter<"Mantenimiento"> | Date | string
    fechaInicio?: DateTimeNullableWithAggregatesFilter<"Mantenimiento"> | Date | string | null
    fechaFin?: DateTimeNullableWithAggregatesFilter<"Mantenimiento"> | Date | string | null
    kilometrajeAlMomento?: IntNullableWithAggregatesFilter<"Mantenimiento"> | number | null
    proximaFecha?: DateTimeNullableWithAggregatesFilter<"Mantenimiento"> | Date | string | null
    proximoKilometraje?: IntNullableWithAggregatesFilter<"Mantenimiento"> | number | null
    comprobanteId?: IntNullableWithAggregatesFilter<"Mantenimiento"> | number | null
    creadoEn?: DateTimeWithAggregatesFilter<"Mantenimiento"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"Mantenimiento"> | Date | string
  }

  export type PagoChoferWhereInput = {
    AND?: PagoChoferWhereInput | PagoChoferWhereInput[]
    OR?: PagoChoferWhereInput[]
    NOT?: PagoChoferWhereInput | PagoChoferWhereInput[]
    id?: IntFilter<"PagoChofer"> | number
    choferId?: IntFilter<"PagoChofer"> | number
    monto?: DecimalFilter<"PagoChofer"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter<"PagoChofer"> | Date | string
    metodoPago?: EnumMetodoPagoFilter<"PagoChofer"> | $Enums.MetodoPago
    descripcion?: StringNullableFilter<"PagoChofer"> | string | null
    estado?: EnumEstadoPagoChoferFilter<"PagoChofer"> | $Enums.EstadoPagoChofer
    fechaPagoReal?: DateTimeNullableFilter<"PagoChofer"> | Date | string | null
    comprobanteId?: IntNullableFilter<"PagoChofer"> | number | null
    viajeId?: IntNullableFilter<"PagoChofer"> | number | null
    creadoEn?: DateTimeFilter<"PagoChofer"> | Date | string
    actualizadoEn?: DateTimeFilter<"PagoChofer"> | Date | string
    chofer?: XOR<ChoferRelationFilter, ChoferWhereInput>
    comprobante?: XOR<ComprobanteNullableRelationFilter, ComprobanteWhereInput> | null
    viaje?: XOR<ViajeNullableRelationFilter, ViajeWhereInput> | null
  }

  export type PagoChoferOrderByWithRelationInput = {
    id?: SortOrder
    choferId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    metodoPago?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    estado?: SortOrder
    fechaPagoReal?: SortOrderInput | SortOrder
    comprobanteId?: SortOrderInput | SortOrder
    viajeId?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    chofer?: ChoferOrderByWithRelationInput
    comprobante?: ComprobanteOrderByWithRelationInput
    viaje?: ViajeOrderByWithRelationInput
  }

  export type PagoChoferWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PagoChoferWhereInput | PagoChoferWhereInput[]
    OR?: PagoChoferWhereInput[]
    NOT?: PagoChoferWhereInput | PagoChoferWhereInput[]
    choferId?: IntFilter<"PagoChofer"> | number
    monto?: DecimalFilter<"PagoChofer"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter<"PagoChofer"> | Date | string
    metodoPago?: EnumMetodoPagoFilter<"PagoChofer"> | $Enums.MetodoPago
    descripcion?: StringNullableFilter<"PagoChofer"> | string | null
    estado?: EnumEstadoPagoChoferFilter<"PagoChofer"> | $Enums.EstadoPagoChofer
    fechaPagoReal?: DateTimeNullableFilter<"PagoChofer"> | Date | string | null
    comprobanteId?: IntNullableFilter<"PagoChofer"> | number | null
    viajeId?: IntNullableFilter<"PagoChofer"> | number | null
    creadoEn?: DateTimeFilter<"PagoChofer"> | Date | string
    actualizadoEn?: DateTimeFilter<"PagoChofer"> | Date | string
    chofer?: XOR<ChoferRelationFilter, ChoferWhereInput>
    comprobante?: XOR<ComprobanteNullableRelationFilter, ComprobanteWhereInput> | null
    viaje?: XOR<ViajeNullableRelationFilter, ViajeWhereInput> | null
  }, "id">

  export type PagoChoferOrderByWithAggregationInput = {
    id?: SortOrder
    choferId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    metodoPago?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    estado?: SortOrder
    fechaPagoReal?: SortOrderInput | SortOrder
    comprobanteId?: SortOrderInput | SortOrder
    viajeId?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: PagoChoferCountOrderByAggregateInput
    _avg?: PagoChoferAvgOrderByAggregateInput
    _max?: PagoChoferMaxOrderByAggregateInput
    _min?: PagoChoferMinOrderByAggregateInput
    _sum?: PagoChoferSumOrderByAggregateInput
  }

  export type PagoChoferScalarWhereWithAggregatesInput = {
    AND?: PagoChoferScalarWhereWithAggregatesInput | PagoChoferScalarWhereWithAggregatesInput[]
    OR?: PagoChoferScalarWhereWithAggregatesInput[]
    NOT?: PagoChoferScalarWhereWithAggregatesInput | PagoChoferScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PagoChofer"> | number
    choferId?: IntWithAggregatesFilter<"PagoChofer"> | number
    monto?: DecimalWithAggregatesFilter<"PagoChofer"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeWithAggregatesFilter<"PagoChofer"> | Date | string
    metodoPago?: EnumMetodoPagoWithAggregatesFilter<"PagoChofer"> | $Enums.MetodoPago
    descripcion?: StringNullableWithAggregatesFilter<"PagoChofer"> | string | null
    estado?: EnumEstadoPagoChoferWithAggregatesFilter<"PagoChofer"> | $Enums.EstadoPagoChofer
    fechaPagoReal?: DateTimeNullableWithAggregatesFilter<"PagoChofer"> | Date | string | null
    comprobanteId?: IntNullableWithAggregatesFilter<"PagoChofer"> | number | null
    viajeId?: IntNullableWithAggregatesFilter<"PagoChofer"> | number | null
    creadoEn?: DateTimeWithAggregatesFilter<"PagoChofer"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"PagoChofer"> | Date | string
  }

  export type RegistroAuditoriaWhereInput = {
    AND?: RegistroAuditoriaWhereInput | RegistroAuditoriaWhereInput[]
    OR?: RegistroAuditoriaWhereInput[]
    NOT?: RegistroAuditoriaWhereInput | RegistroAuditoriaWhereInput[]
    id?: IntFilter<"RegistroAuditoria"> | number
    usuarioId?: IntFilter<"RegistroAuditoria"> | number
    accion?: EnumAccionAuditoriaFilter<"RegistroAuditoria"> | $Enums.AccionAuditoria
    entidad?: StringFilter<"RegistroAuditoria"> | string
    entidadId?: IntFilter<"RegistroAuditoria"> | number
    datosAnteriores?: JsonNullableFilter<"RegistroAuditoria">
    datosNuevos?: JsonNullableFilter<"RegistroAuditoria">
    fechaHora?: DateTimeFilter<"RegistroAuditoria"> | Date | string
    ipAddress?: StringNullableFilter<"RegistroAuditoria"> | string | null
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type RegistroAuditoriaOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    datosAnteriores?: SortOrderInput | SortOrder
    datosNuevos?: SortOrderInput | SortOrder
    fechaHora?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type RegistroAuditoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RegistroAuditoriaWhereInput | RegistroAuditoriaWhereInput[]
    OR?: RegistroAuditoriaWhereInput[]
    NOT?: RegistroAuditoriaWhereInput | RegistroAuditoriaWhereInput[]
    usuarioId?: IntFilter<"RegistroAuditoria"> | number
    accion?: EnumAccionAuditoriaFilter<"RegistroAuditoria"> | $Enums.AccionAuditoria
    entidad?: StringFilter<"RegistroAuditoria"> | string
    entidadId?: IntFilter<"RegistroAuditoria"> | number
    datosAnteriores?: JsonNullableFilter<"RegistroAuditoria">
    datosNuevos?: JsonNullableFilter<"RegistroAuditoria">
    fechaHora?: DateTimeFilter<"RegistroAuditoria"> | Date | string
    ipAddress?: StringNullableFilter<"RegistroAuditoria"> | string | null
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type RegistroAuditoriaOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    datosAnteriores?: SortOrderInput | SortOrder
    datosNuevos?: SortOrderInput | SortOrder
    fechaHora?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    _count?: RegistroAuditoriaCountOrderByAggregateInput
    _avg?: RegistroAuditoriaAvgOrderByAggregateInput
    _max?: RegistroAuditoriaMaxOrderByAggregateInput
    _min?: RegistroAuditoriaMinOrderByAggregateInput
    _sum?: RegistroAuditoriaSumOrderByAggregateInput
  }

  export type RegistroAuditoriaScalarWhereWithAggregatesInput = {
    AND?: RegistroAuditoriaScalarWhereWithAggregatesInput | RegistroAuditoriaScalarWhereWithAggregatesInput[]
    OR?: RegistroAuditoriaScalarWhereWithAggregatesInput[]
    NOT?: RegistroAuditoriaScalarWhereWithAggregatesInput | RegistroAuditoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RegistroAuditoria"> | number
    usuarioId?: IntWithAggregatesFilter<"RegistroAuditoria"> | number
    accion?: EnumAccionAuditoriaWithAggregatesFilter<"RegistroAuditoria"> | $Enums.AccionAuditoria
    entidad?: StringWithAggregatesFilter<"RegistroAuditoria"> | string
    entidadId?: IntWithAggregatesFilter<"RegistroAuditoria"> | number
    datosAnteriores?: JsonNullableWithAggregatesFilter<"RegistroAuditoria">
    datosNuevos?: JsonNullableWithAggregatesFilter<"RegistroAuditoria">
    fechaHora?: DateTimeWithAggregatesFilter<"RegistroAuditoria"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"RegistroAuditoria"> | string | null
  }

  export type UsuarioCreateInput = {
    nombreUsuario: string
    email: string
    passwordHash: string
    nombreCompleto: string
    rol?: $Enums.RolUsuario
    activo?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    registrosAuditoria?: RegistroAuditoriaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    nombreUsuario: string
    email: string
    passwordHash: string
    nombreCompleto: string
    rol?: $Enums.RolUsuario
    activo?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    registrosAuditoria?: RegistroAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolUsuarioFieldUpdateOperationsInput | $Enums.RolUsuario
    activo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrosAuditoria?: RegistroAuditoriaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolUsuarioFieldUpdateOperationsInput | $Enums.RolUsuario
    activo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrosAuditoria?: RegistroAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    nombreUsuario: string
    email: string
    passwordHash: string
    nombreCompleto: string
    rol?: $Enums.RolUsuario
    activo?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
  }

  export type UsuarioUpdateManyMutationInput = {
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolUsuarioFieldUpdateOperationsInput | $Enums.RolUsuario
    activo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolUsuarioFieldUpdateOperationsInput | $Enums.RolUsuario
    activo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VehiculoCreateInput = {
    placa: string
    marca: string
    modelo: string
    anio: number
    tipo: string
    capacidad: string
    estado?: $Enums.EstadoVehiculo
    kilometrajeActual?: number
    fechaUltimoMantenimiento?: Date | string | null
    fechaProximoMantenimiento?: Date | string | null
    fechaVencimientoSoat?: Date | string | null
    fechaVencimientoSeguro?: Date | string | null
    fechaVencimientoMatricula?: Date | string | null
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    viajes?: ViajeCreateNestedManyWithoutVehiculoInput
    mantenimientos?: MantenimientoCreateNestedManyWithoutVehiculoInput
  }

  export type VehiculoUncheckedCreateInput = {
    id?: number
    placa: string
    marca: string
    modelo: string
    anio: number
    tipo: string
    capacidad: string
    estado?: $Enums.EstadoVehiculo
    kilometrajeActual?: number
    fechaUltimoMantenimiento?: Date | string | null
    fechaProximoMantenimiento?: Date | string | null
    fechaVencimientoSoat?: Date | string | null
    fechaVencimientoSeguro?: Date | string | null
    fechaVencimientoMatricula?: Date | string | null
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    viajes?: ViajeUncheckedCreateNestedManyWithoutVehiculoInput
    mantenimientos?: MantenimientoUncheckedCreateNestedManyWithoutVehiculoInput
  }

  export type VehiculoUpdateInput = {
    placa?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    capacidad?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoVehiculoFieldUpdateOperationsInput | $Enums.EstadoVehiculo
    kilometrajeActual?: IntFieldUpdateOperationsInput | number
    fechaUltimoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaProximoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSoat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSeguro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoMatricula?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: ViajeUpdateManyWithoutVehiculoNestedInput
    mantenimientos?: MantenimientoUpdateManyWithoutVehiculoNestedInput
  }

  export type VehiculoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    placa?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    capacidad?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoVehiculoFieldUpdateOperationsInput | $Enums.EstadoVehiculo
    kilometrajeActual?: IntFieldUpdateOperationsInput | number
    fechaUltimoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaProximoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSoat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSeguro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoMatricula?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: ViajeUncheckedUpdateManyWithoutVehiculoNestedInput
    mantenimientos?: MantenimientoUncheckedUpdateManyWithoutVehiculoNestedInput
  }

  export type VehiculoCreateManyInput = {
    id?: number
    placa: string
    marca: string
    modelo: string
    anio: number
    tipo: string
    capacidad: string
    estado?: $Enums.EstadoVehiculo
    kilometrajeActual?: number
    fechaUltimoMantenimiento?: Date | string | null
    fechaProximoMantenimiento?: Date | string | null
    fechaVencimientoSoat?: Date | string | null
    fechaVencimientoSeguro?: Date | string | null
    fechaVencimientoMatricula?: Date | string | null
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
  }

  export type VehiculoUpdateManyMutationInput = {
    placa?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    capacidad?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoVehiculoFieldUpdateOperationsInput | $Enums.EstadoVehiculo
    kilometrajeActual?: IntFieldUpdateOperationsInput | number
    fechaUltimoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaProximoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSoat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSeguro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoMatricula?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VehiculoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    placa?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    capacidad?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoVehiculoFieldUpdateOperationsInput | $Enums.EstadoVehiculo
    kilometrajeActual?: IntFieldUpdateOperationsInput | number
    fechaUltimoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaProximoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSoat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSeguro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoMatricula?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoferCreateInput = {
    nombres: string
    apellidos: string
    documentoId: string
    telefono?: string | null
    fechaVencimientoLicencia?: Date | string | null
    correo?: string | null
    estado?: $Enums.EstadoChofer
    modalidadPago?: $Enums.ModalidadPago
    metodoPago?: $Enums.MetodoPago
    banco?: string | null
    numeroCuenta?: string | null
    sueldoMensual?: Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: Date | string | null
    diaPago?: number | null
    pagoQuincenal?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    viajes?: ViajeCreateNestedManyWithoutChoferInput
    pagos?: PagoChoferCreateNestedManyWithoutChoferInput
  }

  export type ChoferUncheckedCreateInput = {
    id?: number
    nombres: string
    apellidos: string
    documentoId: string
    telefono?: string | null
    fechaVencimientoLicencia?: Date | string | null
    correo?: string | null
    estado?: $Enums.EstadoChofer
    modalidadPago?: $Enums.ModalidadPago
    metodoPago?: $Enums.MetodoPago
    banco?: string | null
    numeroCuenta?: string | null
    sueldoMensual?: Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: Date | string | null
    diaPago?: number | null
    pagoQuincenal?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    viajes?: ViajeUncheckedCreateNestedManyWithoutChoferInput
    pagos?: PagoChoferUncheckedCreateNestedManyWithoutChoferInput
  }

  export type ChoferUpdateInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaVencimientoLicencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoChoferFieldUpdateOperationsInput | $Enums.EstadoChofer
    modalidadPago?: EnumModalidadPagoFieldUpdateOperationsInput | $Enums.ModalidadPago
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    banco?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCuenta?: NullableStringFieldUpdateOperationsInput | string | null
    sueldoMensual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diaPago?: NullableIntFieldUpdateOperationsInput | number | null
    pagoQuincenal?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: ViajeUpdateManyWithoutChoferNestedInput
    pagos?: PagoChoferUpdateManyWithoutChoferNestedInput
  }

  export type ChoferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaVencimientoLicencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoChoferFieldUpdateOperationsInput | $Enums.EstadoChofer
    modalidadPago?: EnumModalidadPagoFieldUpdateOperationsInput | $Enums.ModalidadPago
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    banco?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCuenta?: NullableStringFieldUpdateOperationsInput | string | null
    sueldoMensual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diaPago?: NullableIntFieldUpdateOperationsInput | number | null
    pagoQuincenal?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: ViajeUncheckedUpdateManyWithoutChoferNestedInput
    pagos?: PagoChoferUncheckedUpdateManyWithoutChoferNestedInput
  }

  export type ChoferCreateManyInput = {
    id?: number
    nombres: string
    apellidos: string
    documentoId: string
    telefono?: string | null
    fechaVencimientoLicencia?: Date | string | null
    correo?: string | null
    estado?: $Enums.EstadoChofer
    modalidadPago?: $Enums.ModalidadPago
    metodoPago?: $Enums.MetodoPago
    banco?: string | null
    numeroCuenta?: string | null
    sueldoMensual?: Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: Date | string | null
    diaPago?: number | null
    pagoQuincenal?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChoferUpdateManyMutationInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaVencimientoLicencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoChoferFieldUpdateOperationsInput | $Enums.EstadoChofer
    modalidadPago?: EnumModalidadPagoFieldUpdateOperationsInput | $Enums.ModalidadPago
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    banco?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCuenta?: NullableStringFieldUpdateOperationsInput | string | null
    sueldoMensual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diaPago?: NullableIntFieldUpdateOperationsInput | number | null
    pagoQuincenal?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaVencimientoLicencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoChoferFieldUpdateOperationsInput | $Enums.EstadoChofer
    modalidadPago?: EnumModalidadPagoFieldUpdateOperationsInput | $Enums.ModalidadPago
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    banco?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCuenta?: NullableStringFieldUpdateOperationsInput | string | null
    sueldoMensual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diaPago?: NullableIntFieldUpdateOperationsInput | number | null
    pagoQuincenal?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClienteCreateInput = {
    nombreRazonSocial: string
    documentoId: string
    telefono?: string | null
    correo?: string | null
    direccion?: string | null
    sector?: string | null
    estado?: $Enums.EstadoCliente
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    viajes?: ViajeCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateInput = {
    id?: number
    nombreRazonSocial: string
    documentoId: string
    telefono?: string | null
    correo?: string | null
    direccion?: string | null
    sector?: string | null
    estado?: $Enums.EstadoCliente
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    viajes?: ViajeUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteUpdateInput = {
    nombreRazonSocial?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoClienteFieldUpdateOperationsInput | $Enums.EstadoCliente
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: ViajeUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreRazonSocial?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoClienteFieldUpdateOperationsInput | $Enums.EstadoCliente
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: ViajeUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteCreateManyInput = {
    id?: number
    nombreRazonSocial: string
    documentoId: string
    telefono?: string | null
    correo?: string | null
    direccion?: string | null
    sector?: string | null
    estado?: $Enums.EstadoCliente
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
  }

  export type ClienteUpdateManyMutationInput = {
    nombreRazonSocial?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoClienteFieldUpdateOperationsInput | $Enums.EstadoCliente
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClienteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreRazonSocial?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoClienteFieldUpdateOperationsInput | $Enums.EstadoCliente
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaterialCreateInput = {
    nombre: string
    unidadMedida: string
    esPeligroso?: boolean
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    viajes?: ViajeCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: number
    nombre: string
    unidadMedida: string
    esPeligroso?: boolean
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    viajes?: ViajeUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidadMedida?: StringFieldUpdateOperationsInput | string
    esPeligroso?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    viajes?: ViajeUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidadMedida?: StringFieldUpdateOperationsInput | string
    esPeligroso?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    viajes?: ViajeUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialCreateManyInput = {
    id?: number
    nombre: string
    unidadMedida: string
    esPeligroso?: boolean
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type MaterialUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidadMedida?: StringFieldUpdateOperationsInput | string
    esPeligroso?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidadMedida?: StringFieldUpdateOperationsInput | string
    esPeligroso?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViajeCreateInput = {
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    vehiculo: VehiculoCreateNestedOneWithoutViajesInput
    chofer: ChoferCreateNestedOneWithoutViajesInput
    cliente: ClienteCreateNestedOneWithoutViajesInput
    material: MaterialCreateNestedOneWithoutViajesInput
    gastos?: GastoViajeCreateNestedManyWithoutViajeInput
    pagos?: PagoChoferCreateNestedManyWithoutViajeInput
  }

  export type ViajeUncheckedCreateInput = {
    id?: number
    vehiculoId: number
    choferId: number
    clienteId: number
    materialId: number
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    gastos?: GastoViajeUncheckedCreateNestedManyWithoutViajeInput
    pagos?: PagoChoferUncheckedCreateNestedManyWithoutViajeInput
  }

  export type ViajeUpdateInput = {
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    vehiculo?: VehiculoUpdateOneRequiredWithoutViajesNestedInput
    chofer?: ChoferUpdateOneRequiredWithoutViajesNestedInput
    cliente?: ClienteUpdateOneRequiredWithoutViajesNestedInput
    material?: MaterialUpdateOneRequiredWithoutViajesNestedInput
    gastos?: GastoViajeUpdateManyWithoutViajeNestedInput
    pagos?: PagoChoferUpdateManyWithoutViajeNestedInput
  }

  export type ViajeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehiculoId?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    gastos?: GastoViajeUncheckedUpdateManyWithoutViajeNestedInput
    pagos?: PagoChoferUncheckedUpdateManyWithoutViajeNestedInput
  }

  export type ViajeCreateManyInput = {
    id?: number
    vehiculoId: number
    choferId: number
    clienteId: number
    materialId: number
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type ViajeUpdateManyMutationInput = {
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViajeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehiculoId?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GastoViajeCreateInput = {
    tipoGasto: $Enums.TipoGasto
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    viaje: ViajeCreateNestedOneWithoutGastosInput
    comprobante?: ComprobanteCreateNestedOneWithoutGastosViajeInput
  }

  export type GastoViajeUncheckedCreateInput = {
    id?: number
    viajeId: number
    tipoGasto: $Enums.TipoGasto
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    comprobanteId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type GastoViajeUpdateInput = {
    tipoGasto?: EnumTipoGastoFieldUpdateOperationsInput | $Enums.TipoGasto
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    viaje?: ViajeUpdateOneRequiredWithoutGastosNestedInput
    comprobante?: ComprobanteUpdateOneWithoutGastosViajeNestedInput
  }

  export type GastoViajeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    viajeId?: IntFieldUpdateOperationsInput | number
    tipoGasto?: EnumTipoGastoFieldUpdateOperationsInput | $Enums.TipoGasto
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    comprobanteId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GastoViajeCreateManyInput = {
    id?: number
    viajeId: number
    tipoGasto: $Enums.TipoGasto
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    comprobanteId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type GastoViajeUpdateManyMutationInput = {
    tipoGasto?: EnumTipoGastoFieldUpdateOperationsInput | $Enums.TipoGasto
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GastoViajeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    viajeId?: IntFieldUpdateOperationsInput | number
    tipoGasto?: EnumTipoGastoFieldUpdateOperationsInput | $Enums.TipoGasto
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    comprobanteId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComprobanteCreateInput = {
    tipo: $Enums.TipoComprobante
    referenciaId?: number | null
    url: string
    publicId: string
    nombreArchivoOriginal: string
    creadoEn?: Date | string
    gastosViaje?: GastoViajeCreateNestedManyWithoutComprobanteInput
    mantenimientos?: MantenimientoCreateNestedManyWithoutComprobanteInput
    pagosChofer?: PagoChoferCreateNestedManyWithoutComprobanteInput
  }

  export type ComprobanteUncheckedCreateInput = {
    id?: number
    tipo: $Enums.TipoComprobante
    referenciaId?: number | null
    url: string
    publicId: string
    nombreArchivoOriginal: string
    creadoEn?: Date | string
    gastosViaje?: GastoViajeUncheckedCreateNestedManyWithoutComprobanteInput
    mantenimientos?: MantenimientoUncheckedCreateNestedManyWithoutComprobanteInput
    pagosChofer?: PagoChoferUncheckedCreateNestedManyWithoutComprobanteInput
  }

  export type ComprobanteUpdateInput = {
    tipo?: EnumTipoComprobanteFieldUpdateOperationsInput | $Enums.TipoComprobante
    referenciaId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    nombreArchivoOriginal?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    gastosViaje?: GastoViajeUpdateManyWithoutComprobanteNestedInput
    mantenimientos?: MantenimientoUpdateManyWithoutComprobanteNestedInput
    pagosChofer?: PagoChoferUpdateManyWithoutComprobanteNestedInput
  }

  export type ComprobanteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoComprobanteFieldUpdateOperationsInput | $Enums.TipoComprobante
    referenciaId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    nombreArchivoOriginal?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    gastosViaje?: GastoViajeUncheckedUpdateManyWithoutComprobanteNestedInput
    mantenimientos?: MantenimientoUncheckedUpdateManyWithoutComprobanteNestedInput
    pagosChofer?: PagoChoferUncheckedUpdateManyWithoutComprobanteNestedInput
  }

  export type ComprobanteCreateManyInput = {
    id?: number
    tipo: $Enums.TipoComprobante
    referenciaId?: number | null
    url: string
    publicId: string
    nombreArchivoOriginal: string
    creadoEn?: Date | string
  }

  export type ComprobanteUpdateManyMutationInput = {
    tipo?: EnumTipoComprobanteFieldUpdateOperationsInput | $Enums.TipoComprobante
    referenciaId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    nombreArchivoOriginal?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComprobanteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoComprobanteFieldUpdateOperationsInput | $Enums.TipoComprobante
    referenciaId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    nombreArchivoOriginal?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MantenimientoCreateInput = {
    tipo: $Enums.TipoMantenimiento
    estado?: $Enums.EstadoMantenimiento
    descripcion?: string | null
    taller?: string | null
    esExterno?: boolean
    costoManoObra?: Decimal | DecimalJsLike | number | string
    costoRepuestos?: Decimal | DecimalJsLike | number | string
    costoTotal?: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    kilometrajeAlMomento?: number | null
    proximaFecha?: Date | string | null
    proximoKilometraje?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    vehiculo: VehiculoCreateNestedOneWithoutMantenimientosInput
    comprobante?: ComprobanteCreateNestedOneWithoutMantenimientosInput
  }

  export type MantenimientoUncheckedCreateInput = {
    id?: number
    vehiculoId: number
    tipo: $Enums.TipoMantenimiento
    estado?: $Enums.EstadoMantenimiento
    descripcion?: string | null
    taller?: string | null
    esExterno?: boolean
    costoManoObra?: Decimal | DecimalJsLike | number | string
    costoRepuestos?: Decimal | DecimalJsLike | number | string
    costoTotal?: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    kilometrajeAlMomento?: number | null
    proximaFecha?: Date | string | null
    proximoKilometraje?: number | null
    comprobanteId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type MantenimientoUpdateInput = {
    tipo?: EnumTipoMantenimientoFieldUpdateOperationsInput | $Enums.TipoMantenimiento
    estado?: EnumEstadoMantenimientoFieldUpdateOperationsInput | $Enums.EstadoMantenimiento
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    taller?: NullableStringFieldUpdateOperationsInput | string | null
    esExterno?: BoolFieldUpdateOperationsInput | boolean
    costoManoObra?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoRepuestos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrajeAlMomento?: NullableIntFieldUpdateOperationsInput | number | null
    proximaFecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proximoKilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    vehiculo?: VehiculoUpdateOneRequiredWithoutMantenimientosNestedInput
    comprobante?: ComprobanteUpdateOneWithoutMantenimientosNestedInput
  }

  export type MantenimientoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehiculoId?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoMantenimientoFieldUpdateOperationsInput | $Enums.TipoMantenimiento
    estado?: EnumEstadoMantenimientoFieldUpdateOperationsInput | $Enums.EstadoMantenimiento
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    taller?: NullableStringFieldUpdateOperationsInput | string | null
    esExterno?: BoolFieldUpdateOperationsInput | boolean
    costoManoObra?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoRepuestos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrajeAlMomento?: NullableIntFieldUpdateOperationsInput | number | null
    proximaFecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proximoKilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    comprobanteId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MantenimientoCreateManyInput = {
    id?: number
    vehiculoId: number
    tipo: $Enums.TipoMantenimiento
    estado?: $Enums.EstadoMantenimiento
    descripcion?: string | null
    taller?: string | null
    esExterno?: boolean
    costoManoObra?: Decimal | DecimalJsLike | number | string
    costoRepuestos?: Decimal | DecimalJsLike | number | string
    costoTotal?: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    kilometrajeAlMomento?: number | null
    proximaFecha?: Date | string | null
    proximoKilometraje?: number | null
    comprobanteId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type MantenimientoUpdateManyMutationInput = {
    tipo?: EnumTipoMantenimientoFieldUpdateOperationsInput | $Enums.TipoMantenimiento
    estado?: EnumEstadoMantenimientoFieldUpdateOperationsInput | $Enums.EstadoMantenimiento
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    taller?: NullableStringFieldUpdateOperationsInput | string | null
    esExterno?: BoolFieldUpdateOperationsInput | boolean
    costoManoObra?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoRepuestos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrajeAlMomento?: NullableIntFieldUpdateOperationsInput | number | null
    proximaFecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proximoKilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MantenimientoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehiculoId?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoMantenimientoFieldUpdateOperationsInput | $Enums.TipoMantenimiento
    estado?: EnumEstadoMantenimientoFieldUpdateOperationsInput | $Enums.EstadoMantenimiento
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    taller?: NullableStringFieldUpdateOperationsInput | string | null
    esExterno?: BoolFieldUpdateOperationsInput | boolean
    costoManoObra?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoRepuestos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrajeAlMomento?: NullableIntFieldUpdateOperationsInput | number | null
    proximaFecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proximoKilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    comprobanteId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoChoferCreateInput = {
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    estado?: $Enums.EstadoPagoChofer
    fechaPagoReal?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    chofer: ChoferCreateNestedOneWithoutPagosInput
    comprobante?: ComprobanteCreateNestedOneWithoutPagosChoferInput
    viaje?: ViajeCreateNestedOneWithoutPagosInput
  }

  export type PagoChoferUncheckedCreateInput = {
    id?: number
    choferId: number
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    estado?: $Enums.EstadoPagoChofer
    fechaPagoReal?: Date | string | null
    comprobanteId?: number | null
    viajeId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type PagoChoferUpdateInput = {
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoPagoChoferFieldUpdateOperationsInput | $Enums.EstadoPagoChofer
    fechaPagoReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    chofer?: ChoferUpdateOneRequiredWithoutPagosNestedInput
    comprobante?: ComprobanteUpdateOneWithoutPagosChoferNestedInput
    viaje?: ViajeUpdateOneWithoutPagosNestedInput
  }

  export type PagoChoferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoPagoChoferFieldUpdateOperationsInput | $Enums.EstadoPagoChofer
    fechaPagoReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comprobanteId?: NullableIntFieldUpdateOperationsInput | number | null
    viajeId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoChoferCreateManyInput = {
    id?: number
    choferId: number
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    estado?: $Enums.EstadoPagoChofer
    fechaPagoReal?: Date | string | null
    comprobanteId?: number | null
    viajeId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type PagoChoferUpdateManyMutationInput = {
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoPagoChoferFieldUpdateOperationsInput | $Enums.EstadoPagoChofer
    fechaPagoReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoChoferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoPagoChoferFieldUpdateOperationsInput | $Enums.EstadoPagoChofer
    fechaPagoReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comprobanteId?: NullableIntFieldUpdateOperationsInput | number | null
    viajeId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegistroAuditoriaCreateInput = {
    accion: $Enums.AccionAuditoria
    entidad: string
    entidadId: number
    datosAnteriores?: NullableJsonNullValueInput | InputJsonValue
    datosNuevos?: NullableJsonNullValueInput | InputJsonValue
    fechaHora?: Date | string
    ipAddress?: string | null
    usuario: UsuarioCreateNestedOneWithoutRegistrosAuditoriaInput
  }

  export type RegistroAuditoriaUncheckedCreateInput = {
    id?: number
    usuarioId: number
    accion: $Enums.AccionAuditoria
    entidad: string
    entidadId: number
    datosAnteriores?: NullableJsonNullValueInput | InputJsonValue
    datosNuevos?: NullableJsonNullValueInput | InputJsonValue
    fechaHora?: Date | string
    ipAddress?: string | null
  }

  export type RegistroAuditoriaUpdateInput = {
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: IntFieldUpdateOperationsInput | number
    datosAnteriores?: NullableJsonNullValueInput | InputJsonValue
    datosNuevos?: NullableJsonNullValueInput | InputJsonValue
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: UsuarioUpdateOneRequiredWithoutRegistrosAuditoriaNestedInput
  }

  export type RegistroAuditoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: IntFieldUpdateOperationsInput | number
    datosAnteriores?: NullableJsonNullValueInput | InputJsonValue
    datosNuevos?: NullableJsonNullValueInput | InputJsonValue
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegistroAuditoriaCreateManyInput = {
    id?: number
    usuarioId: number
    accion: $Enums.AccionAuditoria
    entidad: string
    entidadId: number
    datosAnteriores?: NullableJsonNullValueInput | InputJsonValue
    datosNuevos?: NullableJsonNullValueInput | InputJsonValue
    fechaHora?: Date | string
    ipAddress?: string | null
  }

  export type RegistroAuditoriaUpdateManyMutationInput = {
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: IntFieldUpdateOperationsInput | number
    datosAnteriores?: NullableJsonNullValueInput | InputJsonValue
    datosNuevos?: NullableJsonNullValueInput | InputJsonValue
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegistroAuditoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: IntFieldUpdateOperationsInput | number
    datosAnteriores?: NullableJsonNullValueInput | InputJsonValue
    datosNuevos?: NullableJsonNullValueInput | InputJsonValue
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRolUsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.RolUsuario | EnumRolUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.RolUsuario[] | ListEnumRolUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolUsuario[] | ListEnumRolUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumRolUsuarioFilter<$PrismaModel> | $Enums.RolUsuario
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type RegistroAuditoriaListRelationFilter = {
    every?: RegistroAuditoriaWhereInput
    some?: RegistroAuditoriaWhereInput
    none?: RegistroAuditoriaWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RegistroAuditoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombreUsuario?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    nombreCompleto?: SortOrder
    rol?: SortOrder
    activo?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombreUsuario?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    nombreCompleto?: SortOrder
    rol?: SortOrder
    activo?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombreUsuario?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    nombreCompleto?: SortOrder
    rol?: SortOrder
    activo?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRolUsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RolUsuario | EnumRolUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.RolUsuario[] | ListEnumRolUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolUsuario[] | ListEnumRolUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumRolUsuarioWithAggregatesFilter<$PrismaModel> | $Enums.RolUsuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolUsuarioFilter<$PrismaModel>
    _max?: NestedEnumRolUsuarioFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumEstadoVehiculoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoVehiculo | EnumEstadoVehiculoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoVehiculo[] | ListEnumEstadoVehiculoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoVehiculo[] | ListEnumEstadoVehiculoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoVehiculoFilter<$PrismaModel> | $Enums.EstadoVehiculo
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ViajeListRelationFilter = {
    every?: ViajeWhereInput
    some?: ViajeWhereInput
    none?: ViajeWhereInput
  }

  export type MantenimientoListRelationFilter = {
    every?: MantenimientoWhereInput
    some?: MantenimientoWhereInput
    none?: MantenimientoWhereInput
  }

  export type ViajeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MantenimientoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehiculoCountOrderByAggregateInput = {
    id?: SortOrder
    placa?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    anio?: SortOrder
    tipo?: SortOrder
    capacidad?: SortOrder
    estado?: SortOrder
    kilometrajeActual?: SortOrder
    fechaUltimoMantenimiento?: SortOrder
    fechaProximoMantenimiento?: SortOrder
    fechaVencimientoSoat?: SortOrder
    fechaVencimientoSeguro?: SortOrder
    fechaVencimientoMatricula?: SortOrder
    observaciones?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrder
  }

  export type VehiculoAvgOrderByAggregateInput = {
    id?: SortOrder
    anio?: SortOrder
    kilometrajeActual?: SortOrder
  }

  export type VehiculoMaxOrderByAggregateInput = {
    id?: SortOrder
    placa?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    anio?: SortOrder
    tipo?: SortOrder
    capacidad?: SortOrder
    estado?: SortOrder
    kilometrajeActual?: SortOrder
    fechaUltimoMantenimiento?: SortOrder
    fechaProximoMantenimiento?: SortOrder
    fechaVencimientoSoat?: SortOrder
    fechaVencimientoSeguro?: SortOrder
    fechaVencimientoMatricula?: SortOrder
    observaciones?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrder
  }

  export type VehiculoMinOrderByAggregateInput = {
    id?: SortOrder
    placa?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    anio?: SortOrder
    tipo?: SortOrder
    capacidad?: SortOrder
    estado?: SortOrder
    kilometrajeActual?: SortOrder
    fechaUltimoMantenimiento?: SortOrder
    fechaProximoMantenimiento?: SortOrder
    fechaVencimientoSoat?: SortOrder
    fechaVencimientoSeguro?: SortOrder
    fechaVencimientoMatricula?: SortOrder
    observaciones?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrder
  }

  export type VehiculoSumOrderByAggregateInput = {
    id?: SortOrder
    anio?: SortOrder
    kilometrajeActual?: SortOrder
  }

  export type EnumEstadoVehiculoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoVehiculo | EnumEstadoVehiculoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoVehiculo[] | ListEnumEstadoVehiculoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoVehiculo[] | ListEnumEstadoVehiculoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoVehiculoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoVehiculo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoVehiculoFilter<$PrismaModel>
    _max?: NestedEnumEstadoVehiculoFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumEstadoChoferFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoChofer | EnumEstadoChoferFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoChofer[] | ListEnumEstadoChoferFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoChofer[] | ListEnumEstadoChoferFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoChoferFilter<$PrismaModel> | $Enums.EstadoChofer
  }

  export type EnumModalidadPagoFilter<$PrismaModel = never> = {
    equals?: $Enums.ModalidadPago | EnumModalidadPagoFieldRefInput<$PrismaModel>
    in?: $Enums.ModalidadPago[] | ListEnumModalidadPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModalidadPago[] | ListEnumModalidadPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumModalidadPagoFilter<$PrismaModel> | $Enums.ModalidadPago
  }

  export type EnumMetodoPagoFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoPago | EnumMetodoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodoPagoFilter<$PrismaModel> | $Enums.MetodoPago
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PagoChoferListRelationFilter = {
    every?: PagoChoferWhereInput
    some?: PagoChoferWhereInput
    none?: PagoChoferWhereInput
  }

  export type PagoChoferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChoferCountOrderByAggregateInput = {
    id?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    documentoId?: SortOrder
    telefono?: SortOrder
    fechaVencimientoLicencia?: SortOrder
    correo?: SortOrder
    estado?: SortOrder
    modalidadPago?: SortOrder
    metodoPago?: SortOrder
    banco?: SortOrder
    numeroCuenta?: SortOrder
    sueldoMensual?: SortOrder
    fechaContratacion?: SortOrder
    diaPago?: SortOrder
    pagoQuincenal?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChoferAvgOrderByAggregateInput = {
    id?: SortOrder
    sueldoMensual?: SortOrder
    diaPago?: SortOrder
  }

  export type ChoferMaxOrderByAggregateInput = {
    id?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    documentoId?: SortOrder
    telefono?: SortOrder
    fechaVencimientoLicencia?: SortOrder
    correo?: SortOrder
    estado?: SortOrder
    modalidadPago?: SortOrder
    metodoPago?: SortOrder
    banco?: SortOrder
    numeroCuenta?: SortOrder
    sueldoMensual?: SortOrder
    fechaContratacion?: SortOrder
    diaPago?: SortOrder
    pagoQuincenal?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChoferMinOrderByAggregateInput = {
    id?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    documentoId?: SortOrder
    telefono?: SortOrder
    fechaVencimientoLicencia?: SortOrder
    correo?: SortOrder
    estado?: SortOrder
    modalidadPago?: SortOrder
    metodoPago?: SortOrder
    banco?: SortOrder
    numeroCuenta?: SortOrder
    sueldoMensual?: SortOrder
    fechaContratacion?: SortOrder
    diaPago?: SortOrder
    pagoQuincenal?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChoferSumOrderByAggregateInput = {
    id?: SortOrder
    sueldoMensual?: SortOrder
    diaPago?: SortOrder
  }

  export type EnumEstadoChoferWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoChofer | EnumEstadoChoferFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoChofer[] | ListEnumEstadoChoferFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoChofer[] | ListEnumEstadoChoferFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoChoferWithAggregatesFilter<$PrismaModel> | $Enums.EstadoChofer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoChoferFilter<$PrismaModel>
    _max?: NestedEnumEstadoChoferFilter<$PrismaModel>
  }

  export type EnumModalidadPagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModalidadPago | EnumModalidadPagoFieldRefInput<$PrismaModel>
    in?: $Enums.ModalidadPago[] | ListEnumModalidadPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModalidadPago[] | ListEnumModalidadPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumModalidadPagoWithAggregatesFilter<$PrismaModel> | $Enums.ModalidadPago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModalidadPagoFilter<$PrismaModel>
    _max?: NestedEnumModalidadPagoFilter<$PrismaModel>
  }

  export type EnumMetodoPagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoPago | EnumMetodoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodoPagoWithAggregatesFilter<$PrismaModel> | $Enums.MetodoPago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetodoPagoFilter<$PrismaModel>
    _max?: NestedEnumMetodoPagoFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumEstadoClienteFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoCliente | EnumEstadoClienteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoCliente[] | ListEnumEstadoClienteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoCliente[] | ListEnumEstadoClienteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoClienteFilter<$PrismaModel> | $Enums.EstadoCliente
  }

  export type ClienteCountOrderByAggregateInput = {
    id?: SortOrder
    nombreRazonSocial?: SortOrder
    documentoId?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    direccion?: SortOrder
    sector?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrder
  }

  export type ClienteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClienteMaxOrderByAggregateInput = {
    id?: SortOrder
    nombreRazonSocial?: SortOrder
    documentoId?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    direccion?: SortOrder
    sector?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrder
  }

  export type ClienteMinOrderByAggregateInput = {
    id?: SortOrder
    nombreRazonSocial?: SortOrder
    documentoId?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    direccion?: SortOrder
    sector?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    deletedAt?: SortOrder
  }

  export type ClienteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumEstadoClienteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoCliente | EnumEstadoClienteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoCliente[] | ListEnumEstadoClienteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoCliente[] | ListEnumEstadoClienteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoClienteWithAggregatesFilter<$PrismaModel> | $Enums.EstadoCliente
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoClienteFilter<$PrismaModel>
    _max?: NestedEnumEstadoClienteFilter<$PrismaModel>
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    unidadMedida?: SortOrder
    esPeligroso?: SortOrder
    descripcion?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type MaterialAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    unidadMedida?: SortOrder
    esPeligroso?: SortOrder
    descripcion?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    unidadMedida?: SortOrder
    esPeligroso?: SortOrder
    descripcion?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type MaterialSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumEstadoPagoClienteFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPagoCliente | EnumEstadoPagoClienteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPagoCliente[] | ListEnumEstadoPagoClienteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPagoCliente[] | ListEnumEstadoPagoClienteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoClienteFilter<$PrismaModel> | $Enums.EstadoPagoCliente
  }

  export type EnumEstadoViajeFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoViaje | EnumEstadoViajeFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoViaje[] | ListEnumEstadoViajeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoViaje[] | ListEnumEstadoViajeFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoViajeFilter<$PrismaModel> | $Enums.EstadoViaje
  }

  export type VehiculoRelationFilter = {
    is?: VehiculoWhereInput
    isNot?: VehiculoWhereInput
  }

  export type ChoferRelationFilter = {
    is?: ChoferWhereInput
    isNot?: ChoferWhereInput
  }

  export type ClienteRelationFilter = {
    is?: ClienteWhereInput
    isNot?: ClienteWhereInput
  }

  export type MaterialRelationFilter = {
    is?: MaterialWhereInput
    isNot?: MaterialWhereInput
  }

  export type GastoViajeListRelationFilter = {
    every?: GastoViajeWhereInput
    some?: GastoViajeWhereInput
    none?: GastoViajeWhereInput
  }

  export type GastoViajeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ViajeCountOrderByAggregateInput = {
    id?: SortOrder
    vehiculoId?: SortOrder
    choferId?: SortOrder
    clienteId?: SortOrder
    materialId?: SortOrder
    origen?: SortOrder
    destino?: SortOrder
    fechaSalida?: SortOrder
    fechaLlegadaEstimada?: SortOrder
    fechaLlegadaReal?: SortOrder
    kilometrosEstimados?: SortOrder
    kilometrosReales?: SortOrder
    tarifa?: SortOrder
    estadoPagoCliente?: SortOrder
    montoPagadoCliente?: SortOrder
    fechaLimitePago?: SortOrder
    diasCredito?: SortOrder
    montoPagoChofer?: SortOrder
    estado?: SortOrder
    observaciones?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type ViajeAvgOrderByAggregateInput = {
    id?: SortOrder
    vehiculoId?: SortOrder
    choferId?: SortOrder
    clienteId?: SortOrder
    materialId?: SortOrder
    kilometrosEstimados?: SortOrder
    kilometrosReales?: SortOrder
    tarifa?: SortOrder
    montoPagadoCliente?: SortOrder
    diasCredito?: SortOrder
    montoPagoChofer?: SortOrder
  }

  export type ViajeMaxOrderByAggregateInput = {
    id?: SortOrder
    vehiculoId?: SortOrder
    choferId?: SortOrder
    clienteId?: SortOrder
    materialId?: SortOrder
    origen?: SortOrder
    destino?: SortOrder
    fechaSalida?: SortOrder
    fechaLlegadaEstimada?: SortOrder
    fechaLlegadaReal?: SortOrder
    kilometrosEstimados?: SortOrder
    kilometrosReales?: SortOrder
    tarifa?: SortOrder
    estadoPagoCliente?: SortOrder
    montoPagadoCliente?: SortOrder
    fechaLimitePago?: SortOrder
    diasCredito?: SortOrder
    montoPagoChofer?: SortOrder
    estado?: SortOrder
    observaciones?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type ViajeMinOrderByAggregateInput = {
    id?: SortOrder
    vehiculoId?: SortOrder
    choferId?: SortOrder
    clienteId?: SortOrder
    materialId?: SortOrder
    origen?: SortOrder
    destino?: SortOrder
    fechaSalida?: SortOrder
    fechaLlegadaEstimada?: SortOrder
    fechaLlegadaReal?: SortOrder
    kilometrosEstimados?: SortOrder
    kilometrosReales?: SortOrder
    tarifa?: SortOrder
    estadoPagoCliente?: SortOrder
    montoPagadoCliente?: SortOrder
    fechaLimitePago?: SortOrder
    diasCredito?: SortOrder
    montoPagoChofer?: SortOrder
    estado?: SortOrder
    observaciones?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type ViajeSumOrderByAggregateInput = {
    id?: SortOrder
    vehiculoId?: SortOrder
    choferId?: SortOrder
    clienteId?: SortOrder
    materialId?: SortOrder
    kilometrosEstimados?: SortOrder
    kilometrosReales?: SortOrder
    tarifa?: SortOrder
    montoPagadoCliente?: SortOrder
    diasCredito?: SortOrder
    montoPagoChofer?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumEstadoPagoClienteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPagoCliente | EnumEstadoPagoClienteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPagoCliente[] | ListEnumEstadoPagoClienteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPagoCliente[] | ListEnumEstadoPagoClienteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoClienteWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPagoCliente
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPagoClienteFilter<$PrismaModel>
    _max?: NestedEnumEstadoPagoClienteFilter<$PrismaModel>
  }

  export type EnumEstadoViajeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoViaje | EnumEstadoViajeFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoViaje[] | ListEnumEstadoViajeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoViaje[] | ListEnumEstadoViajeFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoViajeWithAggregatesFilter<$PrismaModel> | $Enums.EstadoViaje
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoViajeFilter<$PrismaModel>
    _max?: NestedEnumEstadoViajeFilter<$PrismaModel>
  }

  export type EnumTipoGastoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoGasto | EnumTipoGastoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoGasto[] | ListEnumTipoGastoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoGasto[] | ListEnumTipoGastoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoGastoFilter<$PrismaModel> | $Enums.TipoGasto
  }

  export type ViajeRelationFilter = {
    is?: ViajeWhereInput
    isNot?: ViajeWhereInput
  }

  export type ComprobanteNullableRelationFilter = {
    is?: ComprobanteWhereInput | null
    isNot?: ComprobanteWhereInput | null
  }

  export type GastoViajeCountOrderByAggregateInput = {
    id?: SortOrder
    viajeId?: SortOrder
    tipoGasto?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    metodoPago?: SortOrder
    descripcion?: SortOrder
    comprobanteId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type GastoViajeAvgOrderByAggregateInput = {
    id?: SortOrder
    viajeId?: SortOrder
    monto?: SortOrder
    comprobanteId?: SortOrder
  }

  export type GastoViajeMaxOrderByAggregateInput = {
    id?: SortOrder
    viajeId?: SortOrder
    tipoGasto?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    metodoPago?: SortOrder
    descripcion?: SortOrder
    comprobanteId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type GastoViajeMinOrderByAggregateInput = {
    id?: SortOrder
    viajeId?: SortOrder
    tipoGasto?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    metodoPago?: SortOrder
    descripcion?: SortOrder
    comprobanteId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type GastoViajeSumOrderByAggregateInput = {
    id?: SortOrder
    viajeId?: SortOrder
    monto?: SortOrder
    comprobanteId?: SortOrder
  }

  export type EnumTipoGastoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoGasto | EnumTipoGastoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoGasto[] | ListEnumTipoGastoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoGasto[] | ListEnumTipoGastoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoGastoWithAggregatesFilter<$PrismaModel> | $Enums.TipoGasto
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoGastoFilter<$PrismaModel>
    _max?: NestedEnumTipoGastoFilter<$PrismaModel>
  }

  export type EnumTipoComprobanteFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoComprobante | EnumTipoComprobanteFieldRefInput<$PrismaModel>
    in?: $Enums.TipoComprobante[] | ListEnumTipoComprobanteFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoComprobante[] | ListEnumTipoComprobanteFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoComprobanteFilter<$PrismaModel> | $Enums.TipoComprobante
  }

  export type ComprobanteCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    referenciaId?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    nombreArchivoOriginal?: SortOrder
    creadoEn?: SortOrder
  }

  export type ComprobanteAvgOrderByAggregateInput = {
    id?: SortOrder
    referenciaId?: SortOrder
  }

  export type ComprobanteMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    referenciaId?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    nombreArchivoOriginal?: SortOrder
    creadoEn?: SortOrder
  }

  export type ComprobanteMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    referenciaId?: SortOrder
    url?: SortOrder
    publicId?: SortOrder
    nombreArchivoOriginal?: SortOrder
    creadoEn?: SortOrder
  }

  export type ComprobanteSumOrderByAggregateInput = {
    id?: SortOrder
    referenciaId?: SortOrder
  }

  export type EnumTipoComprobanteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoComprobante | EnumTipoComprobanteFieldRefInput<$PrismaModel>
    in?: $Enums.TipoComprobante[] | ListEnumTipoComprobanteFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoComprobante[] | ListEnumTipoComprobanteFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoComprobanteWithAggregatesFilter<$PrismaModel> | $Enums.TipoComprobante
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoComprobanteFilter<$PrismaModel>
    _max?: NestedEnumTipoComprobanteFilter<$PrismaModel>
  }

  export type EnumTipoMantenimientoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMantenimiento | EnumTipoMantenimientoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoMantenimiento[] | ListEnumTipoMantenimientoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoMantenimiento[] | ListEnumTipoMantenimientoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoMantenimientoFilter<$PrismaModel> | $Enums.TipoMantenimiento
  }

  export type EnumEstadoMantenimientoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoMantenimiento | EnumEstadoMantenimientoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoMantenimiento[] | ListEnumEstadoMantenimientoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoMantenimiento[] | ListEnumEstadoMantenimientoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoMantenimientoFilter<$PrismaModel> | $Enums.EstadoMantenimiento
  }

  export type MantenimientoCountOrderByAggregateInput = {
    id?: SortOrder
    vehiculoId?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    descripcion?: SortOrder
    taller?: SortOrder
    esExterno?: SortOrder
    costoManoObra?: SortOrder
    costoRepuestos?: SortOrder
    costoTotal?: SortOrder
    fecha?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    kilometrajeAlMomento?: SortOrder
    proximaFecha?: SortOrder
    proximoKilometraje?: SortOrder
    comprobanteId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type MantenimientoAvgOrderByAggregateInput = {
    id?: SortOrder
    vehiculoId?: SortOrder
    costoManoObra?: SortOrder
    costoRepuestos?: SortOrder
    costoTotal?: SortOrder
    kilometrajeAlMomento?: SortOrder
    proximoKilometraje?: SortOrder
    comprobanteId?: SortOrder
  }

  export type MantenimientoMaxOrderByAggregateInput = {
    id?: SortOrder
    vehiculoId?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    descripcion?: SortOrder
    taller?: SortOrder
    esExterno?: SortOrder
    costoManoObra?: SortOrder
    costoRepuestos?: SortOrder
    costoTotal?: SortOrder
    fecha?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    kilometrajeAlMomento?: SortOrder
    proximaFecha?: SortOrder
    proximoKilometraje?: SortOrder
    comprobanteId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type MantenimientoMinOrderByAggregateInput = {
    id?: SortOrder
    vehiculoId?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    descripcion?: SortOrder
    taller?: SortOrder
    esExterno?: SortOrder
    costoManoObra?: SortOrder
    costoRepuestos?: SortOrder
    costoTotal?: SortOrder
    fecha?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    kilometrajeAlMomento?: SortOrder
    proximaFecha?: SortOrder
    proximoKilometraje?: SortOrder
    comprobanteId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type MantenimientoSumOrderByAggregateInput = {
    id?: SortOrder
    vehiculoId?: SortOrder
    costoManoObra?: SortOrder
    costoRepuestos?: SortOrder
    costoTotal?: SortOrder
    kilometrajeAlMomento?: SortOrder
    proximoKilometraje?: SortOrder
    comprobanteId?: SortOrder
  }

  export type EnumTipoMantenimientoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMantenimiento | EnumTipoMantenimientoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoMantenimiento[] | ListEnumTipoMantenimientoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoMantenimiento[] | ListEnumTipoMantenimientoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoMantenimientoWithAggregatesFilter<$PrismaModel> | $Enums.TipoMantenimiento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoMantenimientoFilter<$PrismaModel>
    _max?: NestedEnumTipoMantenimientoFilter<$PrismaModel>
  }

  export type EnumEstadoMantenimientoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoMantenimiento | EnumEstadoMantenimientoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoMantenimiento[] | ListEnumEstadoMantenimientoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoMantenimiento[] | ListEnumEstadoMantenimientoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoMantenimientoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoMantenimiento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoMantenimientoFilter<$PrismaModel>
    _max?: NestedEnumEstadoMantenimientoFilter<$PrismaModel>
  }

  export type EnumEstadoPagoChoferFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPagoChofer | EnumEstadoPagoChoferFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPagoChofer[] | ListEnumEstadoPagoChoferFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPagoChofer[] | ListEnumEstadoPagoChoferFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoChoferFilter<$PrismaModel> | $Enums.EstadoPagoChofer
  }

  export type ViajeNullableRelationFilter = {
    is?: ViajeWhereInput | null
    isNot?: ViajeWhereInput | null
  }

  export type PagoChoferCountOrderByAggregateInput = {
    id?: SortOrder
    choferId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    metodoPago?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
    fechaPagoReal?: SortOrder
    comprobanteId?: SortOrder
    viajeId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type PagoChoferAvgOrderByAggregateInput = {
    id?: SortOrder
    choferId?: SortOrder
    monto?: SortOrder
    comprobanteId?: SortOrder
    viajeId?: SortOrder
  }

  export type PagoChoferMaxOrderByAggregateInput = {
    id?: SortOrder
    choferId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    metodoPago?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
    fechaPagoReal?: SortOrder
    comprobanteId?: SortOrder
    viajeId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type PagoChoferMinOrderByAggregateInput = {
    id?: SortOrder
    choferId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    metodoPago?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
    fechaPagoReal?: SortOrder
    comprobanteId?: SortOrder
    viajeId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type PagoChoferSumOrderByAggregateInput = {
    id?: SortOrder
    choferId?: SortOrder
    monto?: SortOrder
    comprobanteId?: SortOrder
    viajeId?: SortOrder
  }

  export type EnumEstadoPagoChoferWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPagoChofer | EnumEstadoPagoChoferFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPagoChofer[] | ListEnumEstadoPagoChoferFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPagoChofer[] | ListEnumEstadoPagoChoferFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoChoferWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPagoChofer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPagoChoferFilter<$PrismaModel>
    _max?: NestedEnumEstadoPagoChoferFilter<$PrismaModel>
  }

  export type EnumAccionAuditoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionAuditoria | EnumAccionAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionAuditoriaFilter<$PrismaModel> | $Enums.AccionAuditoria
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type RegistroAuditoriaCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    datosAnteriores?: SortOrder
    datosNuevos?: SortOrder
    fechaHora?: SortOrder
    ipAddress?: SortOrder
  }

  export type RegistroAuditoriaAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    entidadId?: SortOrder
  }

  export type RegistroAuditoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    fechaHora?: SortOrder
    ipAddress?: SortOrder
  }

  export type RegistroAuditoriaMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    fechaHora?: SortOrder
    ipAddress?: SortOrder
  }

  export type RegistroAuditoriaSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    entidadId?: SortOrder
  }

  export type EnumAccionAuditoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionAuditoria | EnumAccionAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionAuditoriaWithAggregatesFilter<$PrismaModel> | $Enums.AccionAuditoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccionAuditoriaFilter<$PrismaModel>
    _max?: NestedEnumAccionAuditoriaFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type RegistroAuditoriaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<RegistroAuditoriaCreateWithoutUsuarioInput, RegistroAuditoriaUncheckedCreateWithoutUsuarioInput> | RegistroAuditoriaCreateWithoutUsuarioInput[] | RegistroAuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RegistroAuditoriaCreateOrConnectWithoutUsuarioInput | RegistroAuditoriaCreateOrConnectWithoutUsuarioInput[]
    createMany?: RegistroAuditoriaCreateManyUsuarioInputEnvelope
    connect?: RegistroAuditoriaWhereUniqueInput | RegistroAuditoriaWhereUniqueInput[]
  }

  export type RegistroAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<RegistroAuditoriaCreateWithoutUsuarioInput, RegistroAuditoriaUncheckedCreateWithoutUsuarioInput> | RegistroAuditoriaCreateWithoutUsuarioInput[] | RegistroAuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RegistroAuditoriaCreateOrConnectWithoutUsuarioInput | RegistroAuditoriaCreateOrConnectWithoutUsuarioInput[]
    createMany?: RegistroAuditoriaCreateManyUsuarioInputEnvelope
    connect?: RegistroAuditoriaWhereUniqueInput | RegistroAuditoriaWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRolUsuarioFieldUpdateOperationsInput = {
    set?: $Enums.RolUsuario
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type RegistroAuditoriaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<RegistroAuditoriaCreateWithoutUsuarioInput, RegistroAuditoriaUncheckedCreateWithoutUsuarioInput> | RegistroAuditoriaCreateWithoutUsuarioInput[] | RegistroAuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RegistroAuditoriaCreateOrConnectWithoutUsuarioInput | RegistroAuditoriaCreateOrConnectWithoutUsuarioInput[]
    upsert?: RegistroAuditoriaUpsertWithWhereUniqueWithoutUsuarioInput | RegistroAuditoriaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: RegistroAuditoriaCreateManyUsuarioInputEnvelope
    set?: RegistroAuditoriaWhereUniqueInput | RegistroAuditoriaWhereUniqueInput[]
    disconnect?: RegistroAuditoriaWhereUniqueInput | RegistroAuditoriaWhereUniqueInput[]
    delete?: RegistroAuditoriaWhereUniqueInput | RegistroAuditoriaWhereUniqueInput[]
    connect?: RegistroAuditoriaWhereUniqueInput | RegistroAuditoriaWhereUniqueInput[]
    update?: RegistroAuditoriaUpdateWithWhereUniqueWithoutUsuarioInput | RegistroAuditoriaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: RegistroAuditoriaUpdateManyWithWhereWithoutUsuarioInput | RegistroAuditoriaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: RegistroAuditoriaScalarWhereInput | RegistroAuditoriaScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RegistroAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<RegistroAuditoriaCreateWithoutUsuarioInput, RegistroAuditoriaUncheckedCreateWithoutUsuarioInput> | RegistroAuditoriaCreateWithoutUsuarioInput[] | RegistroAuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RegistroAuditoriaCreateOrConnectWithoutUsuarioInput | RegistroAuditoriaCreateOrConnectWithoutUsuarioInput[]
    upsert?: RegistroAuditoriaUpsertWithWhereUniqueWithoutUsuarioInput | RegistroAuditoriaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: RegistroAuditoriaCreateManyUsuarioInputEnvelope
    set?: RegistroAuditoriaWhereUniqueInput | RegistroAuditoriaWhereUniqueInput[]
    disconnect?: RegistroAuditoriaWhereUniqueInput | RegistroAuditoriaWhereUniqueInput[]
    delete?: RegistroAuditoriaWhereUniqueInput | RegistroAuditoriaWhereUniqueInput[]
    connect?: RegistroAuditoriaWhereUniqueInput | RegistroAuditoriaWhereUniqueInput[]
    update?: RegistroAuditoriaUpdateWithWhereUniqueWithoutUsuarioInput | RegistroAuditoriaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: RegistroAuditoriaUpdateManyWithWhereWithoutUsuarioInput | RegistroAuditoriaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: RegistroAuditoriaScalarWhereInput | RegistroAuditoriaScalarWhereInput[]
  }

  export type ViajeCreateNestedManyWithoutVehiculoInput = {
    create?: XOR<ViajeCreateWithoutVehiculoInput, ViajeUncheckedCreateWithoutVehiculoInput> | ViajeCreateWithoutVehiculoInput[] | ViajeUncheckedCreateWithoutVehiculoInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutVehiculoInput | ViajeCreateOrConnectWithoutVehiculoInput[]
    createMany?: ViajeCreateManyVehiculoInputEnvelope
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
  }

  export type MantenimientoCreateNestedManyWithoutVehiculoInput = {
    create?: XOR<MantenimientoCreateWithoutVehiculoInput, MantenimientoUncheckedCreateWithoutVehiculoInput> | MantenimientoCreateWithoutVehiculoInput[] | MantenimientoUncheckedCreateWithoutVehiculoInput[]
    connectOrCreate?: MantenimientoCreateOrConnectWithoutVehiculoInput | MantenimientoCreateOrConnectWithoutVehiculoInput[]
    createMany?: MantenimientoCreateManyVehiculoInputEnvelope
    connect?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
  }

  export type ViajeUncheckedCreateNestedManyWithoutVehiculoInput = {
    create?: XOR<ViajeCreateWithoutVehiculoInput, ViajeUncheckedCreateWithoutVehiculoInput> | ViajeCreateWithoutVehiculoInput[] | ViajeUncheckedCreateWithoutVehiculoInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutVehiculoInput | ViajeCreateOrConnectWithoutVehiculoInput[]
    createMany?: ViajeCreateManyVehiculoInputEnvelope
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
  }

  export type MantenimientoUncheckedCreateNestedManyWithoutVehiculoInput = {
    create?: XOR<MantenimientoCreateWithoutVehiculoInput, MantenimientoUncheckedCreateWithoutVehiculoInput> | MantenimientoCreateWithoutVehiculoInput[] | MantenimientoUncheckedCreateWithoutVehiculoInput[]
    connectOrCreate?: MantenimientoCreateOrConnectWithoutVehiculoInput | MantenimientoCreateOrConnectWithoutVehiculoInput[]
    createMany?: MantenimientoCreateManyVehiculoInputEnvelope
    connect?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
  }

  export type EnumEstadoVehiculoFieldUpdateOperationsInput = {
    set?: $Enums.EstadoVehiculo
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ViajeUpdateManyWithoutVehiculoNestedInput = {
    create?: XOR<ViajeCreateWithoutVehiculoInput, ViajeUncheckedCreateWithoutVehiculoInput> | ViajeCreateWithoutVehiculoInput[] | ViajeUncheckedCreateWithoutVehiculoInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutVehiculoInput | ViajeCreateOrConnectWithoutVehiculoInput[]
    upsert?: ViajeUpsertWithWhereUniqueWithoutVehiculoInput | ViajeUpsertWithWhereUniqueWithoutVehiculoInput[]
    createMany?: ViajeCreateManyVehiculoInputEnvelope
    set?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    disconnect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    delete?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    update?: ViajeUpdateWithWhereUniqueWithoutVehiculoInput | ViajeUpdateWithWhereUniqueWithoutVehiculoInput[]
    updateMany?: ViajeUpdateManyWithWhereWithoutVehiculoInput | ViajeUpdateManyWithWhereWithoutVehiculoInput[]
    deleteMany?: ViajeScalarWhereInput | ViajeScalarWhereInput[]
  }

  export type MantenimientoUpdateManyWithoutVehiculoNestedInput = {
    create?: XOR<MantenimientoCreateWithoutVehiculoInput, MantenimientoUncheckedCreateWithoutVehiculoInput> | MantenimientoCreateWithoutVehiculoInput[] | MantenimientoUncheckedCreateWithoutVehiculoInput[]
    connectOrCreate?: MantenimientoCreateOrConnectWithoutVehiculoInput | MantenimientoCreateOrConnectWithoutVehiculoInput[]
    upsert?: MantenimientoUpsertWithWhereUniqueWithoutVehiculoInput | MantenimientoUpsertWithWhereUniqueWithoutVehiculoInput[]
    createMany?: MantenimientoCreateManyVehiculoInputEnvelope
    set?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    disconnect?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    delete?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    connect?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    update?: MantenimientoUpdateWithWhereUniqueWithoutVehiculoInput | MantenimientoUpdateWithWhereUniqueWithoutVehiculoInput[]
    updateMany?: MantenimientoUpdateManyWithWhereWithoutVehiculoInput | MantenimientoUpdateManyWithWhereWithoutVehiculoInput[]
    deleteMany?: MantenimientoScalarWhereInput | MantenimientoScalarWhereInput[]
  }

  export type ViajeUncheckedUpdateManyWithoutVehiculoNestedInput = {
    create?: XOR<ViajeCreateWithoutVehiculoInput, ViajeUncheckedCreateWithoutVehiculoInput> | ViajeCreateWithoutVehiculoInput[] | ViajeUncheckedCreateWithoutVehiculoInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutVehiculoInput | ViajeCreateOrConnectWithoutVehiculoInput[]
    upsert?: ViajeUpsertWithWhereUniqueWithoutVehiculoInput | ViajeUpsertWithWhereUniqueWithoutVehiculoInput[]
    createMany?: ViajeCreateManyVehiculoInputEnvelope
    set?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    disconnect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    delete?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    update?: ViajeUpdateWithWhereUniqueWithoutVehiculoInput | ViajeUpdateWithWhereUniqueWithoutVehiculoInput[]
    updateMany?: ViajeUpdateManyWithWhereWithoutVehiculoInput | ViajeUpdateManyWithWhereWithoutVehiculoInput[]
    deleteMany?: ViajeScalarWhereInput | ViajeScalarWhereInput[]
  }

  export type MantenimientoUncheckedUpdateManyWithoutVehiculoNestedInput = {
    create?: XOR<MantenimientoCreateWithoutVehiculoInput, MantenimientoUncheckedCreateWithoutVehiculoInput> | MantenimientoCreateWithoutVehiculoInput[] | MantenimientoUncheckedCreateWithoutVehiculoInput[]
    connectOrCreate?: MantenimientoCreateOrConnectWithoutVehiculoInput | MantenimientoCreateOrConnectWithoutVehiculoInput[]
    upsert?: MantenimientoUpsertWithWhereUniqueWithoutVehiculoInput | MantenimientoUpsertWithWhereUniqueWithoutVehiculoInput[]
    createMany?: MantenimientoCreateManyVehiculoInputEnvelope
    set?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    disconnect?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    delete?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    connect?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    update?: MantenimientoUpdateWithWhereUniqueWithoutVehiculoInput | MantenimientoUpdateWithWhereUniqueWithoutVehiculoInput[]
    updateMany?: MantenimientoUpdateManyWithWhereWithoutVehiculoInput | MantenimientoUpdateManyWithWhereWithoutVehiculoInput[]
    deleteMany?: MantenimientoScalarWhereInput | MantenimientoScalarWhereInput[]
  }

  export type ViajeCreateNestedManyWithoutChoferInput = {
    create?: XOR<ViajeCreateWithoutChoferInput, ViajeUncheckedCreateWithoutChoferInput> | ViajeCreateWithoutChoferInput[] | ViajeUncheckedCreateWithoutChoferInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutChoferInput | ViajeCreateOrConnectWithoutChoferInput[]
    createMany?: ViajeCreateManyChoferInputEnvelope
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
  }

  export type PagoChoferCreateNestedManyWithoutChoferInput = {
    create?: XOR<PagoChoferCreateWithoutChoferInput, PagoChoferUncheckedCreateWithoutChoferInput> | PagoChoferCreateWithoutChoferInput[] | PagoChoferUncheckedCreateWithoutChoferInput[]
    connectOrCreate?: PagoChoferCreateOrConnectWithoutChoferInput | PagoChoferCreateOrConnectWithoutChoferInput[]
    createMany?: PagoChoferCreateManyChoferInputEnvelope
    connect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
  }

  export type ViajeUncheckedCreateNestedManyWithoutChoferInput = {
    create?: XOR<ViajeCreateWithoutChoferInput, ViajeUncheckedCreateWithoutChoferInput> | ViajeCreateWithoutChoferInput[] | ViajeUncheckedCreateWithoutChoferInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutChoferInput | ViajeCreateOrConnectWithoutChoferInput[]
    createMany?: ViajeCreateManyChoferInputEnvelope
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
  }

  export type PagoChoferUncheckedCreateNestedManyWithoutChoferInput = {
    create?: XOR<PagoChoferCreateWithoutChoferInput, PagoChoferUncheckedCreateWithoutChoferInput> | PagoChoferCreateWithoutChoferInput[] | PagoChoferUncheckedCreateWithoutChoferInput[]
    connectOrCreate?: PagoChoferCreateOrConnectWithoutChoferInput | PagoChoferCreateOrConnectWithoutChoferInput[]
    createMany?: PagoChoferCreateManyChoferInputEnvelope
    connect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
  }

  export type EnumEstadoChoferFieldUpdateOperationsInput = {
    set?: $Enums.EstadoChofer
  }

  export type EnumModalidadPagoFieldUpdateOperationsInput = {
    set?: $Enums.ModalidadPago
  }

  export type EnumMetodoPagoFieldUpdateOperationsInput = {
    set?: $Enums.MetodoPago
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ViajeUpdateManyWithoutChoferNestedInput = {
    create?: XOR<ViajeCreateWithoutChoferInput, ViajeUncheckedCreateWithoutChoferInput> | ViajeCreateWithoutChoferInput[] | ViajeUncheckedCreateWithoutChoferInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutChoferInput | ViajeCreateOrConnectWithoutChoferInput[]
    upsert?: ViajeUpsertWithWhereUniqueWithoutChoferInput | ViajeUpsertWithWhereUniqueWithoutChoferInput[]
    createMany?: ViajeCreateManyChoferInputEnvelope
    set?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    disconnect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    delete?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    update?: ViajeUpdateWithWhereUniqueWithoutChoferInput | ViajeUpdateWithWhereUniqueWithoutChoferInput[]
    updateMany?: ViajeUpdateManyWithWhereWithoutChoferInput | ViajeUpdateManyWithWhereWithoutChoferInput[]
    deleteMany?: ViajeScalarWhereInput | ViajeScalarWhereInput[]
  }

  export type PagoChoferUpdateManyWithoutChoferNestedInput = {
    create?: XOR<PagoChoferCreateWithoutChoferInput, PagoChoferUncheckedCreateWithoutChoferInput> | PagoChoferCreateWithoutChoferInput[] | PagoChoferUncheckedCreateWithoutChoferInput[]
    connectOrCreate?: PagoChoferCreateOrConnectWithoutChoferInput | PagoChoferCreateOrConnectWithoutChoferInput[]
    upsert?: PagoChoferUpsertWithWhereUniqueWithoutChoferInput | PagoChoferUpsertWithWhereUniqueWithoutChoferInput[]
    createMany?: PagoChoferCreateManyChoferInputEnvelope
    set?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    disconnect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    delete?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    connect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    update?: PagoChoferUpdateWithWhereUniqueWithoutChoferInput | PagoChoferUpdateWithWhereUniqueWithoutChoferInput[]
    updateMany?: PagoChoferUpdateManyWithWhereWithoutChoferInput | PagoChoferUpdateManyWithWhereWithoutChoferInput[]
    deleteMany?: PagoChoferScalarWhereInput | PagoChoferScalarWhereInput[]
  }

  export type ViajeUncheckedUpdateManyWithoutChoferNestedInput = {
    create?: XOR<ViajeCreateWithoutChoferInput, ViajeUncheckedCreateWithoutChoferInput> | ViajeCreateWithoutChoferInput[] | ViajeUncheckedCreateWithoutChoferInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutChoferInput | ViajeCreateOrConnectWithoutChoferInput[]
    upsert?: ViajeUpsertWithWhereUniqueWithoutChoferInput | ViajeUpsertWithWhereUniqueWithoutChoferInput[]
    createMany?: ViajeCreateManyChoferInputEnvelope
    set?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    disconnect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    delete?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    update?: ViajeUpdateWithWhereUniqueWithoutChoferInput | ViajeUpdateWithWhereUniqueWithoutChoferInput[]
    updateMany?: ViajeUpdateManyWithWhereWithoutChoferInput | ViajeUpdateManyWithWhereWithoutChoferInput[]
    deleteMany?: ViajeScalarWhereInput | ViajeScalarWhereInput[]
  }

  export type PagoChoferUncheckedUpdateManyWithoutChoferNestedInput = {
    create?: XOR<PagoChoferCreateWithoutChoferInput, PagoChoferUncheckedCreateWithoutChoferInput> | PagoChoferCreateWithoutChoferInput[] | PagoChoferUncheckedCreateWithoutChoferInput[]
    connectOrCreate?: PagoChoferCreateOrConnectWithoutChoferInput | PagoChoferCreateOrConnectWithoutChoferInput[]
    upsert?: PagoChoferUpsertWithWhereUniqueWithoutChoferInput | PagoChoferUpsertWithWhereUniqueWithoutChoferInput[]
    createMany?: PagoChoferCreateManyChoferInputEnvelope
    set?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    disconnect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    delete?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    connect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    update?: PagoChoferUpdateWithWhereUniqueWithoutChoferInput | PagoChoferUpdateWithWhereUniqueWithoutChoferInput[]
    updateMany?: PagoChoferUpdateManyWithWhereWithoutChoferInput | PagoChoferUpdateManyWithWhereWithoutChoferInput[]
    deleteMany?: PagoChoferScalarWhereInput | PagoChoferScalarWhereInput[]
  }

  export type ViajeCreateNestedManyWithoutClienteInput = {
    create?: XOR<ViajeCreateWithoutClienteInput, ViajeUncheckedCreateWithoutClienteInput> | ViajeCreateWithoutClienteInput[] | ViajeUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutClienteInput | ViajeCreateOrConnectWithoutClienteInput[]
    createMany?: ViajeCreateManyClienteInputEnvelope
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
  }

  export type ViajeUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<ViajeCreateWithoutClienteInput, ViajeUncheckedCreateWithoutClienteInput> | ViajeCreateWithoutClienteInput[] | ViajeUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutClienteInput | ViajeCreateOrConnectWithoutClienteInput[]
    createMany?: ViajeCreateManyClienteInputEnvelope
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
  }

  export type EnumEstadoClienteFieldUpdateOperationsInput = {
    set?: $Enums.EstadoCliente
  }

  export type ViajeUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ViajeCreateWithoutClienteInput, ViajeUncheckedCreateWithoutClienteInput> | ViajeCreateWithoutClienteInput[] | ViajeUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutClienteInput | ViajeCreateOrConnectWithoutClienteInput[]
    upsert?: ViajeUpsertWithWhereUniqueWithoutClienteInput | ViajeUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ViajeCreateManyClienteInputEnvelope
    set?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    disconnect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    delete?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    update?: ViajeUpdateWithWhereUniqueWithoutClienteInput | ViajeUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ViajeUpdateManyWithWhereWithoutClienteInput | ViajeUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ViajeScalarWhereInput | ViajeScalarWhereInput[]
  }

  export type ViajeUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ViajeCreateWithoutClienteInput, ViajeUncheckedCreateWithoutClienteInput> | ViajeCreateWithoutClienteInput[] | ViajeUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutClienteInput | ViajeCreateOrConnectWithoutClienteInput[]
    upsert?: ViajeUpsertWithWhereUniqueWithoutClienteInput | ViajeUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ViajeCreateManyClienteInputEnvelope
    set?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    disconnect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    delete?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    update?: ViajeUpdateWithWhereUniqueWithoutClienteInput | ViajeUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ViajeUpdateManyWithWhereWithoutClienteInput | ViajeUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ViajeScalarWhereInput | ViajeScalarWhereInput[]
  }

  export type ViajeCreateNestedManyWithoutMaterialInput = {
    create?: XOR<ViajeCreateWithoutMaterialInput, ViajeUncheckedCreateWithoutMaterialInput> | ViajeCreateWithoutMaterialInput[] | ViajeUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutMaterialInput | ViajeCreateOrConnectWithoutMaterialInput[]
    createMany?: ViajeCreateManyMaterialInputEnvelope
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
  }

  export type ViajeUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<ViajeCreateWithoutMaterialInput, ViajeUncheckedCreateWithoutMaterialInput> | ViajeCreateWithoutMaterialInput[] | ViajeUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutMaterialInput | ViajeCreateOrConnectWithoutMaterialInput[]
    createMany?: ViajeCreateManyMaterialInputEnvelope
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
  }

  export type ViajeUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<ViajeCreateWithoutMaterialInput, ViajeUncheckedCreateWithoutMaterialInput> | ViajeCreateWithoutMaterialInput[] | ViajeUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutMaterialInput | ViajeCreateOrConnectWithoutMaterialInput[]
    upsert?: ViajeUpsertWithWhereUniqueWithoutMaterialInput | ViajeUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: ViajeCreateManyMaterialInputEnvelope
    set?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    disconnect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    delete?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    update?: ViajeUpdateWithWhereUniqueWithoutMaterialInput | ViajeUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: ViajeUpdateManyWithWhereWithoutMaterialInput | ViajeUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: ViajeScalarWhereInput | ViajeScalarWhereInput[]
  }

  export type ViajeUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<ViajeCreateWithoutMaterialInput, ViajeUncheckedCreateWithoutMaterialInput> | ViajeCreateWithoutMaterialInput[] | ViajeUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ViajeCreateOrConnectWithoutMaterialInput | ViajeCreateOrConnectWithoutMaterialInput[]
    upsert?: ViajeUpsertWithWhereUniqueWithoutMaterialInput | ViajeUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: ViajeCreateManyMaterialInputEnvelope
    set?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    disconnect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    delete?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    connect?: ViajeWhereUniqueInput | ViajeWhereUniqueInput[]
    update?: ViajeUpdateWithWhereUniqueWithoutMaterialInput | ViajeUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: ViajeUpdateManyWithWhereWithoutMaterialInput | ViajeUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: ViajeScalarWhereInput | ViajeScalarWhereInput[]
  }

  export type VehiculoCreateNestedOneWithoutViajesInput = {
    create?: XOR<VehiculoCreateWithoutViajesInput, VehiculoUncheckedCreateWithoutViajesInput>
    connectOrCreate?: VehiculoCreateOrConnectWithoutViajesInput
    connect?: VehiculoWhereUniqueInput
  }

  export type ChoferCreateNestedOneWithoutViajesInput = {
    create?: XOR<ChoferCreateWithoutViajesInput, ChoferUncheckedCreateWithoutViajesInput>
    connectOrCreate?: ChoferCreateOrConnectWithoutViajesInput
    connect?: ChoferWhereUniqueInput
  }

  export type ClienteCreateNestedOneWithoutViajesInput = {
    create?: XOR<ClienteCreateWithoutViajesInput, ClienteUncheckedCreateWithoutViajesInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutViajesInput
    connect?: ClienteWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutViajesInput = {
    create?: XOR<MaterialCreateWithoutViajesInput, MaterialUncheckedCreateWithoutViajesInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutViajesInput
    connect?: MaterialWhereUniqueInput
  }

  export type GastoViajeCreateNestedManyWithoutViajeInput = {
    create?: XOR<GastoViajeCreateWithoutViajeInput, GastoViajeUncheckedCreateWithoutViajeInput> | GastoViajeCreateWithoutViajeInput[] | GastoViajeUncheckedCreateWithoutViajeInput[]
    connectOrCreate?: GastoViajeCreateOrConnectWithoutViajeInput | GastoViajeCreateOrConnectWithoutViajeInput[]
    createMany?: GastoViajeCreateManyViajeInputEnvelope
    connect?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
  }

  export type PagoChoferCreateNestedManyWithoutViajeInput = {
    create?: XOR<PagoChoferCreateWithoutViajeInput, PagoChoferUncheckedCreateWithoutViajeInput> | PagoChoferCreateWithoutViajeInput[] | PagoChoferUncheckedCreateWithoutViajeInput[]
    connectOrCreate?: PagoChoferCreateOrConnectWithoutViajeInput | PagoChoferCreateOrConnectWithoutViajeInput[]
    createMany?: PagoChoferCreateManyViajeInputEnvelope
    connect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
  }

  export type GastoViajeUncheckedCreateNestedManyWithoutViajeInput = {
    create?: XOR<GastoViajeCreateWithoutViajeInput, GastoViajeUncheckedCreateWithoutViajeInput> | GastoViajeCreateWithoutViajeInput[] | GastoViajeUncheckedCreateWithoutViajeInput[]
    connectOrCreate?: GastoViajeCreateOrConnectWithoutViajeInput | GastoViajeCreateOrConnectWithoutViajeInput[]
    createMany?: GastoViajeCreateManyViajeInputEnvelope
    connect?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
  }

  export type PagoChoferUncheckedCreateNestedManyWithoutViajeInput = {
    create?: XOR<PagoChoferCreateWithoutViajeInput, PagoChoferUncheckedCreateWithoutViajeInput> | PagoChoferCreateWithoutViajeInput[] | PagoChoferUncheckedCreateWithoutViajeInput[]
    connectOrCreate?: PagoChoferCreateOrConnectWithoutViajeInput | PagoChoferCreateOrConnectWithoutViajeInput[]
    createMany?: PagoChoferCreateManyViajeInputEnvelope
    connect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumEstadoPagoClienteFieldUpdateOperationsInput = {
    set?: $Enums.EstadoPagoCliente
  }

  export type EnumEstadoViajeFieldUpdateOperationsInput = {
    set?: $Enums.EstadoViaje
  }

  export type VehiculoUpdateOneRequiredWithoutViajesNestedInput = {
    create?: XOR<VehiculoCreateWithoutViajesInput, VehiculoUncheckedCreateWithoutViajesInput>
    connectOrCreate?: VehiculoCreateOrConnectWithoutViajesInput
    upsert?: VehiculoUpsertWithoutViajesInput
    connect?: VehiculoWhereUniqueInput
    update?: XOR<XOR<VehiculoUpdateToOneWithWhereWithoutViajesInput, VehiculoUpdateWithoutViajesInput>, VehiculoUncheckedUpdateWithoutViajesInput>
  }

  export type ChoferUpdateOneRequiredWithoutViajesNestedInput = {
    create?: XOR<ChoferCreateWithoutViajesInput, ChoferUncheckedCreateWithoutViajesInput>
    connectOrCreate?: ChoferCreateOrConnectWithoutViajesInput
    upsert?: ChoferUpsertWithoutViajesInput
    connect?: ChoferWhereUniqueInput
    update?: XOR<XOR<ChoferUpdateToOneWithWhereWithoutViajesInput, ChoferUpdateWithoutViajesInput>, ChoferUncheckedUpdateWithoutViajesInput>
  }

  export type ClienteUpdateOneRequiredWithoutViajesNestedInput = {
    create?: XOR<ClienteCreateWithoutViajesInput, ClienteUncheckedCreateWithoutViajesInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutViajesInput
    upsert?: ClienteUpsertWithoutViajesInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutViajesInput, ClienteUpdateWithoutViajesInput>, ClienteUncheckedUpdateWithoutViajesInput>
  }

  export type MaterialUpdateOneRequiredWithoutViajesNestedInput = {
    create?: XOR<MaterialCreateWithoutViajesInput, MaterialUncheckedCreateWithoutViajesInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutViajesInput
    upsert?: MaterialUpsertWithoutViajesInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutViajesInput, MaterialUpdateWithoutViajesInput>, MaterialUncheckedUpdateWithoutViajesInput>
  }

  export type GastoViajeUpdateManyWithoutViajeNestedInput = {
    create?: XOR<GastoViajeCreateWithoutViajeInput, GastoViajeUncheckedCreateWithoutViajeInput> | GastoViajeCreateWithoutViajeInput[] | GastoViajeUncheckedCreateWithoutViajeInput[]
    connectOrCreate?: GastoViajeCreateOrConnectWithoutViajeInput | GastoViajeCreateOrConnectWithoutViajeInput[]
    upsert?: GastoViajeUpsertWithWhereUniqueWithoutViajeInput | GastoViajeUpsertWithWhereUniqueWithoutViajeInput[]
    createMany?: GastoViajeCreateManyViajeInputEnvelope
    set?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    disconnect?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    delete?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    connect?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    update?: GastoViajeUpdateWithWhereUniqueWithoutViajeInput | GastoViajeUpdateWithWhereUniqueWithoutViajeInput[]
    updateMany?: GastoViajeUpdateManyWithWhereWithoutViajeInput | GastoViajeUpdateManyWithWhereWithoutViajeInput[]
    deleteMany?: GastoViajeScalarWhereInput | GastoViajeScalarWhereInput[]
  }

  export type PagoChoferUpdateManyWithoutViajeNestedInput = {
    create?: XOR<PagoChoferCreateWithoutViajeInput, PagoChoferUncheckedCreateWithoutViajeInput> | PagoChoferCreateWithoutViajeInput[] | PagoChoferUncheckedCreateWithoutViajeInput[]
    connectOrCreate?: PagoChoferCreateOrConnectWithoutViajeInput | PagoChoferCreateOrConnectWithoutViajeInput[]
    upsert?: PagoChoferUpsertWithWhereUniqueWithoutViajeInput | PagoChoferUpsertWithWhereUniqueWithoutViajeInput[]
    createMany?: PagoChoferCreateManyViajeInputEnvelope
    set?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    disconnect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    delete?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    connect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    update?: PagoChoferUpdateWithWhereUniqueWithoutViajeInput | PagoChoferUpdateWithWhereUniqueWithoutViajeInput[]
    updateMany?: PagoChoferUpdateManyWithWhereWithoutViajeInput | PagoChoferUpdateManyWithWhereWithoutViajeInput[]
    deleteMany?: PagoChoferScalarWhereInput | PagoChoferScalarWhereInput[]
  }

  export type GastoViajeUncheckedUpdateManyWithoutViajeNestedInput = {
    create?: XOR<GastoViajeCreateWithoutViajeInput, GastoViajeUncheckedCreateWithoutViajeInput> | GastoViajeCreateWithoutViajeInput[] | GastoViajeUncheckedCreateWithoutViajeInput[]
    connectOrCreate?: GastoViajeCreateOrConnectWithoutViajeInput | GastoViajeCreateOrConnectWithoutViajeInput[]
    upsert?: GastoViajeUpsertWithWhereUniqueWithoutViajeInput | GastoViajeUpsertWithWhereUniqueWithoutViajeInput[]
    createMany?: GastoViajeCreateManyViajeInputEnvelope
    set?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    disconnect?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    delete?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    connect?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    update?: GastoViajeUpdateWithWhereUniqueWithoutViajeInput | GastoViajeUpdateWithWhereUniqueWithoutViajeInput[]
    updateMany?: GastoViajeUpdateManyWithWhereWithoutViajeInput | GastoViajeUpdateManyWithWhereWithoutViajeInput[]
    deleteMany?: GastoViajeScalarWhereInput | GastoViajeScalarWhereInput[]
  }

  export type PagoChoferUncheckedUpdateManyWithoutViajeNestedInput = {
    create?: XOR<PagoChoferCreateWithoutViajeInput, PagoChoferUncheckedCreateWithoutViajeInput> | PagoChoferCreateWithoutViajeInput[] | PagoChoferUncheckedCreateWithoutViajeInput[]
    connectOrCreate?: PagoChoferCreateOrConnectWithoutViajeInput | PagoChoferCreateOrConnectWithoutViajeInput[]
    upsert?: PagoChoferUpsertWithWhereUniqueWithoutViajeInput | PagoChoferUpsertWithWhereUniqueWithoutViajeInput[]
    createMany?: PagoChoferCreateManyViajeInputEnvelope
    set?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    disconnect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    delete?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    connect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    update?: PagoChoferUpdateWithWhereUniqueWithoutViajeInput | PagoChoferUpdateWithWhereUniqueWithoutViajeInput[]
    updateMany?: PagoChoferUpdateManyWithWhereWithoutViajeInput | PagoChoferUpdateManyWithWhereWithoutViajeInput[]
    deleteMany?: PagoChoferScalarWhereInput | PagoChoferScalarWhereInput[]
  }

  export type ViajeCreateNestedOneWithoutGastosInput = {
    create?: XOR<ViajeCreateWithoutGastosInput, ViajeUncheckedCreateWithoutGastosInput>
    connectOrCreate?: ViajeCreateOrConnectWithoutGastosInput
    connect?: ViajeWhereUniqueInput
  }

  export type ComprobanteCreateNestedOneWithoutGastosViajeInput = {
    create?: XOR<ComprobanteCreateWithoutGastosViajeInput, ComprobanteUncheckedCreateWithoutGastosViajeInput>
    connectOrCreate?: ComprobanteCreateOrConnectWithoutGastosViajeInput
    connect?: ComprobanteWhereUniqueInput
  }

  export type EnumTipoGastoFieldUpdateOperationsInput = {
    set?: $Enums.TipoGasto
  }

  export type ViajeUpdateOneRequiredWithoutGastosNestedInput = {
    create?: XOR<ViajeCreateWithoutGastosInput, ViajeUncheckedCreateWithoutGastosInput>
    connectOrCreate?: ViajeCreateOrConnectWithoutGastosInput
    upsert?: ViajeUpsertWithoutGastosInput
    connect?: ViajeWhereUniqueInput
    update?: XOR<XOR<ViajeUpdateToOneWithWhereWithoutGastosInput, ViajeUpdateWithoutGastosInput>, ViajeUncheckedUpdateWithoutGastosInput>
  }

  export type ComprobanteUpdateOneWithoutGastosViajeNestedInput = {
    create?: XOR<ComprobanteCreateWithoutGastosViajeInput, ComprobanteUncheckedCreateWithoutGastosViajeInput>
    connectOrCreate?: ComprobanteCreateOrConnectWithoutGastosViajeInput
    upsert?: ComprobanteUpsertWithoutGastosViajeInput
    disconnect?: ComprobanteWhereInput | boolean
    delete?: ComprobanteWhereInput | boolean
    connect?: ComprobanteWhereUniqueInput
    update?: XOR<XOR<ComprobanteUpdateToOneWithWhereWithoutGastosViajeInput, ComprobanteUpdateWithoutGastosViajeInput>, ComprobanteUncheckedUpdateWithoutGastosViajeInput>
  }

  export type GastoViajeCreateNestedManyWithoutComprobanteInput = {
    create?: XOR<GastoViajeCreateWithoutComprobanteInput, GastoViajeUncheckedCreateWithoutComprobanteInput> | GastoViajeCreateWithoutComprobanteInput[] | GastoViajeUncheckedCreateWithoutComprobanteInput[]
    connectOrCreate?: GastoViajeCreateOrConnectWithoutComprobanteInput | GastoViajeCreateOrConnectWithoutComprobanteInput[]
    createMany?: GastoViajeCreateManyComprobanteInputEnvelope
    connect?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
  }

  export type MantenimientoCreateNestedManyWithoutComprobanteInput = {
    create?: XOR<MantenimientoCreateWithoutComprobanteInput, MantenimientoUncheckedCreateWithoutComprobanteInput> | MantenimientoCreateWithoutComprobanteInput[] | MantenimientoUncheckedCreateWithoutComprobanteInput[]
    connectOrCreate?: MantenimientoCreateOrConnectWithoutComprobanteInput | MantenimientoCreateOrConnectWithoutComprobanteInput[]
    createMany?: MantenimientoCreateManyComprobanteInputEnvelope
    connect?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
  }

  export type PagoChoferCreateNestedManyWithoutComprobanteInput = {
    create?: XOR<PagoChoferCreateWithoutComprobanteInput, PagoChoferUncheckedCreateWithoutComprobanteInput> | PagoChoferCreateWithoutComprobanteInput[] | PagoChoferUncheckedCreateWithoutComprobanteInput[]
    connectOrCreate?: PagoChoferCreateOrConnectWithoutComprobanteInput | PagoChoferCreateOrConnectWithoutComprobanteInput[]
    createMany?: PagoChoferCreateManyComprobanteInputEnvelope
    connect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
  }

  export type GastoViajeUncheckedCreateNestedManyWithoutComprobanteInput = {
    create?: XOR<GastoViajeCreateWithoutComprobanteInput, GastoViajeUncheckedCreateWithoutComprobanteInput> | GastoViajeCreateWithoutComprobanteInput[] | GastoViajeUncheckedCreateWithoutComprobanteInput[]
    connectOrCreate?: GastoViajeCreateOrConnectWithoutComprobanteInput | GastoViajeCreateOrConnectWithoutComprobanteInput[]
    createMany?: GastoViajeCreateManyComprobanteInputEnvelope
    connect?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
  }

  export type MantenimientoUncheckedCreateNestedManyWithoutComprobanteInput = {
    create?: XOR<MantenimientoCreateWithoutComprobanteInput, MantenimientoUncheckedCreateWithoutComprobanteInput> | MantenimientoCreateWithoutComprobanteInput[] | MantenimientoUncheckedCreateWithoutComprobanteInput[]
    connectOrCreate?: MantenimientoCreateOrConnectWithoutComprobanteInput | MantenimientoCreateOrConnectWithoutComprobanteInput[]
    createMany?: MantenimientoCreateManyComprobanteInputEnvelope
    connect?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
  }

  export type PagoChoferUncheckedCreateNestedManyWithoutComprobanteInput = {
    create?: XOR<PagoChoferCreateWithoutComprobanteInput, PagoChoferUncheckedCreateWithoutComprobanteInput> | PagoChoferCreateWithoutComprobanteInput[] | PagoChoferUncheckedCreateWithoutComprobanteInput[]
    connectOrCreate?: PagoChoferCreateOrConnectWithoutComprobanteInput | PagoChoferCreateOrConnectWithoutComprobanteInput[]
    createMany?: PagoChoferCreateManyComprobanteInputEnvelope
    connect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
  }

  export type EnumTipoComprobanteFieldUpdateOperationsInput = {
    set?: $Enums.TipoComprobante
  }

  export type GastoViajeUpdateManyWithoutComprobanteNestedInput = {
    create?: XOR<GastoViajeCreateWithoutComprobanteInput, GastoViajeUncheckedCreateWithoutComprobanteInput> | GastoViajeCreateWithoutComprobanteInput[] | GastoViajeUncheckedCreateWithoutComprobanteInput[]
    connectOrCreate?: GastoViajeCreateOrConnectWithoutComprobanteInput | GastoViajeCreateOrConnectWithoutComprobanteInput[]
    upsert?: GastoViajeUpsertWithWhereUniqueWithoutComprobanteInput | GastoViajeUpsertWithWhereUniqueWithoutComprobanteInput[]
    createMany?: GastoViajeCreateManyComprobanteInputEnvelope
    set?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    disconnect?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    delete?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    connect?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    update?: GastoViajeUpdateWithWhereUniqueWithoutComprobanteInput | GastoViajeUpdateWithWhereUniqueWithoutComprobanteInput[]
    updateMany?: GastoViajeUpdateManyWithWhereWithoutComprobanteInput | GastoViajeUpdateManyWithWhereWithoutComprobanteInput[]
    deleteMany?: GastoViajeScalarWhereInput | GastoViajeScalarWhereInput[]
  }

  export type MantenimientoUpdateManyWithoutComprobanteNestedInput = {
    create?: XOR<MantenimientoCreateWithoutComprobanteInput, MantenimientoUncheckedCreateWithoutComprobanteInput> | MantenimientoCreateWithoutComprobanteInput[] | MantenimientoUncheckedCreateWithoutComprobanteInput[]
    connectOrCreate?: MantenimientoCreateOrConnectWithoutComprobanteInput | MantenimientoCreateOrConnectWithoutComprobanteInput[]
    upsert?: MantenimientoUpsertWithWhereUniqueWithoutComprobanteInput | MantenimientoUpsertWithWhereUniqueWithoutComprobanteInput[]
    createMany?: MantenimientoCreateManyComprobanteInputEnvelope
    set?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    disconnect?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    delete?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    connect?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    update?: MantenimientoUpdateWithWhereUniqueWithoutComprobanteInput | MantenimientoUpdateWithWhereUniqueWithoutComprobanteInput[]
    updateMany?: MantenimientoUpdateManyWithWhereWithoutComprobanteInput | MantenimientoUpdateManyWithWhereWithoutComprobanteInput[]
    deleteMany?: MantenimientoScalarWhereInput | MantenimientoScalarWhereInput[]
  }

  export type PagoChoferUpdateManyWithoutComprobanteNestedInput = {
    create?: XOR<PagoChoferCreateWithoutComprobanteInput, PagoChoferUncheckedCreateWithoutComprobanteInput> | PagoChoferCreateWithoutComprobanteInput[] | PagoChoferUncheckedCreateWithoutComprobanteInput[]
    connectOrCreate?: PagoChoferCreateOrConnectWithoutComprobanteInput | PagoChoferCreateOrConnectWithoutComprobanteInput[]
    upsert?: PagoChoferUpsertWithWhereUniqueWithoutComprobanteInput | PagoChoferUpsertWithWhereUniqueWithoutComprobanteInput[]
    createMany?: PagoChoferCreateManyComprobanteInputEnvelope
    set?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    disconnect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    delete?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    connect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    update?: PagoChoferUpdateWithWhereUniqueWithoutComprobanteInput | PagoChoferUpdateWithWhereUniqueWithoutComprobanteInput[]
    updateMany?: PagoChoferUpdateManyWithWhereWithoutComprobanteInput | PagoChoferUpdateManyWithWhereWithoutComprobanteInput[]
    deleteMany?: PagoChoferScalarWhereInput | PagoChoferScalarWhereInput[]
  }

  export type GastoViajeUncheckedUpdateManyWithoutComprobanteNestedInput = {
    create?: XOR<GastoViajeCreateWithoutComprobanteInput, GastoViajeUncheckedCreateWithoutComprobanteInput> | GastoViajeCreateWithoutComprobanteInput[] | GastoViajeUncheckedCreateWithoutComprobanteInput[]
    connectOrCreate?: GastoViajeCreateOrConnectWithoutComprobanteInput | GastoViajeCreateOrConnectWithoutComprobanteInput[]
    upsert?: GastoViajeUpsertWithWhereUniqueWithoutComprobanteInput | GastoViajeUpsertWithWhereUniqueWithoutComprobanteInput[]
    createMany?: GastoViajeCreateManyComprobanteInputEnvelope
    set?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    disconnect?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    delete?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    connect?: GastoViajeWhereUniqueInput | GastoViajeWhereUniqueInput[]
    update?: GastoViajeUpdateWithWhereUniqueWithoutComprobanteInput | GastoViajeUpdateWithWhereUniqueWithoutComprobanteInput[]
    updateMany?: GastoViajeUpdateManyWithWhereWithoutComprobanteInput | GastoViajeUpdateManyWithWhereWithoutComprobanteInput[]
    deleteMany?: GastoViajeScalarWhereInput | GastoViajeScalarWhereInput[]
  }

  export type MantenimientoUncheckedUpdateManyWithoutComprobanteNestedInput = {
    create?: XOR<MantenimientoCreateWithoutComprobanteInput, MantenimientoUncheckedCreateWithoutComprobanteInput> | MantenimientoCreateWithoutComprobanteInput[] | MantenimientoUncheckedCreateWithoutComprobanteInput[]
    connectOrCreate?: MantenimientoCreateOrConnectWithoutComprobanteInput | MantenimientoCreateOrConnectWithoutComprobanteInput[]
    upsert?: MantenimientoUpsertWithWhereUniqueWithoutComprobanteInput | MantenimientoUpsertWithWhereUniqueWithoutComprobanteInput[]
    createMany?: MantenimientoCreateManyComprobanteInputEnvelope
    set?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    disconnect?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    delete?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    connect?: MantenimientoWhereUniqueInput | MantenimientoWhereUniqueInput[]
    update?: MantenimientoUpdateWithWhereUniqueWithoutComprobanteInput | MantenimientoUpdateWithWhereUniqueWithoutComprobanteInput[]
    updateMany?: MantenimientoUpdateManyWithWhereWithoutComprobanteInput | MantenimientoUpdateManyWithWhereWithoutComprobanteInput[]
    deleteMany?: MantenimientoScalarWhereInput | MantenimientoScalarWhereInput[]
  }

  export type PagoChoferUncheckedUpdateManyWithoutComprobanteNestedInput = {
    create?: XOR<PagoChoferCreateWithoutComprobanteInput, PagoChoferUncheckedCreateWithoutComprobanteInput> | PagoChoferCreateWithoutComprobanteInput[] | PagoChoferUncheckedCreateWithoutComprobanteInput[]
    connectOrCreate?: PagoChoferCreateOrConnectWithoutComprobanteInput | PagoChoferCreateOrConnectWithoutComprobanteInput[]
    upsert?: PagoChoferUpsertWithWhereUniqueWithoutComprobanteInput | PagoChoferUpsertWithWhereUniqueWithoutComprobanteInput[]
    createMany?: PagoChoferCreateManyComprobanteInputEnvelope
    set?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    disconnect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    delete?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    connect?: PagoChoferWhereUniqueInput | PagoChoferWhereUniqueInput[]
    update?: PagoChoferUpdateWithWhereUniqueWithoutComprobanteInput | PagoChoferUpdateWithWhereUniqueWithoutComprobanteInput[]
    updateMany?: PagoChoferUpdateManyWithWhereWithoutComprobanteInput | PagoChoferUpdateManyWithWhereWithoutComprobanteInput[]
    deleteMany?: PagoChoferScalarWhereInput | PagoChoferScalarWhereInput[]
  }

  export type VehiculoCreateNestedOneWithoutMantenimientosInput = {
    create?: XOR<VehiculoCreateWithoutMantenimientosInput, VehiculoUncheckedCreateWithoutMantenimientosInput>
    connectOrCreate?: VehiculoCreateOrConnectWithoutMantenimientosInput
    connect?: VehiculoWhereUniqueInput
  }

  export type ComprobanteCreateNestedOneWithoutMantenimientosInput = {
    create?: XOR<ComprobanteCreateWithoutMantenimientosInput, ComprobanteUncheckedCreateWithoutMantenimientosInput>
    connectOrCreate?: ComprobanteCreateOrConnectWithoutMantenimientosInput
    connect?: ComprobanteWhereUniqueInput
  }

  export type EnumTipoMantenimientoFieldUpdateOperationsInput = {
    set?: $Enums.TipoMantenimiento
  }

  export type EnumEstadoMantenimientoFieldUpdateOperationsInput = {
    set?: $Enums.EstadoMantenimiento
  }

  export type VehiculoUpdateOneRequiredWithoutMantenimientosNestedInput = {
    create?: XOR<VehiculoCreateWithoutMantenimientosInput, VehiculoUncheckedCreateWithoutMantenimientosInput>
    connectOrCreate?: VehiculoCreateOrConnectWithoutMantenimientosInput
    upsert?: VehiculoUpsertWithoutMantenimientosInput
    connect?: VehiculoWhereUniqueInput
    update?: XOR<XOR<VehiculoUpdateToOneWithWhereWithoutMantenimientosInput, VehiculoUpdateWithoutMantenimientosInput>, VehiculoUncheckedUpdateWithoutMantenimientosInput>
  }

  export type ComprobanteUpdateOneWithoutMantenimientosNestedInput = {
    create?: XOR<ComprobanteCreateWithoutMantenimientosInput, ComprobanteUncheckedCreateWithoutMantenimientosInput>
    connectOrCreate?: ComprobanteCreateOrConnectWithoutMantenimientosInput
    upsert?: ComprobanteUpsertWithoutMantenimientosInput
    disconnect?: ComprobanteWhereInput | boolean
    delete?: ComprobanteWhereInput | boolean
    connect?: ComprobanteWhereUniqueInput
    update?: XOR<XOR<ComprobanteUpdateToOneWithWhereWithoutMantenimientosInput, ComprobanteUpdateWithoutMantenimientosInput>, ComprobanteUncheckedUpdateWithoutMantenimientosInput>
  }

  export type ChoferCreateNestedOneWithoutPagosInput = {
    create?: XOR<ChoferCreateWithoutPagosInput, ChoferUncheckedCreateWithoutPagosInput>
    connectOrCreate?: ChoferCreateOrConnectWithoutPagosInput
    connect?: ChoferWhereUniqueInput
  }

  export type ComprobanteCreateNestedOneWithoutPagosChoferInput = {
    create?: XOR<ComprobanteCreateWithoutPagosChoferInput, ComprobanteUncheckedCreateWithoutPagosChoferInput>
    connectOrCreate?: ComprobanteCreateOrConnectWithoutPagosChoferInput
    connect?: ComprobanteWhereUniqueInput
  }

  export type ViajeCreateNestedOneWithoutPagosInput = {
    create?: XOR<ViajeCreateWithoutPagosInput, ViajeUncheckedCreateWithoutPagosInput>
    connectOrCreate?: ViajeCreateOrConnectWithoutPagosInput
    connect?: ViajeWhereUniqueInput
  }

  export type EnumEstadoPagoChoferFieldUpdateOperationsInput = {
    set?: $Enums.EstadoPagoChofer
  }

  export type ChoferUpdateOneRequiredWithoutPagosNestedInput = {
    create?: XOR<ChoferCreateWithoutPagosInput, ChoferUncheckedCreateWithoutPagosInput>
    connectOrCreate?: ChoferCreateOrConnectWithoutPagosInput
    upsert?: ChoferUpsertWithoutPagosInput
    connect?: ChoferWhereUniqueInput
    update?: XOR<XOR<ChoferUpdateToOneWithWhereWithoutPagosInput, ChoferUpdateWithoutPagosInput>, ChoferUncheckedUpdateWithoutPagosInput>
  }

  export type ComprobanteUpdateOneWithoutPagosChoferNestedInput = {
    create?: XOR<ComprobanteCreateWithoutPagosChoferInput, ComprobanteUncheckedCreateWithoutPagosChoferInput>
    connectOrCreate?: ComprobanteCreateOrConnectWithoutPagosChoferInput
    upsert?: ComprobanteUpsertWithoutPagosChoferInput
    disconnect?: ComprobanteWhereInput | boolean
    delete?: ComprobanteWhereInput | boolean
    connect?: ComprobanteWhereUniqueInput
    update?: XOR<XOR<ComprobanteUpdateToOneWithWhereWithoutPagosChoferInput, ComprobanteUpdateWithoutPagosChoferInput>, ComprobanteUncheckedUpdateWithoutPagosChoferInput>
  }

  export type ViajeUpdateOneWithoutPagosNestedInput = {
    create?: XOR<ViajeCreateWithoutPagosInput, ViajeUncheckedCreateWithoutPagosInput>
    connectOrCreate?: ViajeCreateOrConnectWithoutPagosInput
    upsert?: ViajeUpsertWithoutPagosInput
    disconnect?: ViajeWhereInput | boolean
    delete?: ViajeWhereInput | boolean
    connect?: ViajeWhereUniqueInput
    update?: XOR<XOR<ViajeUpdateToOneWithWhereWithoutPagosInput, ViajeUpdateWithoutPagosInput>, ViajeUncheckedUpdateWithoutPagosInput>
  }

  export type UsuarioCreateNestedOneWithoutRegistrosAuditoriaInput = {
    create?: XOR<UsuarioCreateWithoutRegistrosAuditoriaInput, UsuarioUncheckedCreateWithoutRegistrosAuditoriaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRegistrosAuditoriaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EnumAccionAuditoriaFieldUpdateOperationsInput = {
    set?: $Enums.AccionAuditoria
  }

  export type UsuarioUpdateOneRequiredWithoutRegistrosAuditoriaNestedInput = {
    create?: XOR<UsuarioCreateWithoutRegistrosAuditoriaInput, UsuarioUncheckedCreateWithoutRegistrosAuditoriaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRegistrosAuditoriaInput
    upsert?: UsuarioUpsertWithoutRegistrosAuditoriaInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutRegistrosAuditoriaInput, UsuarioUpdateWithoutRegistrosAuditoriaInput>, UsuarioUncheckedUpdateWithoutRegistrosAuditoriaInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRolUsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.RolUsuario | EnumRolUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.RolUsuario[] | ListEnumRolUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolUsuario[] | ListEnumRolUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumRolUsuarioFilter<$PrismaModel> | $Enums.RolUsuario
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRolUsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RolUsuario | EnumRolUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.RolUsuario[] | ListEnumRolUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolUsuario[] | ListEnumRolUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumRolUsuarioWithAggregatesFilter<$PrismaModel> | $Enums.RolUsuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolUsuarioFilter<$PrismaModel>
    _max?: NestedEnumRolUsuarioFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumEstadoVehiculoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoVehiculo | EnumEstadoVehiculoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoVehiculo[] | ListEnumEstadoVehiculoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoVehiculo[] | ListEnumEstadoVehiculoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoVehiculoFilter<$PrismaModel> | $Enums.EstadoVehiculo
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumEstadoVehiculoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoVehiculo | EnumEstadoVehiculoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoVehiculo[] | ListEnumEstadoVehiculoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoVehiculo[] | ListEnumEstadoVehiculoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoVehiculoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoVehiculo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoVehiculoFilter<$PrismaModel>
    _max?: NestedEnumEstadoVehiculoFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumEstadoChoferFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoChofer | EnumEstadoChoferFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoChofer[] | ListEnumEstadoChoferFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoChofer[] | ListEnumEstadoChoferFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoChoferFilter<$PrismaModel> | $Enums.EstadoChofer
  }

  export type NestedEnumModalidadPagoFilter<$PrismaModel = never> = {
    equals?: $Enums.ModalidadPago | EnumModalidadPagoFieldRefInput<$PrismaModel>
    in?: $Enums.ModalidadPago[] | ListEnumModalidadPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModalidadPago[] | ListEnumModalidadPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumModalidadPagoFilter<$PrismaModel> | $Enums.ModalidadPago
  }

  export type NestedEnumMetodoPagoFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoPago | EnumMetodoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodoPagoFilter<$PrismaModel> | $Enums.MetodoPago
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumEstadoChoferWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoChofer | EnumEstadoChoferFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoChofer[] | ListEnumEstadoChoferFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoChofer[] | ListEnumEstadoChoferFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoChoferWithAggregatesFilter<$PrismaModel> | $Enums.EstadoChofer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoChoferFilter<$PrismaModel>
    _max?: NestedEnumEstadoChoferFilter<$PrismaModel>
  }

  export type NestedEnumModalidadPagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModalidadPago | EnumModalidadPagoFieldRefInput<$PrismaModel>
    in?: $Enums.ModalidadPago[] | ListEnumModalidadPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModalidadPago[] | ListEnumModalidadPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumModalidadPagoWithAggregatesFilter<$PrismaModel> | $Enums.ModalidadPago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModalidadPagoFilter<$PrismaModel>
    _max?: NestedEnumModalidadPagoFilter<$PrismaModel>
  }

  export type NestedEnumMetodoPagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoPago | EnumMetodoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodoPagoWithAggregatesFilter<$PrismaModel> | $Enums.MetodoPago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetodoPagoFilter<$PrismaModel>
    _max?: NestedEnumMetodoPagoFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumEstadoClienteFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoCliente | EnumEstadoClienteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoCliente[] | ListEnumEstadoClienteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoCliente[] | ListEnumEstadoClienteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoClienteFilter<$PrismaModel> | $Enums.EstadoCliente
  }

  export type NestedEnumEstadoClienteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoCliente | EnumEstadoClienteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoCliente[] | ListEnumEstadoClienteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoCliente[] | ListEnumEstadoClienteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoClienteWithAggregatesFilter<$PrismaModel> | $Enums.EstadoCliente
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoClienteFilter<$PrismaModel>
    _max?: NestedEnumEstadoClienteFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumEstadoPagoClienteFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPagoCliente | EnumEstadoPagoClienteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPagoCliente[] | ListEnumEstadoPagoClienteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPagoCliente[] | ListEnumEstadoPagoClienteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoClienteFilter<$PrismaModel> | $Enums.EstadoPagoCliente
  }

  export type NestedEnumEstadoViajeFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoViaje | EnumEstadoViajeFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoViaje[] | ListEnumEstadoViajeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoViaje[] | ListEnumEstadoViajeFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoViajeFilter<$PrismaModel> | $Enums.EstadoViaje
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumEstadoPagoClienteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPagoCliente | EnumEstadoPagoClienteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPagoCliente[] | ListEnumEstadoPagoClienteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPagoCliente[] | ListEnumEstadoPagoClienteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoClienteWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPagoCliente
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPagoClienteFilter<$PrismaModel>
    _max?: NestedEnumEstadoPagoClienteFilter<$PrismaModel>
  }

  export type NestedEnumEstadoViajeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoViaje | EnumEstadoViajeFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoViaje[] | ListEnumEstadoViajeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoViaje[] | ListEnumEstadoViajeFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoViajeWithAggregatesFilter<$PrismaModel> | $Enums.EstadoViaje
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoViajeFilter<$PrismaModel>
    _max?: NestedEnumEstadoViajeFilter<$PrismaModel>
  }

  export type NestedEnumTipoGastoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoGasto | EnumTipoGastoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoGasto[] | ListEnumTipoGastoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoGasto[] | ListEnumTipoGastoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoGastoFilter<$PrismaModel> | $Enums.TipoGasto
  }

  export type NestedEnumTipoGastoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoGasto | EnumTipoGastoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoGasto[] | ListEnumTipoGastoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoGasto[] | ListEnumTipoGastoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoGastoWithAggregatesFilter<$PrismaModel> | $Enums.TipoGasto
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoGastoFilter<$PrismaModel>
    _max?: NestedEnumTipoGastoFilter<$PrismaModel>
  }

  export type NestedEnumTipoComprobanteFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoComprobante | EnumTipoComprobanteFieldRefInput<$PrismaModel>
    in?: $Enums.TipoComprobante[] | ListEnumTipoComprobanteFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoComprobante[] | ListEnumTipoComprobanteFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoComprobanteFilter<$PrismaModel> | $Enums.TipoComprobante
  }

  export type NestedEnumTipoComprobanteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoComprobante | EnumTipoComprobanteFieldRefInput<$PrismaModel>
    in?: $Enums.TipoComprobante[] | ListEnumTipoComprobanteFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoComprobante[] | ListEnumTipoComprobanteFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoComprobanteWithAggregatesFilter<$PrismaModel> | $Enums.TipoComprobante
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoComprobanteFilter<$PrismaModel>
    _max?: NestedEnumTipoComprobanteFilter<$PrismaModel>
  }

  export type NestedEnumTipoMantenimientoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMantenimiento | EnumTipoMantenimientoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoMantenimiento[] | ListEnumTipoMantenimientoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoMantenimiento[] | ListEnumTipoMantenimientoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoMantenimientoFilter<$PrismaModel> | $Enums.TipoMantenimiento
  }

  export type NestedEnumEstadoMantenimientoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoMantenimiento | EnumEstadoMantenimientoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoMantenimiento[] | ListEnumEstadoMantenimientoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoMantenimiento[] | ListEnumEstadoMantenimientoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoMantenimientoFilter<$PrismaModel> | $Enums.EstadoMantenimiento
  }

  export type NestedEnumTipoMantenimientoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMantenimiento | EnumTipoMantenimientoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoMantenimiento[] | ListEnumTipoMantenimientoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoMantenimiento[] | ListEnumTipoMantenimientoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoMantenimientoWithAggregatesFilter<$PrismaModel> | $Enums.TipoMantenimiento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoMantenimientoFilter<$PrismaModel>
    _max?: NestedEnumTipoMantenimientoFilter<$PrismaModel>
  }

  export type NestedEnumEstadoMantenimientoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoMantenimiento | EnumEstadoMantenimientoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoMantenimiento[] | ListEnumEstadoMantenimientoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoMantenimiento[] | ListEnumEstadoMantenimientoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoMantenimientoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoMantenimiento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoMantenimientoFilter<$PrismaModel>
    _max?: NestedEnumEstadoMantenimientoFilter<$PrismaModel>
  }

  export type NestedEnumEstadoPagoChoferFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPagoChofer | EnumEstadoPagoChoferFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPagoChofer[] | ListEnumEstadoPagoChoferFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPagoChofer[] | ListEnumEstadoPagoChoferFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoChoferFilter<$PrismaModel> | $Enums.EstadoPagoChofer
  }

  export type NestedEnumEstadoPagoChoferWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPagoChofer | EnumEstadoPagoChoferFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPagoChofer[] | ListEnumEstadoPagoChoferFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPagoChofer[] | ListEnumEstadoPagoChoferFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoChoferWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPagoChofer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPagoChoferFilter<$PrismaModel>
    _max?: NestedEnumEstadoPagoChoferFilter<$PrismaModel>
  }

  export type NestedEnumAccionAuditoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionAuditoria | EnumAccionAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionAuditoriaFilter<$PrismaModel> | $Enums.AccionAuditoria
  }

  export type NestedEnumAccionAuditoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionAuditoria | EnumAccionAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionAuditoriaWithAggregatesFilter<$PrismaModel> | $Enums.AccionAuditoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccionAuditoriaFilter<$PrismaModel>
    _max?: NestedEnumAccionAuditoriaFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RegistroAuditoriaCreateWithoutUsuarioInput = {
    accion: $Enums.AccionAuditoria
    entidad: string
    entidadId: number
    datosAnteriores?: NullableJsonNullValueInput | InputJsonValue
    datosNuevos?: NullableJsonNullValueInput | InputJsonValue
    fechaHora?: Date | string
    ipAddress?: string | null
  }

  export type RegistroAuditoriaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    accion: $Enums.AccionAuditoria
    entidad: string
    entidadId: number
    datosAnteriores?: NullableJsonNullValueInput | InputJsonValue
    datosNuevos?: NullableJsonNullValueInput | InputJsonValue
    fechaHora?: Date | string
    ipAddress?: string | null
  }

  export type RegistroAuditoriaCreateOrConnectWithoutUsuarioInput = {
    where: RegistroAuditoriaWhereUniqueInput
    create: XOR<RegistroAuditoriaCreateWithoutUsuarioInput, RegistroAuditoriaUncheckedCreateWithoutUsuarioInput>
  }

  export type RegistroAuditoriaCreateManyUsuarioInputEnvelope = {
    data: RegistroAuditoriaCreateManyUsuarioInput | RegistroAuditoriaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type RegistroAuditoriaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: RegistroAuditoriaWhereUniqueInput
    update: XOR<RegistroAuditoriaUpdateWithoutUsuarioInput, RegistroAuditoriaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<RegistroAuditoriaCreateWithoutUsuarioInput, RegistroAuditoriaUncheckedCreateWithoutUsuarioInput>
  }

  export type RegistroAuditoriaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: RegistroAuditoriaWhereUniqueInput
    data: XOR<RegistroAuditoriaUpdateWithoutUsuarioInput, RegistroAuditoriaUncheckedUpdateWithoutUsuarioInput>
  }

  export type RegistroAuditoriaUpdateManyWithWhereWithoutUsuarioInput = {
    where: RegistroAuditoriaScalarWhereInput
    data: XOR<RegistroAuditoriaUpdateManyMutationInput, RegistroAuditoriaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type RegistroAuditoriaScalarWhereInput = {
    AND?: RegistroAuditoriaScalarWhereInput | RegistroAuditoriaScalarWhereInput[]
    OR?: RegistroAuditoriaScalarWhereInput[]
    NOT?: RegistroAuditoriaScalarWhereInput | RegistroAuditoriaScalarWhereInput[]
    id?: IntFilter<"RegistroAuditoria"> | number
    usuarioId?: IntFilter<"RegistroAuditoria"> | number
    accion?: EnumAccionAuditoriaFilter<"RegistroAuditoria"> | $Enums.AccionAuditoria
    entidad?: StringFilter<"RegistroAuditoria"> | string
    entidadId?: IntFilter<"RegistroAuditoria"> | number
    datosAnteriores?: JsonNullableFilter<"RegistroAuditoria">
    datosNuevos?: JsonNullableFilter<"RegistroAuditoria">
    fechaHora?: DateTimeFilter<"RegistroAuditoria"> | Date | string
    ipAddress?: StringNullableFilter<"RegistroAuditoria"> | string | null
  }

  export type ViajeCreateWithoutVehiculoInput = {
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    chofer: ChoferCreateNestedOneWithoutViajesInput
    cliente: ClienteCreateNestedOneWithoutViajesInput
    material: MaterialCreateNestedOneWithoutViajesInput
    gastos?: GastoViajeCreateNestedManyWithoutViajeInput
    pagos?: PagoChoferCreateNestedManyWithoutViajeInput
  }

  export type ViajeUncheckedCreateWithoutVehiculoInput = {
    id?: number
    choferId: number
    clienteId: number
    materialId: number
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    gastos?: GastoViajeUncheckedCreateNestedManyWithoutViajeInput
    pagos?: PagoChoferUncheckedCreateNestedManyWithoutViajeInput
  }

  export type ViajeCreateOrConnectWithoutVehiculoInput = {
    where: ViajeWhereUniqueInput
    create: XOR<ViajeCreateWithoutVehiculoInput, ViajeUncheckedCreateWithoutVehiculoInput>
  }

  export type ViajeCreateManyVehiculoInputEnvelope = {
    data: ViajeCreateManyVehiculoInput | ViajeCreateManyVehiculoInput[]
    skipDuplicates?: boolean
  }

  export type MantenimientoCreateWithoutVehiculoInput = {
    tipo: $Enums.TipoMantenimiento
    estado?: $Enums.EstadoMantenimiento
    descripcion?: string | null
    taller?: string | null
    esExterno?: boolean
    costoManoObra?: Decimal | DecimalJsLike | number | string
    costoRepuestos?: Decimal | DecimalJsLike | number | string
    costoTotal?: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    kilometrajeAlMomento?: number | null
    proximaFecha?: Date | string | null
    proximoKilometraje?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    comprobante?: ComprobanteCreateNestedOneWithoutMantenimientosInput
  }

  export type MantenimientoUncheckedCreateWithoutVehiculoInput = {
    id?: number
    tipo: $Enums.TipoMantenimiento
    estado?: $Enums.EstadoMantenimiento
    descripcion?: string | null
    taller?: string | null
    esExterno?: boolean
    costoManoObra?: Decimal | DecimalJsLike | number | string
    costoRepuestos?: Decimal | DecimalJsLike | number | string
    costoTotal?: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    kilometrajeAlMomento?: number | null
    proximaFecha?: Date | string | null
    proximoKilometraje?: number | null
    comprobanteId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type MantenimientoCreateOrConnectWithoutVehiculoInput = {
    where: MantenimientoWhereUniqueInput
    create: XOR<MantenimientoCreateWithoutVehiculoInput, MantenimientoUncheckedCreateWithoutVehiculoInput>
  }

  export type MantenimientoCreateManyVehiculoInputEnvelope = {
    data: MantenimientoCreateManyVehiculoInput | MantenimientoCreateManyVehiculoInput[]
    skipDuplicates?: boolean
  }

  export type ViajeUpsertWithWhereUniqueWithoutVehiculoInput = {
    where: ViajeWhereUniqueInput
    update: XOR<ViajeUpdateWithoutVehiculoInput, ViajeUncheckedUpdateWithoutVehiculoInput>
    create: XOR<ViajeCreateWithoutVehiculoInput, ViajeUncheckedCreateWithoutVehiculoInput>
  }

  export type ViajeUpdateWithWhereUniqueWithoutVehiculoInput = {
    where: ViajeWhereUniqueInput
    data: XOR<ViajeUpdateWithoutVehiculoInput, ViajeUncheckedUpdateWithoutVehiculoInput>
  }

  export type ViajeUpdateManyWithWhereWithoutVehiculoInput = {
    where: ViajeScalarWhereInput
    data: XOR<ViajeUpdateManyMutationInput, ViajeUncheckedUpdateManyWithoutVehiculoInput>
  }

  export type ViajeScalarWhereInput = {
    AND?: ViajeScalarWhereInput | ViajeScalarWhereInput[]
    OR?: ViajeScalarWhereInput[]
    NOT?: ViajeScalarWhereInput | ViajeScalarWhereInput[]
    id?: IntFilter<"Viaje"> | number
    vehiculoId?: IntFilter<"Viaje"> | number
    choferId?: IntFilter<"Viaje"> | number
    clienteId?: IntFilter<"Viaje"> | number
    materialId?: IntFilter<"Viaje"> | number
    origen?: StringFilter<"Viaje"> | string
    destino?: StringFilter<"Viaje"> | string
    fechaSalida?: DateTimeFilter<"Viaje"> | Date | string
    fechaLlegadaEstimada?: DateTimeNullableFilter<"Viaje"> | Date | string | null
    fechaLlegadaReal?: DateTimeNullableFilter<"Viaje"> | Date | string | null
    kilometrosEstimados?: IntNullableFilter<"Viaje"> | number | null
    kilometrosReales?: IntNullableFilter<"Viaje"> | number | null
    tarifa?: DecimalFilter<"Viaje"> | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFilter<"Viaje"> | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFilter<"Viaje"> | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: DateTimeNullableFilter<"Viaje"> | Date | string | null
    diasCredito?: IntFilter<"Viaje"> | number
    montoPagoChofer?: DecimalNullableFilter<"Viaje"> | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFilter<"Viaje"> | $Enums.EstadoViaje
    observaciones?: StringNullableFilter<"Viaje"> | string | null
    creadoEn?: DateTimeFilter<"Viaje"> | Date | string
    actualizadoEn?: DateTimeFilter<"Viaje"> | Date | string
  }

  export type MantenimientoUpsertWithWhereUniqueWithoutVehiculoInput = {
    where: MantenimientoWhereUniqueInput
    update: XOR<MantenimientoUpdateWithoutVehiculoInput, MantenimientoUncheckedUpdateWithoutVehiculoInput>
    create: XOR<MantenimientoCreateWithoutVehiculoInput, MantenimientoUncheckedCreateWithoutVehiculoInput>
  }

  export type MantenimientoUpdateWithWhereUniqueWithoutVehiculoInput = {
    where: MantenimientoWhereUniqueInput
    data: XOR<MantenimientoUpdateWithoutVehiculoInput, MantenimientoUncheckedUpdateWithoutVehiculoInput>
  }

  export type MantenimientoUpdateManyWithWhereWithoutVehiculoInput = {
    where: MantenimientoScalarWhereInput
    data: XOR<MantenimientoUpdateManyMutationInput, MantenimientoUncheckedUpdateManyWithoutVehiculoInput>
  }

  export type MantenimientoScalarWhereInput = {
    AND?: MantenimientoScalarWhereInput | MantenimientoScalarWhereInput[]
    OR?: MantenimientoScalarWhereInput[]
    NOT?: MantenimientoScalarWhereInput | MantenimientoScalarWhereInput[]
    id?: IntFilter<"Mantenimiento"> | number
    vehiculoId?: IntFilter<"Mantenimiento"> | number
    tipo?: EnumTipoMantenimientoFilter<"Mantenimiento"> | $Enums.TipoMantenimiento
    estado?: EnumEstadoMantenimientoFilter<"Mantenimiento"> | $Enums.EstadoMantenimiento
    descripcion?: StringNullableFilter<"Mantenimiento"> | string | null
    taller?: StringNullableFilter<"Mantenimiento"> | string | null
    esExterno?: BoolFilter<"Mantenimiento"> | boolean
    costoManoObra?: DecimalFilter<"Mantenimiento"> | Decimal | DecimalJsLike | number | string
    costoRepuestos?: DecimalFilter<"Mantenimiento"> | Decimal | DecimalJsLike | number | string
    costoTotal?: DecimalFilter<"Mantenimiento"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter<"Mantenimiento"> | Date | string
    fechaInicio?: DateTimeNullableFilter<"Mantenimiento"> | Date | string | null
    fechaFin?: DateTimeNullableFilter<"Mantenimiento"> | Date | string | null
    kilometrajeAlMomento?: IntNullableFilter<"Mantenimiento"> | number | null
    proximaFecha?: DateTimeNullableFilter<"Mantenimiento"> | Date | string | null
    proximoKilometraje?: IntNullableFilter<"Mantenimiento"> | number | null
    comprobanteId?: IntNullableFilter<"Mantenimiento"> | number | null
    creadoEn?: DateTimeFilter<"Mantenimiento"> | Date | string
    actualizadoEn?: DateTimeFilter<"Mantenimiento"> | Date | string
  }

  export type ViajeCreateWithoutChoferInput = {
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    vehiculo: VehiculoCreateNestedOneWithoutViajesInput
    cliente: ClienteCreateNestedOneWithoutViajesInput
    material: MaterialCreateNestedOneWithoutViajesInput
    gastos?: GastoViajeCreateNestedManyWithoutViajeInput
    pagos?: PagoChoferCreateNestedManyWithoutViajeInput
  }

  export type ViajeUncheckedCreateWithoutChoferInput = {
    id?: number
    vehiculoId: number
    clienteId: number
    materialId: number
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    gastos?: GastoViajeUncheckedCreateNestedManyWithoutViajeInput
    pagos?: PagoChoferUncheckedCreateNestedManyWithoutViajeInput
  }

  export type ViajeCreateOrConnectWithoutChoferInput = {
    where: ViajeWhereUniqueInput
    create: XOR<ViajeCreateWithoutChoferInput, ViajeUncheckedCreateWithoutChoferInput>
  }

  export type ViajeCreateManyChoferInputEnvelope = {
    data: ViajeCreateManyChoferInput | ViajeCreateManyChoferInput[]
    skipDuplicates?: boolean
  }

  export type PagoChoferCreateWithoutChoferInput = {
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    estado?: $Enums.EstadoPagoChofer
    fechaPagoReal?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    comprobante?: ComprobanteCreateNestedOneWithoutPagosChoferInput
    viaje?: ViajeCreateNestedOneWithoutPagosInput
  }

  export type PagoChoferUncheckedCreateWithoutChoferInput = {
    id?: number
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    estado?: $Enums.EstadoPagoChofer
    fechaPagoReal?: Date | string | null
    comprobanteId?: number | null
    viajeId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type PagoChoferCreateOrConnectWithoutChoferInput = {
    where: PagoChoferWhereUniqueInput
    create: XOR<PagoChoferCreateWithoutChoferInput, PagoChoferUncheckedCreateWithoutChoferInput>
  }

  export type PagoChoferCreateManyChoferInputEnvelope = {
    data: PagoChoferCreateManyChoferInput | PagoChoferCreateManyChoferInput[]
    skipDuplicates?: boolean
  }

  export type ViajeUpsertWithWhereUniqueWithoutChoferInput = {
    where: ViajeWhereUniqueInput
    update: XOR<ViajeUpdateWithoutChoferInput, ViajeUncheckedUpdateWithoutChoferInput>
    create: XOR<ViajeCreateWithoutChoferInput, ViajeUncheckedCreateWithoutChoferInput>
  }

  export type ViajeUpdateWithWhereUniqueWithoutChoferInput = {
    where: ViajeWhereUniqueInput
    data: XOR<ViajeUpdateWithoutChoferInput, ViajeUncheckedUpdateWithoutChoferInput>
  }

  export type ViajeUpdateManyWithWhereWithoutChoferInput = {
    where: ViajeScalarWhereInput
    data: XOR<ViajeUpdateManyMutationInput, ViajeUncheckedUpdateManyWithoutChoferInput>
  }

  export type PagoChoferUpsertWithWhereUniqueWithoutChoferInput = {
    where: PagoChoferWhereUniqueInput
    update: XOR<PagoChoferUpdateWithoutChoferInput, PagoChoferUncheckedUpdateWithoutChoferInput>
    create: XOR<PagoChoferCreateWithoutChoferInput, PagoChoferUncheckedCreateWithoutChoferInput>
  }

  export type PagoChoferUpdateWithWhereUniqueWithoutChoferInput = {
    where: PagoChoferWhereUniqueInput
    data: XOR<PagoChoferUpdateWithoutChoferInput, PagoChoferUncheckedUpdateWithoutChoferInput>
  }

  export type PagoChoferUpdateManyWithWhereWithoutChoferInput = {
    where: PagoChoferScalarWhereInput
    data: XOR<PagoChoferUpdateManyMutationInput, PagoChoferUncheckedUpdateManyWithoutChoferInput>
  }

  export type PagoChoferScalarWhereInput = {
    AND?: PagoChoferScalarWhereInput | PagoChoferScalarWhereInput[]
    OR?: PagoChoferScalarWhereInput[]
    NOT?: PagoChoferScalarWhereInput | PagoChoferScalarWhereInput[]
    id?: IntFilter<"PagoChofer"> | number
    choferId?: IntFilter<"PagoChofer"> | number
    monto?: DecimalFilter<"PagoChofer"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter<"PagoChofer"> | Date | string
    metodoPago?: EnumMetodoPagoFilter<"PagoChofer"> | $Enums.MetodoPago
    descripcion?: StringNullableFilter<"PagoChofer"> | string | null
    estado?: EnumEstadoPagoChoferFilter<"PagoChofer"> | $Enums.EstadoPagoChofer
    fechaPagoReal?: DateTimeNullableFilter<"PagoChofer"> | Date | string | null
    comprobanteId?: IntNullableFilter<"PagoChofer"> | number | null
    viajeId?: IntNullableFilter<"PagoChofer"> | number | null
    creadoEn?: DateTimeFilter<"PagoChofer"> | Date | string
    actualizadoEn?: DateTimeFilter<"PagoChofer"> | Date | string
  }

  export type ViajeCreateWithoutClienteInput = {
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    vehiculo: VehiculoCreateNestedOneWithoutViajesInput
    chofer: ChoferCreateNestedOneWithoutViajesInput
    material: MaterialCreateNestedOneWithoutViajesInput
    gastos?: GastoViajeCreateNestedManyWithoutViajeInput
    pagos?: PagoChoferCreateNestedManyWithoutViajeInput
  }

  export type ViajeUncheckedCreateWithoutClienteInput = {
    id?: number
    vehiculoId: number
    choferId: number
    materialId: number
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    gastos?: GastoViajeUncheckedCreateNestedManyWithoutViajeInput
    pagos?: PagoChoferUncheckedCreateNestedManyWithoutViajeInput
  }

  export type ViajeCreateOrConnectWithoutClienteInput = {
    where: ViajeWhereUniqueInput
    create: XOR<ViajeCreateWithoutClienteInput, ViajeUncheckedCreateWithoutClienteInput>
  }

  export type ViajeCreateManyClienteInputEnvelope = {
    data: ViajeCreateManyClienteInput | ViajeCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type ViajeUpsertWithWhereUniqueWithoutClienteInput = {
    where: ViajeWhereUniqueInput
    update: XOR<ViajeUpdateWithoutClienteInput, ViajeUncheckedUpdateWithoutClienteInput>
    create: XOR<ViajeCreateWithoutClienteInput, ViajeUncheckedCreateWithoutClienteInput>
  }

  export type ViajeUpdateWithWhereUniqueWithoutClienteInput = {
    where: ViajeWhereUniqueInput
    data: XOR<ViajeUpdateWithoutClienteInput, ViajeUncheckedUpdateWithoutClienteInput>
  }

  export type ViajeUpdateManyWithWhereWithoutClienteInput = {
    where: ViajeScalarWhereInput
    data: XOR<ViajeUpdateManyMutationInput, ViajeUncheckedUpdateManyWithoutClienteInput>
  }

  export type ViajeCreateWithoutMaterialInput = {
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    vehiculo: VehiculoCreateNestedOneWithoutViajesInput
    chofer: ChoferCreateNestedOneWithoutViajesInput
    cliente: ClienteCreateNestedOneWithoutViajesInput
    gastos?: GastoViajeCreateNestedManyWithoutViajeInput
    pagos?: PagoChoferCreateNestedManyWithoutViajeInput
  }

  export type ViajeUncheckedCreateWithoutMaterialInput = {
    id?: number
    vehiculoId: number
    choferId: number
    clienteId: number
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    gastos?: GastoViajeUncheckedCreateNestedManyWithoutViajeInput
    pagos?: PagoChoferUncheckedCreateNestedManyWithoutViajeInput
  }

  export type ViajeCreateOrConnectWithoutMaterialInput = {
    where: ViajeWhereUniqueInput
    create: XOR<ViajeCreateWithoutMaterialInput, ViajeUncheckedCreateWithoutMaterialInput>
  }

  export type ViajeCreateManyMaterialInputEnvelope = {
    data: ViajeCreateManyMaterialInput | ViajeCreateManyMaterialInput[]
    skipDuplicates?: boolean
  }

  export type ViajeUpsertWithWhereUniqueWithoutMaterialInput = {
    where: ViajeWhereUniqueInput
    update: XOR<ViajeUpdateWithoutMaterialInput, ViajeUncheckedUpdateWithoutMaterialInput>
    create: XOR<ViajeCreateWithoutMaterialInput, ViajeUncheckedCreateWithoutMaterialInput>
  }

  export type ViajeUpdateWithWhereUniqueWithoutMaterialInput = {
    where: ViajeWhereUniqueInput
    data: XOR<ViajeUpdateWithoutMaterialInput, ViajeUncheckedUpdateWithoutMaterialInput>
  }

  export type ViajeUpdateManyWithWhereWithoutMaterialInput = {
    where: ViajeScalarWhereInput
    data: XOR<ViajeUpdateManyMutationInput, ViajeUncheckedUpdateManyWithoutMaterialInput>
  }

  export type VehiculoCreateWithoutViajesInput = {
    placa: string
    marca: string
    modelo: string
    anio: number
    tipo: string
    capacidad: string
    estado?: $Enums.EstadoVehiculo
    kilometrajeActual?: number
    fechaUltimoMantenimiento?: Date | string | null
    fechaProximoMantenimiento?: Date | string | null
    fechaVencimientoSoat?: Date | string | null
    fechaVencimientoSeguro?: Date | string | null
    fechaVencimientoMatricula?: Date | string | null
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    mantenimientos?: MantenimientoCreateNestedManyWithoutVehiculoInput
  }

  export type VehiculoUncheckedCreateWithoutViajesInput = {
    id?: number
    placa: string
    marca: string
    modelo: string
    anio: number
    tipo: string
    capacidad: string
    estado?: $Enums.EstadoVehiculo
    kilometrajeActual?: number
    fechaUltimoMantenimiento?: Date | string | null
    fechaProximoMantenimiento?: Date | string | null
    fechaVencimientoSoat?: Date | string | null
    fechaVencimientoSeguro?: Date | string | null
    fechaVencimientoMatricula?: Date | string | null
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    mantenimientos?: MantenimientoUncheckedCreateNestedManyWithoutVehiculoInput
  }

  export type VehiculoCreateOrConnectWithoutViajesInput = {
    where: VehiculoWhereUniqueInput
    create: XOR<VehiculoCreateWithoutViajesInput, VehiculoUncheckedCreateWithoutViajesInput>
  }

  export type ChoferCreateWithoutViajesInput = {
    nombres: string
    apellidos: string
    documentoId: string
    telefono?: string | null
    fechaVencimientoLicencia?: Date | string | null
    correo?: string | null
    estado?: $Enums.EstadoChofer
    modalidadPago?: $Enums.ModalidadPago
    metodoPago?: $Enums.MetodoPago
    banco?: string | null
    numeroCuenta?: string | null
    sueldoMensual?: Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: Date | string | null
    diaPago?: number | null
    pagoQuincenal?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    pagos?: PagoChoferCreateNestedManyWithoutChoferInput
  }

  export type ChoferUncheckedCreateWithoutViajesInput = {
    id?: number
    nombres: string
    apellidos: string
    documentoId: string
    telefono?: string | null
    fechaVencimientoLicencia?: Date | string | null
    correo?: string | null
    estado?: $Enums.EstadoChofer
    modalidadPago?: $Enums.ModalidadPago
    metodoPago?: $Enums.MetodoPago
    banco?: string | null
    numeroCuenta?: string | null
    sueldoMensual?: Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: Date | string | null
    diaPago?: number | null
    pagoQuincenal?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    pagos?: PagoChoferUncheckedCreateNestedManyWithoutChoferInput
  }

  export type ChoferCreateOrConnectWithoutViajesInput = {
    where: ChoferWhereUniqueInput
    create: XOR<ChoferCreateWithoutViajesInput, ChoferUncheckedCreateWithoutViajesInput>
  }

  export type ClienteCreateWithoutViajesInput = {
    nombreRazonSocial: string
    documentoId: string
    telefono?: string | null
    correo?: string | null
    direccion?: string | null
    sector?: string | null
    estado?: $Enums.EstadoCliente
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
  }

  export type ClienteUncheckedCreateWithoutViajesInput = {
    id?: number
    nombreRazonSocial: string
    documentoId: string
    telefono?: string | null
    correo?: string | null
    direccion?: string | null
    sector?: string | null
    estado?: $Enums.EstadoCliente
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
  }

  export type ClienteCreateOrConnectWithoutViajesInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutViajesInput, ClienteUncheckedCreateWithoutViajesInput>
  }

  export type MaterialCreateWithoutViajesInput = {
    nombre: string
    unidadMedida: string
    esPeligroso?: boolean
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type MaterialUncheckedCreateWithoutViajesInput = {
    id?: number
    nombre: string
    unidadMedida: string
    esPeligroso?: boolean
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type MaterialCreateOrConnectWithoutViajesInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutViajesInput, MaterialUncheckedCreateWithoutViajesInput>
  }

  export type GastoViajeCreateWithoutViajeInput = {
    tipoGasto: $Enums.TipoGasto
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    comprobante?: ComprobanteCreateNestedOneWithoutGastosViajeInput
  }

  export type GastoViajeUncheckedCreateWithoutViajeInput = {
    id?: number
    tipoGasto: $Enums.TipoGasto
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    comprobanteId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type GastoViajeCreateOrConnectWithoutViajeInput = {
    where: GastoViajeWhereUniqueInput
    create: XOR<GastoViajeCreateWithoutViajeInput, GastoViajeUncheckedCreateWithoutViajeInput>
  }

  export type GastoViajeCreateManyViajeInputEnvelope = {
    data: GastoViajeCreateManyViajeInput | GastoViajeCreateManyViajeInput[]
    skipDuplicates?: boolean
  }

  export type PagoChoferCreateWithoutViajeInput = {
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    estado?: $Enums.EstadoPagoChofer
    fechaPagoReal?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    chofer: ChoferCreateNestedOneWithoutPagosInput
    comprobante?: ComprobanteCreateNestedOneWithoutPagosChoferInput
  }

  export type PagoChoferUncheckedCreateWithoutViajeInput = {
    id?: number
    choferId: number
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    estado?: $Enums.EstadoPagoChofer
    fechaPagoReal?: Date | string | null
    comprobanteId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type PagoChoferCreateOrConnectWithoutViajeInput = {
    where: PagoChoferWhereUniqueInput
    create: XOR<PagoChoferCreateWithoutViajeInput, PagoChoferUncheckedCreateWithoutViajeInput>
  }

  export type PagoChoferCreateManyViajeInputEnvelope = {
    data: PagoChoferCreateManyViajeInput | PagoChoferCreateManyViajeInput[]
    skipDuplicates?: boolean
  }

  export type VehiculoUpsertWithoutViajesInput = {
    update: XOR<VehiculoUpdateWithoutViajesInput, VehiculoUncheckedUpdateWithoutViajesInput>
    create: XOR<VehiculoCreateWithoutViajesInput, VehiculoUncheckedCreateWithoutViajesInput>
    where?: VehiculoWhereInput
  }

  export type VehiculoUpdateToOneWithWhereWithoutViajesInput = {
    where?: VehiculoWhereInput
    data: XOR<VehiculoUpdateWithoutViajesInput, VehiculoUncheckedUpdateWithoutViajesInput>
  }

  export type VehiculoUpdateWithoutViajesInput = {
    placa?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    capacidad?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoVehiculoFieldUpdateOperationsInput | $Enums.EstadoVehiculo
    kilometrajeActual?: IntFieldUpdateOperationsInput | number
    fechaUltimoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaProximoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSoat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSeguro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoMatricula?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mantenimientos?: MantenimientoUpdateManyWithoutVehiculoNestedInput
  }

  export type VehiculoUncheckedUpdateWithoutViajesInput = {
    id?: IntFieldUpdateOperationsInput | number
    placa?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    capacidad?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoVehiculoFieldUpdateOperationsInput | $Enums.EstadoVehiculo
    kilometrajeActual?: IntFieldUpdateOperationsInput | number
    fechaUltimoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaProximoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSoat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSeguro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoMatricula?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mantenimientos?: MantenimientoUncheckedUpdateManyWithoutVehiculoNestedInput
  }

  export type ChoferUpsertWithoutViajesInput = {
    update: XOR<ChoferUpdateWithoutViajesInput, ChoferUncheckedUpdateWithoutViajesInput>
    create: XOR<ChoferCreateWithoutViajesInput, ChoferUncheckedCreateWithoutViajesInput>
    where?: ChoferWhereInput
  }

  export type ChoferUpdateToOneWithWhereWithoutViajesInput = {
    where?: ChoferWhereInput
    data: XOR<ChoferUpdateWithoutViajesInput, ChoferUncheckedUpdateWithoutViajesInput>
  }

  export type ChoferUpdateWithoutViajesInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaVencimientoLicencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoChoferFieldUpdateOperationsInput | $Enums.EstadoChofer
    modalidadPago?: EnumModalidadPagoFieldUpdateOperationsInput | $Enums.ModalidadPago
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    banco?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCuenta?: NullableStringFieldUpdateOperationsInput | string | null
    sueldoMensual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diaPago?: NullableIntFieldUpdateOperationsInput | number | null
    pagoQuincenal?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pagos?: PagoChoferUpdateManyWithoutChoferNestedInput
  }

  export type ChoferUncheckedUpdateWithoutViajesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaVencimientoLicencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoChoferFieldUpdateOperationsInput | $Enums.EstadoChofer
    modalidadPago?: EnumModalidadPagoFieldUpdateOperationsInput | $Enums.ModalidadPago
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    banco?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCuenta?: NullableStringFieldUpdateOperationsInput | string | null
    sueldoMensual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diaPago?: NullableIntFieldUpdateOperationsInput | number | null
    pagoQuincenal?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pagos?: PagoChoferUncheckedUpdateManyWithoutChoferNestedInput
  }

  export type ClienteUpsertWithoutViajesInput = {
    update: XOR<ClienteUpdateWithoutViajesInput, ClienteUncheckedUpdateWithoutViajesInput>
    create: XOR<ClienteCreateWithoutViajesInput, ClienteUncheckedCreateWithoutViajesInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutViajesInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutViajesInput, ClienteUncheckedUpdateWithoutViajesInput>
  }

  export type ClienteUpdateWithoutViajesInput = {
    nombreRazonSocial?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoClienteFieldUpdateOperationsInput | $Enums.EstadoCliente
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClienteUncheckedUpdateWithoutViajesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreRazonSocial?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoClienteFieldUpdateOperationsInput | $Enums.EstadoCliente
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaterialUpsertWithoutViajesInput = {
    update: XOR<MaterialUpdateWithoutViajesInput, MaterialUncheckedUpdateWithoutViajesInput>
    create: XOR<MaterialCreateWithoutViajesInput, MaterialUncheckedCreateWithoutViajesInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutViajesInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutViajesInput, MaterialUncheckedUpdateWithoutViajesInput>
  }

  export type MaterialUpdateWithoutViajesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    unidadMedida?: StringFieldUpdateOperationsInput | string
    esPeligroso?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateWithoutViajesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    unidadMedida?: StringFieldUpdateOperationsInput | string
    esPeligroso?: BoolFieldUpdateOperationsInput | boolean
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GastoViajeUpsertWithWhereUniqueWithoutViajeInput = {
    where: GastoViajeWhereUniqueInput
    update: XOR<GastoViajeUpdateWithoutViajeInput, GastoViajeUncheckedUpdateWithoutViajeInput>
    create: XOR<GastoViajeCreateWithoutViajeInput, GastoViajeUncheckedCreateWithoutViajeInput>
  }

  export type GastoViajeUpdateWithWhereUniqueWithoutViajeInput = {
    where: GastoViajeWhereUniqueInput
    data: XOR<GastoViajeUpdateWithoutViajeInput, GastoViajeUncheckedUpdateWithoutViajeInput>
  }

  export type GastoViajeUpdateManyWithWhereWithoutViajeInput = {
    where: GastoViajeScalarWhereInput
    data: XOR<GastoViajeUpdateManyMutationInput, GastoViajeUncheckedUpdateManyWithoutViajeInput>
  }

  export type GastoViajeScalarWhereInput = {
    AND?: GastoViajeScalarWhereInput | GastoViajeScalarWhereInput[]
    OR?: GastoViajeScalarWhereInput[]
    NOT?: GastoViajeScalarWhereInput | GastoViajeScalarWhereInput[]
    id?: IntFilter<"GastoViaje"> | number
    viajeId?: IntFilter<"GastoViaje"> | number
    tipoGasto?: EnumTipoGastoFilter<"GastoViaje"> | $Enums.TipoGasto
    monto?: DecimalFilter<"GastoViaje"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter<"GastoViaje"> | Date | string
    metodoPago?: EnumMetodoPagoFilter<"GastoViaje"> | $Enums.MetodoPago
    descripcion?: StringNullableFilter<"GastoViaje"> | string | null
    comprobanteId?: IntNullableFilter<"GastoViaje"> | number | null
    creadoEn?: DateTimeFilter<"GastoViaje"> | Date | string
    actualizadoEn?: DateTimeFilter<"GastoViaje"> | Date | string
  }

  export type PagoChoferUpsertWithWhereUniqueWithoutViajeInput = {
    where: PagoChoferWhereUniqueInput
    update: XOR<PagoChoferUpdateWithoutViajeInput, PagoChoferUncheckedUpdateWithoutViajeInput>
    create: XOR<PagoChoferCreateWithoutViajeInput, PagoChoferUncheckedCreateWithoutViajeInput>
  }

  export type PagoChoferUpdateWithWhereUniqueWithoutViajeInput = {
    where: PagoChoferWhereUniqueInput
    data: XOR<PagoChoferUpdateWithoutViajeInput, PagoChoferUncheckedUpdateWithoutViajeInput>
  }

  export type PagoChoferUpdateManyWithWhereWithoutViajeInput = {
    where: PagoChoferScalarWhereInput
    data: XOR<PagoChoferUpdateManyMutationInput, PagoChoferUncheckedUpdateManyWithoutViajeInput>
  }

  export type ViajeCreateWithoutGastosInput = {
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    vehiculo: VehiculoCreateNestedOneWithoutViajesInput
    chofer: ChoferCreateNestedOneWithoutViajesInput
    cliente: ClienteCreateNestedOneWithoutViajesInput
    material: MaterialCreateNestedOneWithoutViajesInput
    pagos?: PagoChoferCreateNestedManyWithoutViajeInput
  }

  export type ViajeUncheckedCreateWithoutGastosInput = {
    id?: number
    vehiculoId: number
    choferId: number
    clienteId: number
    materialId: number
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    pagos?: PagoChoferUncheckedCreateNestedManyWithoutViajeInput
  }

  export type ViajeCreateOrConnectWithoutGastosInput = {
    where: ViajeWhereUniqueInput
    create: XOR<ViajeCreateWithoutGastosInput, ViajeUncheckedCreateWithoutGastosInput>
  }

  export type ComprobanteCreateWithoutGastosViajeInput = {
    tipo: $Enums.TipoComprobante
    referenciaId?: number | null
    url: string
    publicId: string
    nombreArchivoOriginal: string
    creadoEn?: Date | string
    mantenimientos?: MantenimientoCreateNestedManyWithoutComprobanteInput
    pagosChofer?: PagoChoferCreateNestedManyWithoutComprobanteInput
  }

  export type ComprobanteUncheckedCreateWithoutGastosViajeInput = {
    id?: number
    tipo: $Enums.TipoComprobante
    referenciaId?: number | null
    url: string
    publicId: string
    nombreArchivoOriginal: string
    creadoEn?: Date | string
    mantenimientos?: MantenimientoUncheckedCreateNestedManyWithoutComprobanteInput
    pagosChofer?: PagoChoferUncheckedCreateNestedManyWithoutComprobanteInput
  }

  export type ComprobanteCreateOrConnectWithoutGastosViajeInput = {
    where: ComprobanteWhereUniqueInput
    create: XOR<ComprobanteCreateWithoutGastosViajeInput, ComprobanteUncheckedCreateWithoutGastosViajeInput>
  }

  export type ViajeUpsertWithoutGastosInput = {
    update: XOR<ViajeUpdateWithoutGastosInput, ViajeUncheckedUpdateWithoutGastosInput>
    create: XOR<ViajeCreateWithoutGastosInput, ViajeUncheckedCreateWithoutGastosInput>
    where?: ViajeWhereInput
  }

  export type ViajeUpdateToOneWithWhereWithoutGastosInput = {
    where?: ViajeWhereInput
    data: XOR<ViajeUpdateWithoutGastosInput, ViajeUncheckedUpdateWithoutGastosInput>
  }

  export type ViajeUpdateWithoutGastosInput = {
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    vehiculo?: VehiculoUpdateOneRequiredWithoutViajesNestedInput
    chofer?: ChoferUpdateOneRequiredWithoutViajesNestedInput
    cliente?: ClienteUpdateOneRequiredWithoutViajesNestedInput
    material?: MaterialUpdateOneRequiredWithoutViajesNestedInput
    pagos?: PagoChoferUpdateManyWithoutViajeNestedInput
  }

  export type ViajeUncheckedUpdateWithoutGastosInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehiculoId?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    pagos?: PagoChoferUncheckedUpdateManyWithoutViajeNestedInput
  }

  export type ComprobanteUpsertWithoutGastosViajeInput = {
    update: XOR<ComprobanteUpdateWithoutGastosViajeInput, ComprobanteUncheckedUpdateWithoutGastosViajeInput>
    create: XOR<ComprobanteCreateWithoutGastosViajeInput, ComprobanteUncheckedCreateWithoutGastosViajeInput>
    where?: ComprobanteWhereInput
  }

  export type ComprobanteUpdateToOneWithWhereWithoutGastosViajeInput = {
    where?: ComprobanteWhereInput
    data: XOR<ComprobanteUpdateWithoutGastosViajeInput, ComprobanteUncheckedUpdateWithoutGastosViajeInput>
  }

  export type ComprobanteUpdateWithoutGastosViajeInput = {
    tipo?: EnumTipoComprobanteFieldUpdateOperationsInput | $Enums.TipoComprobante
    referenciaId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    nombreArchivoOriginal?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    mantenimientos?: MantenimientoUpdateManyWithoutComprobanteNestedInput
    pagosChofer?: PagoChoferUpdateManyWithoutComprobanteNestedInput
  }

  export type ComprobanteUncheckedUpdateWithoutGastosViajeInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoComprobanteFieldUpdateOperationsInput | $Enums.TipoComprobante
    referenciaId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    nombreArchivoOriginal?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    mantenimientos?: MantenimientoUncheckedUpdateManyWithoutComprobanteNestedInput
    pagosChofer?: PagoChoferUncheckedUpdateManyWithoutComprobanteNestedInput
  }

  export type GastoViajeCreateWithoutComprobanteInput = {
    tipoGasto: $Enums.TipoGasto
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    viaje: ViajeCreateNestedOneWithoutGastosInput
  }

  export type GastoViajeUncheckedCreateWithoutComprobanteInput = {
    id?: number
    viajeId: number
    tipoGasto: $Enums.TipoGasto
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type GastoViajeCreateOrConnectWithoutComprobanteInput = {
    where: GastoViajeWhereUniqueInput
    create: XOR<GastoViajeCreateWithoutComprobanteInput, GastoViajeUncheckedCreateWithoutComprobanteInput>
  }

  export type GastoViajeCreateManyComprobanteInputEnvelope = {
    data: GastoViajeCreateManyComprobanteInput | GastoViajeCreateManyComprobanteInput[]
    skipDuplicates?: boolean
  }

  export type MantenimientoCreateWithoutComprobanteInput = {
    tipo: $Enums.TipoMantenimiento
    estado?: $Enums.EstadoMantenimiento
    descripcion?: string | null
    taller?: string | null
    esExterno?: boolean
    costoManoObra?: Decimal | DecimalJsLike | number | string
    costoRepuestos?: Decimal | DecimalJsLike | number | string
    costoTotal?: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    kilometrajeAlMomento?: number | null
    proximaFecha?: Date | string | null
    proximoKilometraje?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    vehiculo: VehiculoCreateNestedOneWithoutMantenimientosInput
  }

  export type MantenimientoUncheckedCreateWithoutComprobanteInput = {
    id?: number
    vehiculoId: number
    tipo: $Enums.TipoMantenimiento
    estado?: $Enums.EstadoMantenimiento
    descripcion?: string | null
    taller?: string | null
    esExterno?: boolean
    costoManoObra?: Decimal | DecimalJsLike | number | string
    costoRepuestos?: Decimal | DecimalJsLike | number | string
    costoTotal?: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    kilometrajeAlMomento?: number | null
    proximaFecha?: Date | string | null
    proximoKilometraje?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type MantenimientoCreateOrConnectWithoutComprobanteInput = {
    where: MantenimientoWhereUniqueInput
    create: XOR<MantenimientoCreateWithoutComprobanteInput, MantenimientoUncheckedCreateWithoutComprobanteInput>
  }

  export type MantenimientoCreateManyComprobanteInputEnvelope = {
    data: MantenimientoCreateManyComprobanteInput | MantenimientoCreateManyComprobanteInput[]
    skipDuplicates?: boolean
  }

  export type PagoChoferCreateWithoutComprobanteInput = {
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    estado?: $Enums.EstadoPagoChofer
    fechaPagoReal?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    chofer: ChoferCreateNestedOneWithoutPagosInput
    viaje?: ViajeCreateNestedOneWithoutPagosInput
  }

  export type PagoChoferUncheckedCreateWithoutComprobanteInput = {
    id?: number
    choferId: number
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    estado?: $Enums.EstadoPagoChofer
    fechaPagoReal?: Date | string | null
    viajeId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type PagoChoferCreateOrConnectWithoutComprobanteInput = {
    where: PagoChoferWhereUniqueInput
    create: XOR<PagoChoferCreateWithoutComprobanteInput, PagoChoferUncheckedCreateWithoutComprobanteInput>
  }

  export type PagoChoferCreateManyComprobanteInputEnvelope = {
    data: PagoChoferCreateManyComprobanteInput | PagoChoferCreateManyComprobanteInput[]
    skipDuplicates?: boolean
  }

  export type GastoViajeUpsertWithWhereUniqueWithoutComprobanteInput = {
    where: GastoViajeWhereUniqueInput
    update: XOR<GastoViajeUpdateWithoutComprobanteInput, GastoViajeUncheckedUpdateWithoutComprobanteInput>
    create: XOR<GastoViajeCreateWithoutComprobanteInput, GastoViajeUncheckedCreateWithoutComprobanteInput>
  }

  export type GastoViajeUpdateWithWhereUniqueWithoutComprobanteInput = {
    where: GastoViajeWhereUniqueInput
    data: XOR<GastoViajeUpdateWithoutComprobanteInput, GastoViajeUncheckedUpdateWithoutComprobanteInput>
  }

  export type GastoViajeUpdateManyWithWhereWithoutComprobanteInput = {
    where: GastoViajeScalarWhereInput
    data: XOR<GastoViajeUpdateManyMutationInput, GastoViajeUncheckedUpdateManyWithoutComprobanteInput>
  }

  export type MantenimientoUpsertWithWhereUniqueWithoutComprobanteInput = {
    where: MantenimientoWhereUniqueInput
    update: XOR<MantenimientoUpdateWithoutComprobanteInput, MantenimientoUncheckedUpdateWithoutComprobanteInput>
    create: XOR<MantenimientoCreateWithoutComprobanteInput, MantenimientoUncheckedCreateWithoutComprobanteInput>
  }

  export type MantenimientoUpdateWithWhereUniqueWithoutComprobanteInput = {
    where: MantenimientoWhereUniqueInput
    data: XOR<MantenimientoUpdateWithoutComprobanteInput, MantenimientoUncheckedUpdateWithoutComprobanteInput>
  }

  export type MantenimientoUpdateManyWithWhereWithoutComprobanteInput = {
    where: MantenimientoScalarWhereInput
    data: XOR<MantenimientoUpdateManyMutationInput, MantenimientoUncheckedUpdateManyWithoutComprobanteInput>
  }

  export type PagoChoferUpsertWithWhereUniqueWithoutComprobanteInput = {
    where: PagoChoferWhereUniqueInput
    update: XOR<PagoChoferUpdateWithoutComprobanteInput, PagoChoferUncheckedUpdateWithoutComprobanteInput>
    create: XOR<PagoChoferCreateWithoutComprobanteInput, PagoChoferUncheckedCreateWithoutComprobanteInput>
  }

  export type PagoChoferUpdateWithWhereUniqueWithoutComprobanteInput = {
    where: PagoChoferWhereUniqueInput
    data: XOR<PagoChoferUpdateWithoutComprobanteInput, PagoChoferUncheckedUpdateWithoutComprobanteInput>
  }

  export type PagoChoferUpdateManyWithWhereWithoutComprobanteInput = {
    where: PagoChoferScalarWhereInput
    data: XOR<PagoChoferUpdateManyMutationInput, PagoChoferUncheckedUpdateManyWithoutComprobanteInput>
  }

  export type VehiculoCreateWithoutMantenimientosInput = {
    placa: string
    marca: string
    modelo: string
    anio: number
    tipo: string
    capacidad: string
    estado?: $Enums.EstadoVehiculo
    kilometrajeActual?: number
    fechaUltimoMantenimiento?: Date | string | null
    fechaProximoMantenimiento?: Date | string | null
    fechaVencimientoSoat?: Date | string | null
    fechaVencimientoSeguro?: Date | string | null
    fechaVencimientoMatricula?: Date | string | null
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    viajes?: ViajeCreateNestedManyWithoutVehiculoInput
  }

  export type VehiculoUncheckedCreateWithoutMantenimientosInput = {
    id?: number
    placa: string
    marca: string
    modelo: string
    anio: number
    tipo: string
    capacidad: string
    estado?: $Enums.EstadoVehiculo
    kilometrajeActual?: number
    fechaUltimoMantenimiento?: Date | string | null
    fechaProximoMantenimiento?: Date | string | null
    fechaVencimientoSoat?: Date | string | null
    fechaVencimientoSeguro?: Date | string | null
    fechaVencimientoMatricula?: Date | string | null
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    viajes?: ViajeUncheckedCreateNestedManyWithoutVehiculoInput
  }

  export type VehiculoCreateOrConnectWithoutMantenimientosInput = {
    where: VehiculoWhereUniqueInput
    create: XOR<VehiculoCreateWithoutMantenimientosInput, VehiculoUncheckedCreateWithoutMantenimientosInput>
  }

  export type ComprobanteCreateWithoutMantenimientosInput = {
    tipo: $Enums.TipoComprobante
    referenciaId?: number | null
    url: string
    publicId: string
    nombreArchivoOriginal: string
    creadoEn?: Date | string
    gastosViaje?: GastoViajeCreateNestedManyWithoutComprobanteInput
    pagosChofer?: PagoChoferCreateNestedManyWithoutComprobanteInput
  }

  export type ComprobanteUncheckedCreateWithoutMantenimientosInput = {
    id?: number
    tipo: $Enums.TipoComprobante
    referenciaId?: number | null
    url: string
    publicId: string
    nombreArchivoOriginal: string
    creadoEn?: Date | string
    gastosViaje?: GastoViajeUncheckedCreateNestedManyWithoutComprobanteInput
    pagosChofer?: PagoChoferUncheckedCreateNestedManyWithoutComprobanteInput
  }

  export type ComprobanteCreateOrConnectWithoutMantenimientosInput = {
    where: ComprobanteWhereUniqueInput
    create: XOR<ComprobanteCreateWithoutMantenimientosInput, ComprobanteUncheckedCreateWithoutMantenimientosInput>
  }

  export type VehiculoUpsertWithoutMantenimientosInput = {
    update: XOR<VehiculoUpdateWithoutMantenimientosInput, VehiculoUncheckedUpdateWithoutMantenimientosInput>
    create: XOR<VehiculoCreateWithoutMantenimientosInput, VehiculoUncheckedCreateWithoutMantenimientosInput>
    where?: VehiculoWhereInput
  }

  export type VehiculoUpdateToOneWithWhereWithoutMantenimientosInput = {
    where?: VehiculoWhereInput
    data: XOR<VehiculoUpdateWithoutMantenimientosInput, VehiculoUncheckedUpdateWithoutMantenimientosInput>
  }

  export type VehiculoUpdateWithoutMantenimientosInput = {
    placa?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    capacidad?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoVehiculoFieldUpdateOperationsInput | $Enums.EstadoVehiculo
    kilometrajeActual?: IntFieldUpdateOperationsInput | number
    fechaUltimoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaProximoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSoat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSeguro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoMatricula?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: ViajeUpdateManyWithoutVehiculoNestedInput
  }

  export type VehiculoUncheckedUpdateWithoutMantenimientosInput = {
    id?: IntFieldUpdateOperationsInput | number
    placa?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    capacidad?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoVehiculoFieldUpdateOperationsInput | $Enums.EstadoVehiculo
    kilometrajeActual?: IntFieldUpdateOperationsInput | number
    fechaUltimoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaProximoMantenimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSoat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoSeguro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaVencimientoMatricula?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: ViajeUncheckedUpdateManyWithoutVehiculoNestedInput
  }

  export type ComprobanteUpsertWithoutMantenimientosInput = {
    update: XOR<ComprobanteUpdateWithoutMantenimientosInput, ComprobanteUncheckedUpdateWithoutMantenimientosInput>
    create: XOR<ComprobanteCreateWithoutMantenimientosInput, ComprobanteUncheckedCreateWithoutMantenimientosInput>
    where?: ComprobanteWhereInput
  }

  export type ComprobanteUpdateToOneWithWhereWithoutMantenimientosInput = {
    where?: ComprobanteWhereInput
    data: XOR<ComprobanteUpdateWithoutMantenimientosInput, ComprobanteUncheckedUpdateWithoutMantenimientosInput>
  }

  export type ComprobanteUpdateWithoutMantenimientosInput = {
    tipo?: EnumTipoComprobanteFieldUpdateOperationsInput | $Enums.TipoComprobante
    referenciaId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    nombreArchivoOriginal?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    gastosViaje?: GastoViajeUpdateManyWithoutComprobanteNestedInput
    pagosChofer?: PagoChoferUpdateManyWithoutComprobanteNestedInput
  }

  export type ComprobanteUncheckedUpdateWithoutMantenimientosInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoComprobanteFieldUpdateOperationsInput | $Enums.TipoComprobante
    referenciaId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    nombreArchivoOriginal?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    gastosViaje?: GastoViajeUncheckedUpdateManyWithoutComprobanteNestedInput
    pagosChofer?: PagoChoferUncheckedUpdateManyWithoutComprobanteNestedInput
  }

  export type ChoferCreateWithoutPagosInput = {
    nombres: string
    apellidos: string
    documentoId: string
    telefono?: string | null
    fechaVencimientoLicencia?: Date | string | null
    correo?: string | null
    estado?: $Enums.EstadoChofer
    modalidadPago?: $Enums.ModalidadPago
    metodoPago?: $Enums.MetodoPago
    banco?: string | null
    numeroCuenta?: string | null
    sueldoMensual?: Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: Date | string | null
    diaPago?: number | null
    pagoQuincenal?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    viajes?: ViajeCreateNestedManyWithoutChoferInput
  }

  export type ChoferUncheckedCreateWithoutPagosInput = {
    id?: number
    nombres: string
    apellidos: string
    documentoId: string
    telefono?: string | null
    fechaVencimientoLicencia?: Date | string | null
    correo?: string | null
    estado?: $Enums.EstadoChofer
    modalidadPago?: $Enums.ModalidadPago
    metodoPago?: $Enums.MetodoPago
    banco?: string | null
    numeroCuenta?: string | null
    sueldoMensual?: Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: Date | string | null
    diaPago?: number | null
    pagoQuincenal?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
    viajes?: ViajeUncheckedCreateNestedManyWithoutChoferInput
  }

  export type ChoferCreateOrConnectWithoutPagosInput = {
    where: ChoferWhereUniqueInput
    create: XOR<ChoferCreateWithoutPagosInput, ChoferUncheckedCreateWithoutPagosInput>
  }

  export type ComprobanteCreateWithoutPagosChoferInput = {
    tipo: $Enums.TipoComprobante
    referenciaId?: number | null
    url: string
    publicId: string
    nombreArchivoOriginal: string
    creadoEn?: Date | string
    gastosViaje?: GastoViajeCreateNestedManyWithoutComprobanteInput
    mantenimientos?: MantenimientoCreateNestedManyWithoutComprobanteInput
  }

  export type ComprobanteUncheckedCreateWithoutPagosChoferInput = {
    id?: number
    tipo: $Enums.TipoComprobante
    referenciaId?: number | null
    url: string
    publicId: string
    nombreArchivoOriginal: string
    creadoEn?: Date | string
    gastosViaje?: GastoViajeUncheckedCreateNestedManyWithoutComprobanteInput
    mantenimientos?: MantenimientoUncheckedCreateNestedManyWithoutComprobanteInput
  }

  export type ComprobanteCreateOrConnectWithoutPagosChoferInput = {
    where: ComprobanteWhereUniqueInput
    create: XOR<ComprobanteCreateWithoutPagosChoferInput, ComprobanteUncheckedCreateWithoutPagosChoferInput>
  }

  export type ViajeCreateWithoutPagosInput = {
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    vehiculo: VehiculoCreateNestedOneWithoutViajesInput
    chofer: ChoferCreateNestedOneWithoutViajesInput
    cliente: ClienteCreateNestedOneWithoutViajesInput
    material: MaterialCreateNestedOneWithoutViajesInput
    gastos?: GastoViajeCreateNestedManyWithoutViajeInput
  }

  export type ViajeUncheckedCreateWithoutPagosInput = {
    id?: number
    vehiculoId: number
    choferId: number
    clienteId: number
    materialId: number
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    gastos?: GastoViajeUncheckedCreateNestedManyWithoutViajeInput
  }

  export type ViajeCreateOrConnectWithoutPagosInput = {
    where: ViajeWhereUniqueInput
    create: XOR<ViajeCreateWithoutPagosInput, ViajeUncheckedCreateWithoutPagosInput>
  }

  export type ChoferUpsertWithoutPagosInput = {
    update: XOR<ChoferUpdateWithoutPagosInput, ChoferUncheckedUpdateWithoutPagosInput>
    create: XOR<ChoferCreateWithoutPagosInput, ChoferUncheckedCreateWithoutPagosInput>
    where?: ChoferWhereInput
  }

  export type ChoferUpdateToOneWithWhereWithoutPagosInput = {
    where?: ChoferWhereInput
    data: XOR<ChoferUpdateWithoutPagosInput, ChoferUncheckedUpdateWithoutPagosInput>
  }

  export type ChoferUpdateWithoutPagosInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaVencimientoLicencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoChoferFieldUpdateOperationsInput | $Enums.EstadoChofer
    modalidadPago?: EnumModalidadPagoFieldUpdateOperationsInput | $Enums.ModalidadPago
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    banco?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCuenta?: NullableStringFieldUpdateOperationsInput | string | null
    sueldoMensual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diaPago?: NullableIntFieldUpdateOperationsInput | number | null
    pagoQuincenal?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: ViajeUpdateManyWithoutChoferNestedInput
  }

  export type ChoferUncheckedUpdateWithoutPagosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaVencimientoLicencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoChoferFieldUpdateOperationsInput | $Enums.EstadoChofer
    modalidadPago?: EnumModalidadPagoFieldUpdateOperationsInput | $Enums.ModalidadPago
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    banco?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCuenta?: NullableStringFieldUpdateOperationsInput | string | null
    sueldoMensual?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaContratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diaPago?: NullableIntFieldUpdateOperationsInput | number | null
    pagoQuincenal?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: ViajeUncheckedUpdateManyWithoutChoferNestedInput
  }

  export type ComprobanteUpsertWithoutPagosChoferInput = {
    update: XOR<ComprobanteUpdateWithoutPagosChoferInput, ComprobanteUncheckedUpdateWithoutPagosChoferInput>
    create: XOR<ComprobanteCreateWithoutPagosChoferInput, ComprobanteUncheckedCreateWithoutPagosChoferInput>
    where?: ComprobanteWhereInput
  }

  export type ComprobanteUpdateToOneWithWhereWithoutPagosChoferInput = {
    where?: ComprobanteWhereInput
    data: XOR<ComprobanteUpdateWithoutPagosChoferInput, ComprobanteUncheckedUpdateWithoutPagosChoferInput>
  }

  export type ComprobanteUpdateWithoutPagosChoferInput = {
    tipo?: EnumTipoComprobanteFieldUpdateOperationsInput | $Enums.TipoComprobante
    referenciaId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    nombreArchivoOriginal?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    gastosViaje?: GastoViajeUpdateManyWithoutComprobanteNestedInput
    mantenimientos?: MantenimientoUpdateManyWithoutComprobanteNestedInput
  }

  export type ComprobanteUncheckedUpdateWithoutPagosChoferInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoComprobanteFieldUpdateOperationsInput | $Enums.TipoComprobante
    referenciaId?: NullableIntFieldUpdateOperationsInput | number | null
    url?: StringFieldUpdateOperationsInput | string
    publicId?: StringFieldUpdateOperationsInput | string
    nombreArchivoOriginal?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    gastosViaje?: GastoViajeUncheckedUpdateManyWithoutComprobanteNestedInput
    mantenimientos?: MantenimientoUncheckedUpdateManyWithoutComprobanteNestedInput
  }

  export type ViajeUpsertWithoutPagosInput = {
    update: XOR<ViajeUpdateWithoutPagosInput, ViajeUncheckedUpdateWithoutPagosInput>
    create: XOR<ViajeCreateWithoutPagosInput, ViajeUncheckedCreateWithoutPagosInput>
    where?: ViajeWhereInput
  }

  export type ViajeUpdateToOneWithWhereWithoutPagosInput = {
    where?: ViajeWhereInput
    data: XOR<ViajeUpdateWithoutPagosInput, ViajeUncheckedUpdateWithoutPagosInput>
  }

  export type ViajeUpdateWithoutPagosInput = {
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    vehiculo?: VehiculoUpdateOneRequiredWithoutViajesNestedInput
    chofer?: ChoferUpdateOneRequiredWithoutViajesNestedInput
    cliente?: ClienteUpdateOneRequiredWithoutViajesNestedInput
    material?: MaterialUpdateOneRequiredWithoutViajesNestedInput
    gastos?: GastoViajeUpdateManyWithoutViajeNestedInput
  }

  export type ViajeUncheckedUpdateWithoutPagosInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehiculoId?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    gastos?: GastoViajeUncheckedUpdateManyWithoutViajeNestedInput
  }

  export type UsuarioCreateWithoutRegistrosAuditoriaInput = {
    nombreUsuario: string
    email: string
    passwordHash: string
    nombreCompleto: string
    rol?: $Enums.RolUsuario
    activo?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
  }

  export type UsuarioUncheckedCreateWithoutRegistrosAuditoriaInput = {
    id?: number
    nombreUsuario: string
    email: string
    passwordHash: string
    nombreCompleto: string
    rol?: $Enums.RolUsuario
    activo?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    deletedAt?: Date | string | null
  }

  export type UsuarioCreateOrConnectWithoutRegistrosAuditoriaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutRegistrosAuditoriaInput, UsuarioUncheckedCreateWithoutRegistrosAuditoriaInput>
  }

  export type UsuarioUpsertWithoutRegistrosAuditoriaInput = {
    update: XOR<UsuarioUpdateWithoutRegistrosAuditoriaInput, UsuarioUncheckedUpdateWithoutRegistrosAuditoriaInput>
    create: XOR<UsuarioCreateWithoutRegistrosAuditoriaInput, UsuarioUncheckedCreateWithoutRegistrosAuditoriaInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutRegistrosAuditoriaInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutRegistrosAuditoriaInput, UsuarioUncheckedUpdateWithoutRegistrosAuditoriaInput>
  }

  export type UsuarioUpdateWithoutRegistrosAuditoriaInput = {
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolUsuarioFieldUpdateOperationsInput | $Enums.RolUsuario
    activo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsuarioUncheckedUpdateWithoutRegistrosAuditoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombreUsuario?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolUsuarioFieldUpdateOperationsInput | $Enums.RolUsuario
    activo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RegistroAuditoriaCreateManyUsuarioInput = {
    id?: number
    accion: $Enums.AccionAuditoria
    entidad: string
    entidadId: number
    datosAnteriores?: NullableJsonNullValueInput | InputJsonValue
    datosNuevos?: NullableJsonNullValueInput | InputJsonValue
    fechaHora?: Date | string
    ipAddress?: string | null
  }

  export type RegistroAuditoriaUpdateWithoutUsuarioInput = {
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: IntFieldUpdateOperationsInput | number
    datosAnteriores?: NullableJsonNullValueInput | InputJsonValue
    datosNuevos?: NullableJsonNullValueInput | InputJsonValue
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegistroAuditoriaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: IntFieldUpdateOperationsInput | number
    datosAnteriores?: NullableJsonNullValueInput | InputJsonValue
    datosNuevos?: NullableJsonNullValueInput | InputJsonValue
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegistroAuditoriaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: IntFieldUpdateOperationsInput | number
    datosAnteriores?: NullableJsonNullValueInput | InputJsonValue
    datosNuevos?: NullableJsonNullValueInput | InputJsonValue
    fechaHora?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViajeCreateManyVehiculoInput = {
    id?: number
    choferId: number
    clienteId: number
    materialId: number
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type MantenimientoCreateManyVehiculoInput = {
    id?: number
    tipo: $Enums.TipoMantenimiento
    estado?: $Enums.EstadoMantenimiento
    descripcion?: string | null
    taller?: string | null
    esExterno?: boolean
    costoManoObra?: Decimal | DecimalJsLike | number | string
    costoRepuestos?: Decimal | DecimalJsLike | number | string
    costoTotal?: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    kilometrajeAlMomento?: number | null
    proximaFecha?: Date | string | null
    proximoKilometraje?: number | null
    comprobanteId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type ViajeUpdateWithoutVehiculoInput = {
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    chofer?: ChoferUpdateOneRequiredWithoutViajesNestedInput
    cliente?: ClienteUpdateOneRequiredWithoutViajesNestedInput
    material?: MaterialUpdateOneRequiredWithoutViajesNestedInput
    gastos?: GastoViajeUpdateManyWithoutViajeNestedInput
    pagos?: PagoChoferUpdateManyWithoutViajeNestedInput
  }

  export type ViajeUncheckedUpdateWithoutVehiculoInput = {
    id?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    gastos?: GastoViajeUncheckedUpdateManyWithoutViajeNestedInput
    pagos?: PagoChoferUncheckedUpdateManyWithoutViajeNestedInput
  }

  export type ViajeUncheckedUpdateManyWithoutVehiculoInput = {
    id?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MantenimientoUpdateWithoutVehiculoInput = {
    tipo?: EnumTipoMantenimientoFieldUpdateOperationsInput | $Enums.TipoMantenimiento
    estado?: EnumEstadoMantenimientoFieldUpdateOperationsInput | $Enums.EstadoMantenimiento
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    taller?: NullableStringFieldUpdateOperationsInput | string | null
    esExterno?: BoolFieldUpdateOperationsInput | boolean
    costoManoObra?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoRepuestos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrajeAlMomento?: NullableIntFieldUpdateOperationsInput | number | null
    proximaFecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proximoKilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    comprobante?: ComprobanteUpdateOneWithoutMantenimientosNestedInput
  }

  export type MantenimientoUncheckedUpdateWithoutVehiculoInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoMantenimientoFieldUpdateOperationsInput | $Enums.TipoMantenimiento
    estado?: EnumEstadoMantenimientoFieldUpdateOperationsInput | $Enums.EstadoMantenimiento
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    taller?: NullableStringFieldUpdateOperationsInput | string | null
    esExterno?: BoolFieldUpdateOperationsInput | boolean
    costoManoObra?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoRepuestos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrajeAlMomento?: NullableIntFieldUpdateOperationsInput | number | null
    proximaFecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proximoKilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    comprobanteId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MantenimientoUncheckedUpdateManyWithoutVehiculoInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoMantenimientoFieldUpdateOperationsInput | $Enums.TipoMantenimiento
    estado?: EnumEstadoMantenimientoFieldUpdateOperationsInput | $Enums.EstadoMantenimiento
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    taller?: NullableStringFieldUpdateOperationsInput | string | null
    esExterno?: BoolFieldUpdateOperationsInput | boolean
    costoManoObra?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoRepuestos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrajeAlMomento?: NullableIntFieldUpdateOperationsInput | number | null
    proximaFecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proximoKilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    comprobanteId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViajeCreateManyChoferInput = {
    id?: number
    vehiculoId: number
    clienteId: number
    materialId: number
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type PagoChoferCreateManyChoferInput = {
    id?: number
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    estado?: $Enums.EstadoPagoChofer
    fechaPagoReal?: Date | string | null
    comprobanteId?: number | null
    viajeId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type ViajeUpdateWithoutChoferInput = {
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    vehiculo?: VehiculoUpdateOneRequiredWithoutViajesNestedInput
    cliente?: ClienteUpdateOneRequiredWithoutViajesNestedInput
    material?: MaterialUpdateOneRequiredWithoutViajesNestedInput
    gastos?: GastoViajeUpdateManyWithoutViajeNestedInput
    pagos?: PagoChoferUpdateManyWithoutViajeNestedInput
  }

  export type ViajeUncheckedUpdateWithoutChoferInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehiculoId?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    gastos?: GastoViajeUncheckedUpdateManyWithoutViajeNestedInput
    pagos?: PagoChoferUncheckedUpdateManyWithoutViajeNestedInput
  }

  export type ViajeUncheckedUpdateManyWithoutChoferInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehiculoId?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoChoferUpdateWithoutChoferInput = {
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoPagoChoferFieldUpdateOperationsInput | $Enums.EstadoPagoChofer
    fechaPagoReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    comprobante?: ComprobanteUpdateOneWithoutPagosChoferNestedInput
    viaje?: ViajeUpdateOneWithoutPagosNestedInput
  }

  export type PagoChoferUncheckedUpdateWithoutChoferInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoPagoChoferFieldUpdateOperationsInput | $Enums.EstadoPagoChofer
    fechaPagoReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comprobanteId?: NullableIntFieldUpdateOperationsInput | number | null
    viajeId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoChoferUncheckedUpdateManyWithoutChoferInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoPagoChoferFieldUpdateOperationsInput | $Enums.EstadoPagoChofer
    fechaPagoReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comprobanteId?: NullableIntFieldUpdateOperationsInput | number | null
    viajeId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViajeCreateManyClienteInput = {
    id?: number
    vehiculoId: number
    choferId: number
    materialId: number
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type ViajeUpdateWithoutClienteInput = {
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    vehiculo?: VehiculoUpdateOneRequiredWithoutViajesNestedInput
    chofer?: ChoferUpdateOneRequiredWithoutViajesNestedInput
    material?: MaterialUpdateOneRequiredWithoutViajesNestedInput
    gastos?: GastoViajeUpdateManyWithoutViajeNestedInput
    pagos?: PagoChoferUpdateManyWithoutViajeNestedInput
  }

  export type ViajeUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehiculoId?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    gastos?: GastoViajeUncheckedUpdateManyWithoutViajeNestedInput
    pagos?: PagoChoferUncheckedUpdateManyWithoutViajeNestedInput
  }

  export type ViajeUncheckedUpdateManyWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehiculoId?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViajeCreateManyMaterialInput = {
    id?: number
    vehiculoId: number
    choferId: number
    clienteId: number
    origen: string
    destino: string
    fechaSalida: Date | string
    fechaLlegadaEstimada?: Date | string | null
    fechaLlegadaReal?: Date | string | null
    kilometrosEstimados?: number | null
    kilometrosReales?: number | null
    tarifa: Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: $Enums.EstadoPagoCliente
    montoPagadoCliente?: Decimal | DecimalJsLike | number | string
    fechaLimitePago?: Date | string | null
    diasCredito?: number
    montoPagoChofer?: Decimal | DecimalJsLike | number | string | null
    estado?: $Enums.EstadoViaje
    observaciones?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type ViajeUpdateWithoutMaterialInput = {
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    vehiculo?: VehiculoUpdateOneRequiredWithoutViajesNestedInput
    chofer?: ChoferUpdateOneRequiredWithoutViajesNestedInput
    cliente?: ClienteUpdateOneRequiredWithoutViajesNestedInput
    gastos?: GastoViajeUpdateManyWithoutViajeNestedInput
    pagos?: PagoChoferUpdateManyWithoutViajeNestedInput
  }

  export type ViajeUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehiculoId?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    gastos?: GastoViajeUncheckedUpdateManyWithoutViajeNestedInput
    pagos?: PagoChoferUncheckedUpdateManyWithoutViajeNestedInput
  }

  export type ViajeUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehiculoId?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    origen?: StringFieldUpdateOperationsInput | string
    destino?: StringFieldUpdateOperationsInput | string
    fechaSalida?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLlegadaEstimada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaLlegadaReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrosEstimados?: NullableIntFieldUpdateOperationsInput | number | null
    kilometrosReales?: NullableIntFieldUpdateOperationsInput | number | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estadoPagoCliente?: EnumEstadoPagoClienteFieldUpdateOperationsInput | $Enums.EstadoPagoCliente
    montoPagadoCliente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaLimitePago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diasCredito?: IntFieldUpdateOperationsInput | number
    montoPagoChofer?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estado?: EnumEstadoViajeFieldUpdateOperationsInput | $Enums.EstadoViaje
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GastoViajeCreateManyViajeInput = {
    id?: number
    tipoGasto: $Enums.TipoGasto
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    comprobanteId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type PagoChoferCreateManyViajeInput = {
    id?: number
    choferId: number
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    estado?: $Enums.EstadoPagoChofer
    fechaPagoReal?: Date | string | null
    comprobanteId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type GastoViajeUpdateWithoutViajeInput = {
    tipoGasto?: EnumTipoGastoFieldUpdateOperationsInput | $Enums.TipoGasto
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    comprobante?: ComprobanteUpdateOneWithoutGastosViajeNestedInput
  }

  export type GastoViajeUncheckedUpdateWithoutViajeInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoGasto?: EnumTipoGastoFieldUpdateOperationsInput | $Enums.TipoGasto
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    comprobanteId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GastoViajeUncheckedUpdateManyWithoutViajeInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoGasto?: EnumTipoGastoFieldUpdateOperationsInput | $Enums.TipoGasto
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    comprobanteId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoChoferUpdateWithoutViajeInput = {
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoPagoChoferFieldUpdateOperationsInput | $Enums.EstadoPagoChofer
    fechaPagoReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    chofer?: ChoferUpdateOneRequiredWithoutPagosNestedInput
    comprobante?: ComprobanteUpdateOneWithoutPagosChoferNestedInput
  }

  export type PagoChoferUncheckedUpdateWithoutViajeInput = {
    id?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoPagoChoferFieldUpdateOperationsInput | $Enums.EstadoPagoChofer
    fechaPagoReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comprobanteId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoChoferUncheckedUpdateManyWithoutViajeInput = {
    id?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoPagoChoferFieldUpdateOperationsInput | $Enums.EstadoPagoChofer
    fechaPagoReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comprobanteId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GastoViajeCreateManyComprobanteInput = {
    id?: number
    viajeId: number
    tipoGasto: $Enums.TipoGasto
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type MantenimientoCreateManyComprobanteInput = {
    id?: number
    vehiculoId: number
    tipo: $Enums.TipoMantenimiento
    estado?: $Enums.EstadoMantenimiento
    descripcion?: string | null
    taller?: string | null
    esExterno?: boolean
    costoManoObra?: Decimal | DecimalJsLike | number | string
    costoRepuestos?: Decimal | DecimalJsLike | number | string
    costoTotal?: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    kilometrajeAlMomento?: number | null
    proximaFecha?: Date | string | null
    proximoKilometraje?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type PagoChoferCreateManyComprobanteInput = {
    id?: number
    choferId: number
    monto: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    metodoPago?: $Enums.MetodoPago
    descripcion?: string | null
    estado?: $Enums.EstadoPagoChofer
    fechaPagoReal?: Date | string | null
    viajeId?: number | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type GastoViajeUpdateWithoutComprobanteInput = {
    tipoGasto?: EnumTipoGastoFieldUpdateOperationsInput | $Enums.TipoGasto
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    viaje?: ViajeUpdateOneRequiredWithoutGastosNestedInput
  }

  export type GastoViajeUncheckedUpdateWithoutComprobanteInput = {
    id?: IntFieldUpdateOperationsInput | number
    viajeId?: IntFieldUpdateOperationsInput | number
    tipoGasto?: EnumTipoGastoFieldUpdateOperationsInput | $Enums.TipoGasto
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GastoViajeUncheckedUpdateManyWithoutComprobanteInput = {
    id?: IntFieldUpdateOperationsInput | number
    viajeId?: IntFieldUpdateOperationsInput | number
    tipoGasto?: EnumTipoGastoFieldUpdateOperationsInput | $Enums.TipoGasto
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MantenimientoUpdateWithoutComprobanteInput = {
    tipo?: EnumTipoMantenimientoFieldUpdateOperationsInput | $Enums.TipoMantenimiento
    estado?: EnumEstadoMantenimientoFieldUpdateOperationsInput | $Enums.EstadoMantenimiento
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    taller?: NullableStringFieldUpdateOperationsInput | string | null
    esExterno?: BoolFieldUpdateOperationsInput | boolean
    costoManoObra?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoRepuestos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrajeAlMomento?: NullableIntFieldUpdateOperationsInput | number | null
    proximaFecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proximoKilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    vehiculo?: VehiculoUpdateOneRequiredWithoutMantenimientosNestedInput
  }

  export type MantenimientoUncheckedUpdateWithoutComprobanteInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehiculoId?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoMantenimientoFieldUpdateOperationsInput | $Enums.TipoMantenimiento
    estado?: EnumEstadoMantenimientoFieldUpdateOperationsInput | $Enums.EstadoMantenimiento
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    taller?: NullableStringFieldUpdateOperationsInput | string | null
    esExterno?: BoolFieldUpdateOperationsInput | boolean
    costoManoObra?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoRepuestos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrajeAlMomento?: NullableIntFieldUpdateOperationsInput | number | null
    proximaFecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proximoKilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MantenimientoUncheckedUpdateManyWithoutComprobanteInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehiculoId?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoMantenimientoFieldUpdateOperationsInput | $Enums.TipoMantenimiento
    estado?: EnumEstadoMantenimientoFieldUpdateOperationsInput | $Enums.EstadoMantenimiento
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    taller?: NullableStringFieldUpdateOperationsInput | string | null
    esExterno?: BoolFieldUpdateOperationsInput | boolean
    costoManoObra?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoRepuestos?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kilometrajeAlMomento?: NullableIntFieldUpdateOperationsInput | number | null
    proximaFecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proximoKilometraje?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoChoferUpdateWithoutComprobanteInput = {
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoPagoChoferFieldUpdateOperationsInput | $Enums.EstadoPagoChofer
    fechaPagoReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    chofer?: ChoferUpdateOneRequiredWithoutPagosNestedInput
    viaje?: ViajeUpdateOneWithoutPagosNestedInput
  }

  export type PagoChoferUncheckedUpdateWithoutComprobanteInput = {
    id?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoPagoChoferFieldUpdateOperationsInput | $Enums.EstadoPagoChofer
    fechaPagoReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajeId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoChoferUncheckedUpdateManyWithoutComprobanteInput = {
    id?: IntFieldUpdateOperationsInput | number
    choferId?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    metodoPago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoPagoChoferFieldUpdateOperationsInput | $Enums.EstadoPagoChofer
    fechaPagoReal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajeId?: NullableIntFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehiculoCountOutputTypeDefaultArgs instead
     */
    export type VehiculoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehiculoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoferCountOutputTypeDefaultArgs instead
     */
    export type ChoferCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoferCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClienteCountOutputTypeDefaultArgs instead
     */
    export type ClienteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialCountOutputTypeDefaultArgs instead
     */
    export type MaterialCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ViajeCountOutputTypeDefaultArgs instead
     */
    export type ViajeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ViajeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComprobanteCountOutputTypeDefaultArgs instead
     */
    export type ComprobanteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComprobanteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehiculoDefaultArgs instead
     */
    export type VehiculoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehiculoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoferDefaultArgs instead
     */
    export type ChoferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoferDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClienteDefaultArgs instead
     */
    export type ClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialDefaultArgs instead
     */
    export type MaterialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ViajeDefaultArgs instead
     */
    export type ViajeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ViajeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GastoViajeDefaultArgs instead
     */
    export type GastoViajeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GastoViajeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComprobanteDefaultArgs instead
     */
    export type ComprobanteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComprobanteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MantenimientoDefaultArgs instead
     */
    export type MantenimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MantenimientoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PagoChoferDefaultArgs instead
     */
    export type PagoChoferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PagoChoferDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegistroAuditoriaDefaultArgs instead
     */
    export type RegistroAuditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegistroAuditoriaDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}